

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Evaluación de modelos &#8212; Machine Learning</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'model_evaluation';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Cadenas de Algoritmos y Pipelines" href="chains_pipelines.html" />
    <link rel="prev" title="Análisis de Componentes Principales" href="practical_pca.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/logo-uninorte.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/logo-uninorte.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Machine Learning
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="supervised_intro.html">Aprendizaje supervisado</a></li>
<li class="toctree-l1"><a class="reference internal" href="knn_model.html"><span class="math notranslate nohighlight">\(k\)</span>-Vecinos más cercanos</a></li>
<li class="toctree-l1"><a class="reference internal" href="linear_model.html">Modelos lineales</a></li>
<li class="toctree-l1"><a class="reference internal" href="bayes_model.html">Clasificadores Naive Bayes</a></li>
<li class="toctree-l1"><a class="reference internal" href="decisiontree_model.html">Árboles de decisión</a></li>

<li class="toctree-l1"><a class="reference internal" href="svm_model.html">Máquinas de vectores de soporte</a></li>
<li class="toctree-l1"><a class="reference internal" href="ann_model.html">Redes Neuronales y Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="practical_pca.html">Análisis de Componentes Principales</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Evaluación de modelos</a></li>
<li class="toctree-l1"><a class="reference internal" href="chains_pipelines.html">Cadenas de Algoritmos y Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Apéndice</a></li>
<li class="toctree-l1"><a class="reference internal" href="biblio.html">Bibliografía</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fmodel_evaluation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/model_evaluation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Evaluación de modelos</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-validation">Cross-Validation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-en-scikit-learn">Validación cruzada en scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ventajas-de-la-validacion-cruzada">Ventajas de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-estratificada-k-fold-y-otras-estrategias">Validación cruzada estratificada <span class="math notranslate nohighlight">\(k\)</span>-fold y otras estrategias</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mas-control-sobre-la-validacion-cruzada">Más control sobre la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-exclusion-leave-one-out">Validación cruzada con exclusión (leave-one-out)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-aleatoria-y-dividida">Validación cruzada aleatoria y dividida</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-grupos">Validación cruzada con grupos</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search">Grid Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-simple">Grid Search simple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">El peligro de sobreajustar los parámetros y el conjunto de validación</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-con-validacion-cruzada">Grid Search con validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisis-del-resultado-de-la-validacion-cruzada">Análisis del resultado de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-sobre-espacios-que-no-son-una-red">Búsqueda sobre espacios que no son una red</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-anidada">Validación cruzada anidada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">Paralelización de la validación cruzada y la búsqueda en red</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-evaluacion-y-scoring">Métricas de evaluación y scoring</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tenga-en-cuenta-el-objetivo-final">Tenga en cuenta el objetivo final</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-binaria">Métricas para la clasificación binaria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tipos-de-errores">Tipos de errores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjuntos-de-datos-desequilibrados">Conjuntos de datos desequilibrados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-de-confusion">Matrices de confusión</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#teniendo-en-cuenta-la-incertidumbre">Teniendo en cuenta la incertidumbre</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#curvas-precision-recall-y-roc">Curvas precision-recall y ROC</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caracteristicas-operativas-del-receptor-roc-y-auc">Características operativas del receptor (ROC) y AUC</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-multiclase">Métricas para la clasificación multiclase</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-regresion">Métricas de regresión</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">Uso de métricas de evaluación en la selección de modelos</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="evaluacion-de-modelos">
<h1>Evaluación de modelos<a class="headerlink" href="#evaluacion-de-modelos" title="Permalink to this heading">#</a></h1>
<ul class="simple">
<li><p>Después de haber discutido los fundamentos del <code class="docutils literal notranslate"><span class="pre">aprendizaje</span> <span class="pre">supervisado</span></code> y de sus <code class="docutils literal notranslate"><span class="pre">algoritmos</span></code>, nos adentraremos en la <code class="docutils literal notranslate"><span class="pre">evaluación</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">modelos</span></code> y en la <code class="docutils literal notranslate"><span class="pre">selección</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span></code>. Nos centraremos en los modelos supervisados, la <code class="docutils literal notranslate"><span class="pre">regresión</span></code> y la <code class="docutils literal notranslate"><span class="pre">clasificación</span></code>, ya que la evaluación y selección de modelos en el aprendizaje no supervisado suele ser un proceso muy cualitativo.</p></li>
<li><p>Para evaluar nuestros modelos supervisados, hasta ahora hemos dividido nuestro conjunto de datos en un conjunto de <code class="docutils literal notranslate"><span class="pre">entrenamiento</span></code> y un conjunto de <code class="docutils literal notranslate"><span class="pre">prueba</span></code> utilizando la función <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code>, hemos construido un modelo en el conjunto de entrenamiento llamando al método <code class="docutils literal notranslate"><span class="pre">fit</span></code>, y lo hemos evaluado en el conjunto de <code class="docutils literal notranslate"><span class="pre">prueba</span></code> utilizando el método <code class="docutils literal notranslate"><span class="pre">score</span></code>, que para la clasificación, calcula la <code class="docutils literal notranslate"><span class="pre">fracción</span> <span class="pre">de</span> <span class="pre">muestras</span> <span class="pre">correctamente</span> <span class="pre">clasificadas</span></code>. He aquí
un ejemplo de este proceso</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Creamos un conjunto de datos sintéticos</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dividimos los datos y las etiquetas en un conjunto de entrenamiento y otro de prueba</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Instanciar el modelo y ajustarlo al conjunto de entrenamiento</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Evaluar el modelo en el conjunto de prueba</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set score: 0.88
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Evaluar el modelo en el conjunto de entrenamiento</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Train set score: 0.91
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Recuerde que la razón por la que dividimos nuestros datos en conjuntos de entrenamiento y de prueba, es que estamos interesados en medir lo bien que nuestro modelo se generaliza a nuevos datos no vistos anteriormente. <code class="docutils literal notranslate"><span class="pre">No</span> <span class="pre">nos</span> <span class="pre">interesa</span> <span class="pre">lo</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">nuestro</span> <span class="pre">modelo</span> <span class="pre">se</span> <span class="pre">ajusta</span> <span class="pre">al</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento,</span> <span class="pre">sino</span> <span class="pre">lo</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">puede</span> <span class="pre">hacer</span> <span class="pre">predicciones</span> <span class="pre">sobre</span> <span class="pre">datos</span> <span class="pre">no</span> <span class="pre">observados</span> <span class="pre">durante</span> <span class="pre">el</span> <span class="pre">entrenamiento</span></code>.</p></li>
<li><p>En esta sección, ampliaremos dos aspectos de esta evaluación. En primer lugar, introduciremos la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span></code> (cross-validation), una forma más sólida de <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">el</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">generalización</span></code>, y discutiremos los métodos para <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">el</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">clasificación</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">regresión</span></code> que van más allá de las medidas por defecto de <code class="docutils literal notranslate"><span class="pre">precisión</span> <span class="pre">(accuracy)</span></code> y <span class="math notranslate nohighlight">\(R^2\)</span> proporcionadas por el método <code class="docutils literal notranslate"><span class="pre">score</span></code>. También hablaremos del <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code>, un método eficaz para ajustar los parámetros de los modelos supervisados y obtener el <code class="docutils literal notranslate"><span class="pre">mejor</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">generalización</span></code>.</p></li>
</ul>
<section id="cross-validation">
<h2>Cross-Validation<a class="headerlink" href="#cross-validation" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>La <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">(cross-validation)</span></code> es un <code class="docutils literal notranslate"><span class="pre">método</span> <span class="pre">estadístico</span></code> para evaluar el rendimiento de la generalización que es <code class="docutils literal notranslate"><span class="pre">más</span> <span class="pre">estable</span> <span class="pre">y</span> <span class="pre">exhaustivo</span></code> que el uso de una división en un conjunto de entrenamiento y otro de prueba. En la validación cruzada, <code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">datos</span> <span class="pre">se</span> <span class="pre">dividen</span> <span class="pre">repetidamente</span> <span class="pre">y</span> <span class="pre">se</span> <span class="pre">entrenan</span> <span class="pre">múltiples</span> <span class="pre">modelos</span></code>. La versión más utilizada de la validación cruzada es la <code class="docutils literal notranslate"><span class="pre">k-fold</span> <span class="pre">cross-validation</span></code>, donde <code class="docutils literal notranslate"><span class="pre">k</span></code> es un número <code class="docutils literal notranslate"><span class="pre">especificado</span> <span class="pre">por</span> <span class="pre">el</span> <span class="pre">usuario,</span> <span class="pre">normalmente</span> <span class="pre">5</span> <span class="pre">o</span> <span class="pre">10</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Cuando</span> <span class="pre">se</span> <span class="pre">realiza</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">five-fold,</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">se</span> <span class="pre">dividen</span> <span class="pre">primero</span> <span class="pre">en</span> <span class="pre">cinco</span> <span class="pre">partes</span> <span class="pre">de</span> <span class="pre">tamaño</span> <span class="pre">(aproximadamente)</span> <span class="pre">igual,</span> <span class="pre">llamadas</span> <span class="pre">pliegues</span> <span class="pre">(folds)</span></code>. A continuación, se entrena una secuencia de modelos. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">primer</span> <span class="pre">modelo</span> <span class="pre">se</span> <span class="pre">entrena</span> <span class="pre">utilizando</span> <span class="pre">el</span> <span class="pre">primer</span> <span class="pre">pliegue</span> <span class="pre">como</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba,</span> <span class="pre">y</span> <span class="pre">los</span> <span class="pre">pliegues</span> <span class="pre">restantes</span> <span class="pre">(2-5)</span> <span class="pre">se</span> <span class="pre">utilizan</span> <span class="pre">como</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento.</span> <span class="pre">El</span> <span class="pre">modelo</span> <span class="pre">se</span> <span class="pre">construye</span> <span class="pre">utilizando</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">pliegues</span> <span class="pre">2-5,</span> <span class="pre">y</span> <span class="pre">luego</span> <span class="pre">se</span> <span class="pre">evalúa</span> <span class="pre">accuracy</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">pliegue</span> <span class="pre">1</span></code>. A continuación, luego se construye otro modelo, esta vez utilizando el pliegue 2 como conjunto de prueba y los datos de los pliegues 1, 3, 4 y 5 como conjunto de entrenamiento. Este proceso se repite utilizando los pliegues 3, 4 y 5 como conjuntos de prueba. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">cada</span> <span class="pre">una</span> <span class="pre">de</span> <span class="pre">estas</span> <span class="pre">cinco</span> <span class="pre">divisiones</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">prueba,</span> <span class="pre">calculamos</span> <span class="pre">la</span> <span class="pre">accuracy</span></code>. Al final, hemos recogido cinco valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_cross_validation</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/aa557bdb5079f148667eb0825fd90cf07b0c8d074e9c1df1bb09be72ea85c648.png" src="_images/aa557bdb5079f148667eb0825fd90cf07b0c8d074e9c1df1bb09be72ea85c648.png" />
</div>
</div>
<ul class="simple">
<li><p>Normalmente, la primera quinta parte de los datos es conocida como el <code class="docutils literal notranslate"><span class="pre">primer</span> <span class="pre">fold</span></code>, la segunda quinta parte de los datos es el
<code class="docutils literal notranslate"><span class="pre">segundo</span> <span class="pre">fold</span></code>, y así sucesivamente.</p></li>
</ul>
<section id="validacion-cruzada-en-scikit-learn">
<h3>Validación cruzada en scikit-learn<a class="headerlink" href="#validacion-cruzada-en-scikit-learn" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>La validación cruzada se implementa en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> utilizando la función <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">model_selection</span></code>. <code class="docutils literal notranslate"><span class="pre">Los</span> <span class="pre">parámetros</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">función</span> <span class="pre">cross_val_score</span> <span class="pre">son,</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">que</span> <span class="pre">queremos</span> <span class="pre">evaluar,</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">las</span> <span class="pre">etiquetas</span> <span class="pre">reales</span></code>. Vamos a evaluar <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code>. Utilizaremos los parámetros por defecto de este modelo, mas adelante estudiaremos como conseguir los mas óptimos por medio de <code class="docutils literal notranslate"><span class="pre">grid-search</span></code>, por ahora solo estamos interesados en evaluar el modelo por defecto usando <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>. Para mas información acerca de los argumentos del modelo (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">sklearn.linear_model.LogisticRegression</a>).</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">);</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [0.96666667 1.         0.93333333 0.96666667 1.        ]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Por defecto, <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> realiza una <code class="docutils literal notranslate"><span class="pre">five-fold</span> <span class="pre">cross</span> <span class="pre">validation</span></code>, devolviendo cinco valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>. Podemos cambiar el número de pliegues <code class="docutils literal notranslate"><span class="pre">(folds)</span></code> utilizados, cambiando el parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [1.         0.93333333 1.         1.         0.93333333 0.93333333
 0.93333333 1.         1.         1.        ]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Una forma habitual de <code class="docutils literal notranslate"><span class="pre">resumir</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">es</span> <span class="pre">calcular</span> <span class="pre">la</span> <span class="pre">media</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">media</span></code> podemos concluir que, esperamos que el modelo sea de precisión en torno al 97% de media. Si observamos las cinco puntuaciones producidas por la validación cruzada de cinco pliegues <code class="docutils literal notranslate"><span class="pre">five-fold</span> <span class="pre">cross</span> <span class="pre">validation</span></code>, también podemos concluir que hay una varianza relativamente alta en la precisión entre pliegues, que va del 100% de precisión al 93.33% de precisión aproximadamente. Esto podría implicar que el modelo es muy <code class="docutils literal notranslate"><span class="pre">dependiente</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">pliegues</span> <span class="pre">particulares</span> <span class="pre">utilizados</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">entrenamiento</span></code>, pero también podría ser simplemente una <code class="docutils literal notranslate"><span class="pre">consecuencia</span> <span class="pre">del</span> <span class="pre">pequeño</span> <span class="pre">tamaño</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span></code>.</p></li>
</ul>
</section>
<section id="ventajas-de-la-validacion-cruzada">
<h3>Ventajas de la validación cruzada<a class="headerlink" href="#ventajas-de-la-validacion-cruzada" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Son varios los beneficios de utilizar la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span></code> en lugar de una única división en un conjunto de entrenamiento y otro de prueba. En primer lugar, recuerde que <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code> realiza una división aleatoria de los datos. Imaginemos que <code class="docutils literal notranslate"><span class="pre">tenemos</span> <span class="pre">&quot;suerte&quot;</span> <span class="pre">al</span> <span class="pre">dividir</span> <span class="pre">aleatoriamente</span> <span class="pre">los</span> <span class="pre">datos,</span> <span class="pre">y</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">ejemplos</span> <span class="pre">que</span> <span class="pre">son</span> <span class="pre">difíciles</span> <span class="pre">de</span> <span class="pre">clasificar</span> <span class="pre">acaban</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code>. En ese caso, <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">sólo</span> <span class="pre">contendrá</span> <span class="pre">ejemplos</span> <span class="pre">&quot;fáciles&quot;,</span> <span class="pre">y</span> <span class="pre">nuestra</span> <span class="pre">precisión</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">será</span> <span class="pre">irrealmente</span> <span class="pre">alto</span></code>. Por el contrario, <code class="docutils literal notranslate"><span class="pre">si</span> <span class="pre">tenemos</span> <span class="pre">&quot;mala</span> <span class="pre">suerte&quot;,</span> <span class="pre">es</span> <span class="pre">posible</span> <span class="pre">que</span> <span class="pre">pongamos</span> <span class="pre">al</span> <span class="pre">azar</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">ejemplos</span> <span class="pre">difíciles</span> <span class="pre">de</span> <span class="pre">clasificar</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">y</span> <span class="pre">en</span> <span class="pre">consecuencia,</span> <span class="pre">obtener</span> <span class="pre">una</span> <span class="pre">scoring</span> <span class="pre">irrealmente</span> <span class="pre">baja</span></code>.</p></li>
<li><p>Sin embargo, al utilizar la validación cruzada, cada ejemplo estará en el conjunto de entrenamiento exactamente una vez: cada ejemplo está en uno de los pliegues (<code class="docutils literal notranslate"><span class="pre">folds</span></code>), y cada pliegue es el conjunto de prueba una vez. Por lo tanto, <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">tiene</span> <span class="pre">que</span> <span class="pre">generalizar</span> <span class="pre">bien</span> <span class="pre">a</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos,</span> <span class="pre">para</span> <span class="pre">que</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">validaciones</span> <span class="pre">cruzadas</span> <span class="pre">(y</span> <span class="pre">su</span> <span class="pre">media)</span> <span class="pre">sean</span> <span class="pre">altas</span></code>. El hecho de <code class="docutils literal notranslate"><span class="pre">tener</span> <span class="pre">múltiples</span> <span class="pre">divisiones</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">también</span> <span class="pre">proporciona</span> <span class="pre">cierta</span> <span class="pre">información</span> <span class="pre">sobre</span> <span class="pre">la</span> <span class="pre">sensibilidad</span> <span class="pre">de</span> <span class="pre">nuestro</span> <span class="pre">modelo</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code>.</p></li>
<li><p>En el caso del conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code>, vimos precisiones de entre el 93.33% y el 100%. <code class="docutils literal notranslate"><span class="pre">Se</span> <span class="pre">trata</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">rango</span> <span class="pre">bastante</span> <span class="pre">amplio</span> <span class="pre">que</span> <span class="pre">nos</span> <span class="pre">da</span> <span class="pre">una</span> <span class="pre">idea</span> <span class="pre">de</span> <span class="pre">cómo</span> <span class="pre">podría</span> <span class="pre">funcionar</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">peor</span> <span class="pre">y</span> <span class="pre">el</span> <span class="pre">mejor</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">casos,</span> <span class="pre">cuando</span> <span class="pre">se</span> <span class="pre">aplica</span> <span class="pre">a</span> <span class="pre">nuevos</span> <span class="pre">datos</span></code>. Otro beneficio de la validación cruzada en comparación con el uso de una única división de los datos es que utilizamos nuestros datos de forma más eficaz. Al utilizar <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code>, solemos utilizar <code class="docutils literal notranslate"><span class="pre">75%</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">25%</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">evaluación</span></code>. Cuando se utiliza la validación cruzada de cinco pliegues (<code class="docutils literal notranslate"><span class="pre">five-fold</span></code>), en cada iteración podemos utilizar <code class="docutils literal notranslate"><span class="pre">cuatro</span> <span class="pre">quintos</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">(80%)</span> <span class="pre">para</span> <span class="pre">ajustar</span> <span class="pre">el</span> <span class="pre">modelo</span></code>. Cuando se utiliza la validación cruzada de 10 pliegues, podemos utilizar <code class="docutils literal notranslate"><span class="pre">nueve</span> <span class="pre">décimas</span> <span class="pre">partes</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">(90%)</span></code> para ajustar el modelo. Un <code class="docutils literal notranslate"><span class="pre">mayor</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">suele</span> <span class="pre">dar</span> <span class="pre">lugar</span> <span class="pre">a</span> <span class="pre">modelos</span> <span class="pre">más</span> <span class="pre">precisos</span></code>. La principal <code class="docutils literal notranslate"><span class="pre">desventaja</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">es</span> <span class="pre">el</span> <span class="pre">aumento</span> <span class="pre">del</span> <span class="pre">coste</span> <span class="pre">computacional</span></code>. Como ahora <code class="docutils literal notranslate"><span class="pre">estamos</span> <span class="pre">entrenando</span> <span class="pre">k</span> <span class="pre">modelos</span> <span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">único</span> <span class="pre">modelo</span></code>, la validación cruzada será aproximadamente <code class="docutils literal notranslate"><span class="pre">k</span></code> veces más lenta que hacer una única división de los datos.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Es importante tener en cuenta que la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">no</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">forma</span> <span class="pre">de</span> <span class="pre">construir</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">que</span> <span class="pre">pueda</span> <span class="pre">aplicarse</span> <span class="pre">a</span> <span class="pre">nuevos</span> <span class="pre">datos.</span> <span class="pre">La</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">no</span> <span class="pre">devuelve</span> <span class="pre">un</span> <span class="pre">modelo</span></code>. Cuando se llama a <code class="docutils literal notranslate"><span class="pre">cross_validation_score</span></code>, se construyen internamente múltiples modelos, pero el propósito de la validación cruzada es <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">lo</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">un</span> <span class="pre">algoritmo</span> <span class="pre">determinado</span> <span class="pre">generalizará</span> <span class="pre">cuando</span> <span class="pre">es</span> <span class="pre">entrenado</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">específico</span></code>.</p>
</div>
</section>
<section id="validacion-cruzada-estratificada-k-fold-y-otras-estrategias">
<h3>Validación cruzada estratificada <span class="math notranslate nohighlight">\(k\)</span>-fold y otras estrategias<a class="headerlink" href="#validacion-cruzada-estratificada-k-fold-y-otras-estrategias" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Dividir el conjunto de datos en <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">pliegues</span></code> comenzando por la primera parte de los datos, como descrito en la sección anterior, <code class="docutils literal notranslate"><span class="pre">puede</span> <span class="pre">no</span> <span class="pre">ser</span> <span class="pre">siempre</span> <span class="pre">una</span> <span class="pre">buena</span> <span class="pre">idea</span></code>. Por ejemplo, veamos el conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iris labels:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Iris labels:
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Nótese que <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">primer</span> <span class="pre">tercio</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">corresponde</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">0,</span> <span class="pre">el</span> <span class="pre">segundo</span> <span class="pre">tercio</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">1</span> <span class="pre">y</span> <span class="pre">el</span> <span class="pre">último</span> <span class="pre">tercio</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">2</span></code>. Imagine que realiza una validación cruzada <code class="docutils literal notranslate"><span class="pre">3-fold</span></code> en este conjunto de datos. El primer pliegue sería sólo la clase 0, por lo que en la primera división de los datos, el conjunto de prueba sería sólo la clase 0, y el conjunto de entrenamiento sería sólo las clases 1 y 2. <code class="docutils literal notranslate"><span class="pre">Como</span> <span class="pre">las</span> <span class="pre">clases</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">prueba</span> <span class="pre">serían</span> <span class="pre">diferentes</span> <span class="pre">en</span> <span class="pre">las</span> <span class="pre">tres</span> <span class="pre">divisiones,</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">de</span> <span class="pre">tres</span> <span class="pre">pliegues</span> <span class="pre">sería</span> <span class="pre">cero</span> <span class="pre">en</span> <span class="pre">este</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span></code>. Esto no es muy útil, ya que podemos obtener una precisión mucho mejor que el 0% en el dataset <code class="docutils literal notranslate"><span class="pre">iris</span></code>.</p></li>
<li><p>Como la estrategia simple de <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> falla aquí, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span> <span class="pre">no</span> <span class="pre">la</span> <span class="pre">utiliza</span> <span class="pre">para</span> <span class="pre">clasificación,</span> <span class="pre">sino</span> <span class="pre">que</span> <span class="pre">utiliza</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">estratificada</span> <span class="pre">k-fold</span></code>. En la validación cruzada estratificada, dividimos los datos de forma que las <code class="docutils literal notranslate"><span class="pre">proporciones</span> <span class="pre">entre</span> <span class="pre">las</span> <span class="pre">clases</span> <span class="pre">sean</span> <span class="pre">las</span> <span class="pre">mismas</span> <span class="pre">en</span> <span class="pre">cada</span> <span class="pre">pliegue</span> <span class="pre">como</span> <span class="pre">en</span> <span class="pre">todo</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_stratified_cross_validation</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cfc2289b827814972bc54341ab0482a351d0c498542b5ce562db9dd6475c512f.png" src="_images/cfc2289b827814972bc54341ab0482a351d0c498542b5ce562db9dd6475c512f.png" />
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Por</span> <span class="pre">ejemplo,</span> <span class="pre">si</span> <span class="pre">el</span> <span class="pre">90%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">pertenecen</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">A</span> <span class="pre">y</span> <span class="pre">el</span> <span class="pre">10%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">pertenecen</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">B,</span> <span class="pre">entonces</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">estratificada</span> <span class="pre">garantiza</span> <span class="pre">que</span> <span class="pre">en</span> <span class="pre">cada</span> <span class="pre">pliegue,</span> <span class="pre">el</span> <span class="pre">90%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">pertenezcan</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">A</span> <span class="pre">y</span> <span class="pre">el</span> <span class="pre">10%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">pertenezcan</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">B</span></code>. Suele ser una buena idea utilizar la validación cruzada estratificada de <code class="docutils literal notranslate"><span class="pre">k</span></code> pliegues en lugar de la validación cruzada de <code class="docutils literal notranslate"><span class="pre">k</span></code> pliegues para evaluar un clasificador, porque da lugar a <code class="docutils literal notranslate"><span class="pre">estimaciones</span> <span class="pre">más</span> <span class="pre">fiables</span> <span class="pre">del</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">generalización</span></code>. En el caso de que sólo el 10% de las muestras pertenezcan a la clase B utilizando la validación cruzada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> estándar, podría ocurrir fácilmente que un pliegue sólo contuviera muestras de la clase A. El uso de este pliegue como conjunto de prueba no sería muy informativo sobre el rendimiento general del clasificador.</p></li>
<li><p>Para la regresión, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> utiliza la validación cruzada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> estándar por defecto. Sería posible también tratar de hacer cada pliegue representativo de los diferentes valores objetivo de la regresión, pero esta no es una estrategia comúnmente utilizada. En el curso <code class="docutils literal notranslate"><span class="pre">Time</span> <span class="pre">Series</span> <span class="pre">Forecasting</span></code> analizaremos este tipo de validación cruzada.</p></li>
</ul>
</section>
<section id="mas-control-sobre-la-validacion-cruzada">
<h3>Más control sobre la validación cruzada<a class="headerlink" href="#mas-control-sobre-la-validacion-cruzada" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Hemos visto antes que podemos ajustar el número de pliegues que utiliza <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> utilizando el parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code>. Sin embargo, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> permite un control mucho más fino sobre lo que sucede durante la división de los datos, proporcionando un divisor de validación cruzada como parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code>. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">la</span> <span class="pre">mayoría</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">casos</span> <span class="pre">de</span> <span class="pre">uso,</span> <span class="pre">los</span> <span class="pre">valores</span> <span class="pre">predeterminados</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">k-fold</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">regresión</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">estratificada</span> <span class="pre">funcionan</span> <span class="pre">bien,</span> <span class="pre">pero</span> <span class="pre">hay</span> <span class="pre">algunos</span> <span class="pre">casos</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">que</span> <span class="pre">una</span> <span class="pre">estrategia</span> <span class="pre">diferente</span> <span class="pre">se</span> <span class="pre">podría</span> <span class="pre">querer</span> <span class="pre">utilizar</span></code>.</p></li>
<li><p>Digamos, por ejemplo, que queremos utilizar la validación cruzada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> estándar en un conjunto de datos de clasificación para <code class="docutils literal notranslate"><span class="pre">reproducir</span> <span class="pre">los</span> <span class="pre">resultados</span> <span class="pre">de</span> <span class="pre">otra</span> <span class="pre">persona</span></code>. Para ello, primero tenemos que importar la clase <code class="docutils literal notranslate"><span class="pre">KFold</span> <span class="pre">splitter</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">model_selection</span></code> e instanciarla con el número de pliegues que queremos utilizar.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
<span class="n">kfold</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Entonces, podemos pasar el objeto <code class="docutils literal notranslate"><span class="pre">kfold</span> <span class="pre">splitter</span></code> como el parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code> a <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kfold</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0. 0. 0.]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>De este modo, podemos comprobar que, efectivamente, es una muy <code class="docutils literal notranslate"><span class="pre">mala</span> <span class="pre">idea</span> <span class="pre">utilizar</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">triple</span> <span class="pre">(no</span> <span class="pre">estratificada)</span></code> en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code>. Recuerde que cada pliegue corresponde a una de las clases del conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code>, por lo que no se puede aprender nada. Otra forma de resolver este problema es <code class="docutils literal notranslate"><span class="pre">aleatorizar</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">estratificar</span> <span class="pre">los</span> <span class="pre">pliegues</span></code>, para eliminar la ordenación de las muestras por etiquetas. Si <code class="docutils literal notranslate"><span class="pre">shuffle</span> <span class="pre">es</span> <span class="pre">True,</span> <span class="pre">primero</span> <span class="pre">se</span> <span class="pre">aleatorizan</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">y</span> <span class="pre">luego</span> <span class="pre">se</span> <span class="pre">dividen</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">k-folds</span></code>.</p></li>
<li><p>Podemos hacerlo estableciendo el parámetro <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> de <code class="docutils literal notranslate"><span class="pre">KFold</span></code> en <code class="docutils literal notranslate"><span class="pre">True</span></code>. Si aleatorizamos los datos, tenemos también que fijar el <code class="docutils literal notranslate"><span class="pre">random_state</span></code> para conseguir una aleatoriedad reproducible. De lo contrario, cada ejecución de <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> daría un resultado diferente, ya que cada vez se utilizaría una división distinta. Aleatorizar los datos antes de dividirlos produce un resultado mucho mejor</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kfold</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kfold</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0.98 0.96 0.96]
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-con-exclusion-leave-one-out">
<h3>Validación cruzada con exclusión (leave-one-out)<a class="headerlink" href="#validacion-cruzada-con-exclusion-leave-one-out" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Otro método de validación cruzada que se utiliza con frecuencia es el <code class="docutils literal notranslate"><span class="pre">leave-one-out</span></code>. Se puede pensar en la validación cruzada de exclusión como una <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">de</span> <span class="pre">k</span> <span class="pre">pliegues</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">que</span> <span class="pre">cada</span> <span class="pre">pliegue</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">sola</span> <span class="pre">muestra</span></code>. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">cada</span> <span class="pre">pliegue,</span> <span class="pre">se</span> <span class="pre">elige</span> <span class="pre">un</span> <span class="pre">único</span> <span class="pre">punto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">que</span> <span class="pre">será</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code>. Esto puede consumir mucho tiempo, sobre todo para conjuntos de datos grandes, pero a veces proporciona mejores estimaciones en conjuntos de datos pequeños.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">LeaveOneOut</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">loo</span> <span class="o">=</span> <span class="n">LeaveOneOut</span><span class="p">()</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">loo</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of cv iterations: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of cv iterations:  150
Mean accuracy: 0.97
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-aleatoria-y-dividida">
<h3>Validación cruzada aleatoria y dividida<a class="headerlink" href="#validacion-cruzada-aleatoria-y-dividida" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Otra estrategia muy flexible para la validación cruzada es <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">aleatoria</span> <span class="pre">(shuffle-split</span> <span class="pre">cross-validation</span></code>). En la validación cruzada de división aleatoria, cada división (split) está compuesta de tanto <code class="docutils literal notranslate"><span class="pre">train_size</span> <span class="pre">puntos</span> <span class="pre">(disyuntos)</span></code> para el conjunto de entrenamiento y tantos <code class="docutils literal notranslate"><span class="pre">test_size</span> <span class="pre">puntos</span> <span class="pre">(disjuntos)</span></code> para el conjunto de prueba, se fijen inicialmente.</p></li>
<li><p>Esta división se repite <code class="docutils literal notranslate"><span class="pre">n_iter</span></code> veces, de forma aleatoria. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">la</span> <span class="pre">ejecución</span> <span class="pre">de</span> <span class="pre">cuatro</span> <span class="pre">iteraciones</span> <span class="pre">de</span> <span class="pre">división</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">que</span> <span class="pre">consta</span> <span class="pre">de</span> <span class="pre">10</span> <span class="pre">puntos,</span> <span class="pre">con</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">de</span> <span class="pre">5</span> <span class="pre">puntos</span> <span class="pre">y</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">de</span> <span class="pre">2</span> <span class="pre">puntos</span> <span class="pre">cada</span> <span class="pre">uno</span></code> (puede usar enteros para <code class="docutils literal notranslate"><span class="pre">train_size</span></code> y <code class="docutils literal notranslate"><span class="pre">test_size</span></code> para asignarles sus tamaños absolutos, o números de tipo flotante para usar fracciones del conjunto de datos)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_shuffle_split</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/93a69c5bb20c86ef358bc7af0a3d733edd8727015f5bb0b0a63667ca0dbb706c.png" src="_images/93a69c5bb20c86ef358bc7af0a3d733edd8727015f5bb0b0a63667ca0dbb706c.png" />
</div>
</div>
<ul class="simple">
<li><p>El siguiente código divide el conjunto de datos en un <code class="docutils literal notranslate"><span class="pre">50%</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">un</span> <span class="pre">50%</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">para</span> <span class="pre">10</span> <span class="pre">iteraciones</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">ShuffleSplit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shuffle_split</span> <span class="o">=</span> <span class="n">ShuffleSplit</span><span class="p">(</span><span class="n">test_size</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">shuffle_split</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0.97333333 0.92       0.92       0.97333333 0.94666667 0.93333333
 0.96       0.96       0.96       0.96      ]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">aleatoria</span> <span class="pre">permite</span> <span class="pre">controlar</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">iteraciones</span> <span class="pre">independientemente</span> <span class="pre">del</span> <span class="pre">tamaño</span> <span class="pre">del</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">prueba,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">a</span> <span class="pre">veces</span> <span class="pre">puede</span> <span class="pre">ser</span> <span class="pre">útil</span></code>. También permite solamente usar parte de los datos en cada iteración, proporcionando <code class="docutils literal notranslate"><span class="pre">train_size</span></code> y <code class="docutils literal notranslate"><span class="pre">test_size</span></code> que no suman uno. El submuestreo de los datos de esta manera puede ser <code class="docutils literal notranslate"><span class="pre">útil</span> <span class="pre">para</span> <span class="pre">experimentar</span> <span class="pre">con</span> <span class="pre">grandes</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span></code>. También existe una variante estratificada de <code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code>, llamada <code class="docutils literal notranslate"><span class="pre">StratifiedShuffleSplit</span></code>, que puede proporcionar resultados más fiables para las tareas de clasificación.</p></li>
</ul>
</section>
<section id="validacion-cruzada-con-grupos">
<h3>Validación cruzada con grupos<a class="headerlink" href="#validacion-cruzada-con-grupos" title="Permalink to this heading">#</a></h3>
<div class="admonition-groupkfold admonition">
<p class="admonition-title">GroupKFold</p>
<ul class="simple">
<li><p>Digamos que quieres construir un sistema para <code class="docutils literal notranslate"><span class="pre">reconocer</span> <span class="pre">emociones</span> <span class="pre">a</span> <span class="pre">partir</span> <span class="pre">de</span> <span class="pre">imágenes</span> <span class="pre">de</span> <span class="pre">rostros</span> <span class="pre">(o</span> <span class="pre">imágenes</span> <span class="pre">médicas)</span></code>, y se recopila un conjunto de datos con imágenes de 100 personas, donde cada persona es capturada varias veces, mostrando varias emociones. El objetivo es construir un clasificador que pueda <code class="docutils literal notranslate"><span class="pre">identificar</span> <span class="pre">correctamente</span> <span class="pre">las</span> <span class="pre">emociones</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">personas</span> <span class="pre">que</span> <span class="pre">no</span> <span class="pre">están</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span></code>. <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code> es una variación de k-fold que <code class="docutils literal notranslate"><span class="pre">garantiza</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">mismo</span> <span class="pre">grupo</span> <span class="pre">no</span> <span class="pre">esté</span> <span class="pre">representado</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code>.</p></li>
</ul>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p>Se podría utilizar la validación cruzada estratificada por defecto para medir el rendimiento de un clasificador aquí. Sin embargo, <code class="docutils literal notranslate"><span class="pre">es</span> <span class="pre">probable</span> <span class="pre">que</span> <span class="pre">haya</span> <span class="pre">imágenes</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">misma</span> <span class="pre">persona</span> <span class="pre">tanto</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">como</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">de</span> <span class="pre">prueba</span></code>. Será mucho más fácil para un clasificador detectar emociones en un rostro que forma parte del conjunto de entrenamiento, en comparación con una cara completamente nueva.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">evaluar</span> <span class="pre">con</span> <span class="pre">precisión</span> <span class="pre">la</span> <span class="pre">generalización</span> <span class="pre">a</span> <span class="pre">nuevas</span> <span class="pre">caras,</span> <span class="pre">debemos</span> <span class="pre">asegurarnos</span> <span class="pre">de</span> <span class="pre">que</span> <span class="pre">los</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">contengan</span> <span class="pre">imágenes</span> <span class="pre">de</span> <span class="pre">personas</span> <span class="pre">diferentes</span></code>. Para ello, podemos utilizar <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code>, que toma como argumento una matriz de grupos que podemos utilizar para indicar qué persona aparece en la imagen.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>El siguiente es un ejemplo de uso para exponer el funcionamiento de esta validación cruzada, considerando un <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">sintético</span></code> con una agrupación dada por la matriz <code class="docutils literal notranslate"><span class="pre">groups</span></code>. El conjunto de datos consta de <code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">puntos</span> <span class="pre">de</span> <span class="pre">datos</span></code>, y para cada uno de ellos, <code class="docutils literal notranslate"><span class="pre">groups</span></code> especifica a qué grupo pertenece el punto. Los grupos especifican que <code class="docutils literal notranslate"><span class="pre">hay</span> <span class="pre">cuatro</span> <span class="pre">grupos,</span> <span class="pre">y</span> <span class="pre">las</span> <span class="pre">tres</span> <span class="pre">primeras</span> <span class="pre">muestras</span> <span class="pre">pertenecen</span> <span class="pre">al</span> <span class="pre">primer</span> <span class="pre">grupo,</span> <span class="pre">las</span> <span class="pre">siguientes</span> <span class="pre">cuatro</span> <span class="pre">muestras</span> <span class="pre">pertenecen</span> <span class="pre">al</span> <span class="pre">segundo</span> <span class="pre">grupo</span></code>, y así sucesivamente</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GroupKFold</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Creamos nuestro conjunto de datos sintético, y la lista de grupos <code class="docutils literal notranslate"><span class="pre">groups</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1, 0, 2, 0, 0, 1, 1, 2, 0, 2, 2, 1])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gkf</span> <span class="o">=</span> <span class="n">GroupKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">gkf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;GroupKFold: </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
    <span class="n">Xtrain</span><span class="p">,</span> <span class="n">Xtest</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>
    <span class="n">ytrain</span><span class="p">,</span> <span class="n">ytest</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>
    <span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
    <span class="n">logreg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xtrain</span><span class="p">,</span> <span class="n">ytrain</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LogisticRegression Score: &quot;</span><span class="p">,</span> <span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">Xtest</span><span class="p">,</span> <span class="n">ytest</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>GroupKFold: [ 0  1  2  7  8  9 10 11] [3 4 5 6]
LogisticRegression Score:  0.75
GroupKFold: [0 1 2 3 4 5 6] [ 7  8  9 10 11]
LogisticRegression Score:  0.6
GroupKFold: [ 3  4  5  6  7  8  9 10 11] [0 1 2]
LogisticRegression Score:  0.6666666666666666
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>No es necesario que las muestras estén ordenadas por grupos; sólo lo hemos hecho con fines ilustrativos. <code class="docutils literal notranslate"><span class="pre">Como</span> <span class="pre">puede</span> <span class="pre">ver,</span> <span class="pre">para</span> <span class="pre">cada</span> <span class="pre">división,</span> <span class="pre">cada</span> <span class="pre">grupo</span> <span class="pre">está</span> <span class="pre">completamente</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">o</span> <span class="pre">completamente</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code>. Ademas, <code class="docutils literal notranslate"><span class="pre">observe</span> <span class="pre">que</span> <span class="pre">los</span> <span class="pre">pliegues</span> <span class="pre">no</span> <span class="pre">tienen</span> <span class="pre">exactamente</span> <span class="pre">el</span> <span class="pre">mismo</span> <span class="pre">tamaño</span> <span class="pre">debido</span> <span class="pre">al</span> <span class="pre">desequilibrio</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span></code>.</p></li>
<li><p>Hay más estrategias de división para la validación cruzada en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, que pueden utilizarse para una variedad aún mayor de casos (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/cross_validation.html">Cross-validation: evaluating estimator performance</a>). Sin embargo, el <code class="docutils literal notranslate"><span class="pre">KFold</span></code> estándar, el <code class="docutils literal notranslate"><span class="pre">StratifiedKFold</span></code> y el <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code> son, como mucho, los más utilizados. En el siguiente link puede encontrar la documentición relacionada con el uso de cada parámetro de la función <code class="docutils literal notranslate"><span class="pre">sklearn.model_selection.cross_val_score</span></code> (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_score.html">Evaluate a score by cross-validation</a>).</p></li>
</ul>
</section>
</section>
<section id="grid-search">
<h2>Grid Search<a class="headerlink" href="#grid-search" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Ahora que sabemos cómo evaluar el grado de generalización de un modelo, podemos dar el siguiente paso y <code class="docutils literal notranslate"><span class="pre">mejorar</span> <span class="pre">el</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">generalización</span> <span class="pre">del</span> <span class="pre">modelo</span> <span class="pre">ajustando</span> <span class="pre">sus</span> <span class="pre">parámetros</span></code>. Es importante entender lo que significan los parámetros antes de intentar ajustarlos. Encontrar los valores de los parámetros importantes de un modelo (<code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">que</span> <span class="pre">proporcionan</span> <span class="pre">el</span> <span class="pre">mejor</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">generalización</span></code>) es una tarea complicada, pero necesaria para casi todos los modelos y conjuntos de datos.</p></li>
<li><p>Al ser una tarea tan común, existen métodos estándar en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> para ayudarle con ello. El método más utilizado es la <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code>, que básicamente significa <code class="docutils literal notranslate"><span class="pre">probar</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">combinaciones</span> <span class="pre">posibles</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">de</span> <span class="pre">interés</span></code>. Considere el caso de un SVM con un <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">RBF</span></code> (función de base radial), como implementado en la clase <code class="docutils literal notranslate"><span class="pre">SVC</span></code>. Como ya hemos comentado en el estudio del modelo, hay dos parámetros importantes: el <code class="docutils literal notranslate"><span class="pre">ancho</span> <span class="pre">de</span> <span class="pre">banda</span> <span class="pre">del</span> <span class="pre">kernel,</span> <span class="pre">gamma</span></code>, y el <code class="docutils literal notranslate"><span class="pre">parámetro</span> <span class="pre">de</span> <span class="pre">regularización,</span> <span class="pre">C</span></code>.</p></li>
<li><p>Digamos que queremos probar los valores <code class="docutils literal notranslate"><span class="pre">0.001,</span> <span class="pre">0.01,</span> <span class="pre">0.1,</span> <span class="pre">1,</span> <span class="pre">10</span> <span class="pre">y</span> <span class="pre">100</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">parámetro</span> <span class="pre">C,</span> <span class="pre">y</span> <span class="pre">lo</span> <span class="pre">mismo</span> <span class="pre">para</span> <span class="pre">gamma</span></code>. Como tenemos seis ajustes diferentes para <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code> que queremos probar, tenemos <code class="docutils literal notranslate"><span class="pre">36</span> <span class="pre">combinaciones</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">en</span> <span class="pre">total</span></code>. Al ver todas las combinaciones posibles, <code class="docutils literal notranslate"><span class="pre">se</span> <span class="pre">crea</span> <span class="pre">una</span> <span class="pre">tabla</span> <span class="pre">(o</span> <span class="pre">red)</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">para</span> <span class="pre">SVM</span></code>, como se muestra aquí:</p></li>
</ul>
<figure class="align-center" id="grid-search-svm">
<a class="reference internal image-reference" href="_images/grid_search_svm.png"><img alt="_images/grid_search_svm.png" src="_images/grid_search_svm.png" style="width: 698.5999999999999px; height: 138.6px;" /></a>
</figure>
<section id="grid-search-simple">
<h3>Grid Search simple<a class="headerlink" href="#grid-search-simple" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Podemos implementar un <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> sobre los dos parámetros usando un par de <code class="docutils literal notranslate"><span class="pre">ciclos</span> <span class="pre">for</span></code>, entrenando y evaluando un clasificador para cada combinación</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of training set: </span><span class="si">{}</span><span class="s2"> size of test set: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">best_score</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Size of training set: 112 size of test set: 38
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
        <span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_score</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_parameters</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best score: 0.97
Best parameters: {&#39;C&#39;: 100, &#39;gamma&#39;: 0.001}
</pre></div>
</div>
</div>
</div>
</section>
<section id="el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">
<h3>El peligro de sobreajustar los parámetros y el conjunto de validación<a class="headerlink" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Teniendo en cuenta este resultado, podríamos tener la <code class="docutils literal notranslate"><span class="pre">tentación</span> <span class="pre">de</span> <span class="pre">decir</span> <span class="pre">que</span> <span class="pre">hemos</span> <span class="pre">encontrado</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">que</span> <span class="pre">funciona</span> <span class="pre">con</span> <span class="pre">un</span> <span class="pre">97%</span> <span class="pre">de</span> <span class="pre">precisión</span></code> en nuestro conjunto de datos. Sin embargo, esta afirmación podría ser demasiado optimista (o simplemente errónea), por la siguiente razón: <code class="docutils literal notranslate"><span class="pre">hemos</span> <span class="pre">probado</span> <span class="pre">muchos</span> <span class="pre">parámetros</span> <span class="pre">diferentes</span> <span class="pre">y</span> <span class="pre">se</span> <span class="pre">seleccionó</span> <span class="pre">el</span> <span class="pre">que</span> <span class="pre">tenía</span> <span class="pre">la</span> <span class="pre">mejor</span> <span class="pre">precisión</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba,</span> <span class="pre">pero</span> <span class="pre">esta</span> <span class="pre">precisión</span> <span class="pre">no</span> <span class="pre">necesariamente</span> <span class="pre">la</span> <span class="pre">obtendremos</span> <span class="pre">con</span> <span class="pre">nuevos</span> <span class="pre">datos</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Como</span> <span class="pre">hemos</span> <span class="pre">utilizado</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">para</span> <span class="pre">ajustar</span> <span class="pre">los</span> <span class="pre">parámetros,</span> <span class="pre">ya</span> <span class="pre">no</span> <span class="pre">podemos</span> <span class="pre">utilizarlos</span> <span class="pre">para</span> <span class="pre">evaluar</span> <span class="pre">la</span> <span class="pre">calidad</span> <span class="pre">del</span> <span class="pre">modelo</span></code>. Esta es la misma razón por la que necesitamos dividir los datos en conjuntos de entrenamiento y de prueba; <code class="docutils literal notranslate"><span class="pre">necesitamos</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">independiente</span> <span class="pre">para</span> <span class="pre">evaluar,</span> <span class="pre">uno</span> <span class="pre">que</span> <span class="pre">no</span> <span class="pre">se</span> <span class="pre">haya</span> <span class="pre">utilizado</span> <span class="pre">para</span> <span class="pre">crear</span> <span class="pre">el</span> <span class="pre">modelo</span></code>.</p></li>
<li><p>Una forma de resolver este problema es <code class="docutils literal notranslate"><span class="pre">dividir</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">nuevo,</span> <span class="pre">de</span> <span class="pre">modo</span> <span class="pre">que</span> <span class="pre">tengamos</span> <span class="pre">tres</span> <span class="pre">conjuntos</span></code>: el <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code> para construir el modelo, el <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">validación</span></code> (o desarrollo) para seleccionar los parámetros del modelo, y el <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code> para evaluar el rendimiento de los parámetros seleccionados`</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_threefold_split</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/59eb92d5a7579c16f018f7a4aecf821cebd888a1a641f1768236b066d5d00cb8.png" src="_images/59eb92d5a7579c16f018f7a4aecf821cebd888a1a641f1768236b066d5d00cb8.png" />
</div>
</div>
<ul class="simple">
<li><p>Después de seleccionar los mejores parámetros utilizando el <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">validación</span></code>, podemos <code class="docutils literal notranslate"><span class="pre">reconstruir</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">utilizando</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">ajustados</span></code> que encontramos, pero ahora <code class="docutils literal notranslate"><span class="pre">entrenado</span> <span class="pre">tanto</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">validación</span></code>. De esta forma, podemos utilizar tantos datos como sea posible para construir nuestro modelo. Esto nos lleva a la siguiente implementación</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dividimos los datos en conjunto de <code class="docutils literal notranslate"><span class="pre">entrenamiento+validación</span></code> y conjunto de <code class="docutils literal notranslate"><span class="pre">prueba</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dividimos el conjunto de <code class="docutils literal notranslate"><span class="pre">entrenamiento+validación</span></code> en conjuntos de <code class="docutils literal notranslate"><span class="pre">entrenamiento</span></code> y <code class="docutils literal notranslate"><span class="pre">validación</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_valid</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of training set: </span><span class="si">{}</span><span class="s2"> size of validation set: </span><span class="si">{}</span><span class="s2"> size of test set: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
      <span class="nb">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_valid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Size of training set: 84 size of validation set: 28 size of test set: 38
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">best_score</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
        <span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span> <span class="c1"># Ajuste del modelo SVC</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">)</span> <span class="c1"># Score para selección de parámetros</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span> <span class="c1"># Almacenamos el mejor score y sus parámetros</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Reconstruimos</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">combinado</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">validación</span></code>, y lo <code class="docutils literal notranslate"><span class="pre">evaluamos</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="o">**</span><span class="n">best_parameters</span><span class="p">)</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">)</span>
<span class="n">test_score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best score on validation set: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_score</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: &quot;</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score with best parameters: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_score</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best score on validation set: 0.96
Best parameters:  {&#39;C&#39;: 10, &#39;gamma&#39;: 0.001}
Test set score with best parameters: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">mejor</span> <span class="pre">score</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">es</span> <span class="pre">del</span> <span class="pre">96%</span></code>: ligeramente inferior a la anterior, probablemente porque utilizamos menos datos para entrenar el modelo (<code class="docutils literal notranslate"><span class="pre">X_train</span> <span class="pre">es</span> <span class="pre">menor</span> <span class="pre">ahora</span> <span class="pre">porque</span> <span class="pre">dividimos</span> <span class="pre">nuestro</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">dos</span> <span class="pre">veces</span></code>). Sin embargo, el score en el conjunto de prueba, el que realmente nos dice que tan buena es la generalización, es aún más baja, un 92%. Así que <code class="docutils literal notranslate"><span class="pre">sólo</span> <span class="pre">podemos</span> <span class="pre">afirmar</span> <span class="pre">que</span> <span class="pre">clasificamos</span> <span class="pre">los</span> <span class="pre">nuevos</span> <span class="pre">datos</span> <span class="pre">con</span> <span class="pre">un</span> <span class="pre">92%</span> <span class="pre">de</span> <span class="pre">acierto,</span> <span class="pre">y</span> <span class="pre">no</span> <span class="pre">con</span> <span class="pre">un</span> <span class="pre">97%</span> <span class="pre">como</span> <span class="pre">pensábamos</span> <span class="pre">antes</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">distinción</span> <span class="pre">entre</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento,</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">y</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">es</span> <span class="pre">fundamentalmente</span> <span class="pre">importante</span></code> para aplicar los métodos de aprendizaje automático en la práctica. <code class="docutils literal notranslate"><span class="pre">Cualquier</span> <span class="pre">decisión</span> <span class="pre">tomada</span> <span class="pre">basada</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">&quot;filtra&quot;</span> <span class="pre">información</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">al</span> <span class="pre">modelo</span></code>. Por lo tanto, es importante mantener un conjunto de prueba separado, que sólo se utiliza para la evaluación final.</p></li>
<li><p>Es una buena práctica <code class="docutils literal notranslate"><span class="pre">realizar</span> <span class="pre">todo</span> <span class="pre">el</span> <span class="pre">análisis</span> <span class="pre">exploratorio</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">del</span> <span class="pre">modelo</span> <span class="pre">utilizando</span> <span class="pre">la</span> <span class="pre">combinación</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">validación,</span> <span class="pre">y</span> <span class="pre">reservar</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">evaluación</span> <span class="pre">final</span></code>, incluso en el caso de la visualización exploratoria. En sentido estricto, <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">más</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">y</span> <span class="pre">elegir</span> <span class="pre">el</span> <span class="pre">mejor</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">dos</span> <span class="pre">resultará</span> <span class="pre">en</span> <span class="pre">una</span> <span class="pre">estimación</span> <span class="pre">demasiado</span> <span class="pre">optimista</span></code> de la precisión del modelo.</p></li>
</ul>
</section>
<section id="grid-search-con-validacion-cruzada">
<h3>Grid Search con validación cruzada<a class="headerlink" href="#grid-search-con-validacion-cruzada" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Aunque</span> <span class="pre">el</span> <span class="pre">método</span> <span class="pre">de</span> <span class="pre">dividir</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento,</span> <span class="pre">uno</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">y</span> <span class="pre">otro</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">que</span> <span class="pre">acabamos</span> <span class="pre">de</span> <span class="pre">ver</span> <span class="pre">es</span> <span class="pre">factible</span> <span class="pre">y</span> <span class="pre">se</span> <span class="pre">utiliza</span> <span class="pre">con</span> <span class="pre">relativa</span> <span class="pre">frecuencia,</span> <span class="pre">es</span> <span class="pre">bastante</span> <span class="pre">sensible</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">forma</span> <span class="pre">en</span> <span class="pre">que</span> <span class="pre">se</span> <span class="pre">dividen</span> <span class="pre">los</span> <span class="pre">datos</span></code>. De la salida del fragmento de código anterior podemos ver que el <code class="docutils literal notranslate"><span class="pre">grid-search</span></code> selecciona <code class="docutils literal notranslate"><span class="pre">'C':</span> <span class="pre">10,</span> <span class="pre">'gamma':</span> <span class="pre">0.001</span></code>, como los mejores parámetros, mientras que la salida del código de la sección anterior selecciona <code class="docutils literal notranslate"><span class="pre">'C':</span> <span class="pre">100,</span> <span class="pre">'gamma':</span> <span class="pre">0.001</span></code> como los mejores parámetros. Para una mejor estimación del rendimiento de la generalización, <code class="docutils literal notranslate"><span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">usar</span> <span class="pre">una</span> <span class="pre">única</span> <span class="pre">división</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">otro</span> <span class="pre">de</span> <span class="pre">validación,</span> <span class="pre">podemos</span> <span class="pre">usar</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">para</span> <span class="pre">evaluar</span> <span class="pre">el</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">cada</span> <span class="pre">combinación</span> <span class="pre">de</span> <span class="pre">parámetros</span></code>. Este método puede codificarse como sigue:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span> <span class="c1"># Entrena SVC para cada parámetro</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">svm</span><span class="p">,</span> <span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># Calcula validación cruzada</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="c1"># Calcula media de la validación cruzada para precisión</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Reconstruimos</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">combinado</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">validación</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="o">**</span><span class="n">best_parameters</span><span class="p">)</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-1 {color: black;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>SVC(C=10, gamma=0.1)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">SVC</label><div class="sk-toggleable__content"><pre>SVC(C=10, gamma=0.1)</pre></div></div></div></div></div></div></div>
</div>
<ul class="simple">
<li><p>Para evaluar la precisión de <code class="docutils literal notranslate"><span class="pre">SVM</span></code> utilizando un ajuste particular de <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code> con <code class="docutils literal notranslate"><span class="pre">5-fold</span></code> validación cruzada, necesitamos entrenar <code class="docutils literal notranslate"><span class="pre">36</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">=</span> <span class="pre">180</span> <span class="pre">modelos</span></code>. Como puede imaginarse el <code class="docutils literal notranslate"><span class="pre">principal</span> <span class="pre">inconveniente</span> <span class="pre">del</span> <span class="pre">uso</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">es</span> <span class="pre">el</span> <span class="pre">tiempo</span> <span class="pre">que</span> <span class="pre">lleva</span> <span class="pre">entrenar</span> <span class="pre">todos</span> <span class="pre">estos</span> <span class="pre">modelos</span></code>. La siguiente visualización ilustra cómo se selecciona la mejor configuración de parámetros en el código anterior</p></li>
</ul>
<figure class="align-center" id="best-params-cv">
<img alt="_images/best_params_cv.png" src="_images/best_params_cv.png" />
</figure>
<ul class="simple">
<li><p>Para cada ajuste de parámetros (sólo se muestra un subconjunto), <code class="docutils literal notranslate"><span class="pre">se</span> <span class="pre">calculan</span> <span class="pre">cinco</span> <span class="pre">valores</span> <span class="pre">de</span> <span class="pre">precisión</span></code>, uno para cada división en la validación cruzada. A continuación, <code class="docutils literal notranslate"><span class="pre">se</span> <span class="pre">calcula</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">media</span></code> de la validación para cada parámetro. <code class="docutils literal notranslate"><span class="pre">Se</span> <span class="pre">eligen</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">con</span> <span class="pre">la</span> <span class="pre">mayor</span> <span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">de</span> <span class="pre">validación,</span> <span class="pre">marcados</span> <span class="pre">con</span> <span class="pre">un</span> <span class="pre">círculo</span></code>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Como hemos dicho antes, <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">forma</span> <span class="pre">de</span> <span class="pre">evaluar</span> <span class="pre">un</span> <span class="pre">determinado</span> <span class="pre">algoritmo</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">específico</span></code>. Sin embargo, a menudo se utiliza junto con métodos de búsqueda de parámetros como <code class="docutils literal notranslate"><span class="pre">Grid</span> <span class="pre">Search</span></code>. Por esta razón, normalmente se utiliza el término <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span></code> coloquialmente para referirse a un <code class="docutils literal notranslate"><span class="pre">Grid</span> <span class="pre">Search</span></code> con <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span></code>.</p>
</div>
<ul class="simple">
<li><p>El proceso general de división de los datos, la ejecución de <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> y la evaluación de los parámetros finales se ilustra en la siguiente figura</p></li>
</ul>
<figure class="align-center" id="kfold-validation">
<img alt="_images/kfold_validation.png" src="_images/kfold_validation.png" />
<figcaption>
<p><span class="caption-number">Fig. 69 </span><span class="caption-text">Resumen del proceso de selección de parámetros y evaluación de modelos con <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>.</span><a class="headerlink" href="#kfold-validation" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>Debido a que <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> con <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span></code> es un método tan comúnmente utilizado para ajustar parámetros, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> proporciona la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, que lo implementa en la forma de un estimador. Para utilizar la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, primero hay que especificar los parámetros sobre los que se quiere buscar utilizando un <code class="docutils literal notranslate"><span class="pre">diccionario</span></code>. A continuación, <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> realizará todos los ajustes necesarios del modelo. Las <code class="docutils literal notranslate"><span class="pre">claves</span></code> (keys) del diccionario son los <code class="docutils literal notranslate"><span class="pre">nombres</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">que</span> <span class="pre">queremos</span> <span class="pre">ajustar</span></code> (tal y como se indican cuando se construye el modelo, en este caso, <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code>), y los <code class="docutils literal notranslate"><span class="pre">valores</span></code> (values) son los ajustes de los parámetros que queremos probar. Probar los valores <code class="docutils literal notranslate"><span class="pre">0,001,</span> <span class="pre">0,01,</span> <span class="pre">0,1,</span> <span class="pre">1,</span> <span class="pre">10</span> <span class="pre">y</span> <span class="pre">100</span> <span class="pre">para</span> <span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code> se traduce en lo siguiente diccionario</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parameter grid:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Parameter grid:
{&#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100], &#39;gamma&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Ahora podemos instanciar la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> con el modelo <code class="docutils literal notranslate"><span class="pre">(SVC)</span></code>, el parámetro a buscar (<code class="docutils literal notranslate"><span class="pre">param_grid</span></code>), y la estrategia de validación cruzada que queremos utilizar (digamos <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">estratificada</span> <span class="pre">5-fold</span></code>):</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> utilizará la validación cruzada en lugar de la división en un conjunto de entrenamiento y de prueba que utilizábamos antes. <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span> <span class="pre">todavía</span> <span class="pre">tenemos</span> <span class="pre">que</span> <span class="pre">dividir</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">otro</span> <span class="pre">de</span> <span class="pre">prueba,</span> <span class="pre">para</span> <span class="pre">evitar</span> <span class="pre">el</span> <span class="pre">sobreajuste</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El objeto <code class="docutils literal notranslate"><span class="pre">grid_search</span></code> que hemos creado <code class="docutils literal notranslate"><span class="pre">se</span> <span class="pre">comporta</span> <span class="pre">como</span> <span class="pre">un</span> <span class="pre">clasificador</span></code>; podemos llamar a los métodos estándar <code class="docutils literal notranslate"><span class="pre">fit,</span> <span class="pre">predict</span></code> y <code class="docutils literal notranslate"><span class="pre">score</span></code>. Sin embargo, <code class="docutils literal notranslate"><span class="pre">cuando</span> <span class="pre">llamamos</span> <span class="pre">a</span> <span class="pre">fit,</span> <span class="pre">se</span> <span class="pre">ejecutará</span> <span class="pre">una</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">para</span> <span class="pre">cada</span> <span class="pre">combinación</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">que</span> <span class="pre">hayamos</span> <span class="pre">especificado</span></code> en <code class="docutils literal notranslate"><span class="pre">param_grid</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-2 {color: black;}#sk-container-id-2 pre{padding: 0;}#sk-container-id-2 div.sk-toggleable {background-color: white;}#sk-container-id-2 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-2 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-2 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-2 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-2 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-2 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-2 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-2 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-2 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-2 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-2 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-2 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-2 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-2 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-2 div.sk-item {position: relative;z-index: 1;}#sk-container-id-2 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-2 div.sk-item::before, #sk-container-id-2 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-2 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-2 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-2 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-2 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-2 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-2 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-2 div.sk-label-container {text-align: center;}#sk-container-id-2 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-2 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-2" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>GridSearchCV(cv=5, estimator=SVC(),
             param_grid={&#x27;C&#x27;: [0.001, 0.01, 0.1, 1, 10, 100],
                         &#x27;gamma&#x27;: [0.001, 0.01, 0.1, 1, 10, 100]})</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">GridSearchCV</label><div class="sk-toggleable__content"><pre>GridSearchCV(cv=5, estimator=SVC(),
             param_grid={&#x27;C&#x27;: [0.001, 0.01, 0.1, 1, 10, 100],
                         &#x27;gamma&#x27;: [0.001, 0.01, 0.1, 1, 10, 100]})</pre></div></div></div><div class="sk-parallel"><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">estimator: SVC</label><div class="sk-toggleable__content"><pre>SVC()</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-4" type="checkbox" ><label for="sk-estimator-id-4" class="sk-toggleable__label sk-toggleable__label-arrow">SVC</label><div class="sk-toggleable__content"><pre>SVC()</pre></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<ul class="simple">
<li><p>El objeto <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> no sólo busca los mejores parámetros, sino que también automáticamente un <code class="docutils literal notranslate"><span class="pre">nuevo</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">todo</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">con</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">que</span> <span class="pre">han</span> <span class="pre">dado</span> <span class="pre">el</span> <span class="pre">mejor</span> <span class="pre">rendimiento</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span></code>. La clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> proporciona una interfaz muy conveniente para acceder al modelo reentrenado utilizando los métodos <code class="docutils literal notranslate"><span class="pre">predict</span></code> y <code class="docutils literal notranslate"><span class="pre">score</span></code>. Para <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">lo</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">generalizan</span> <span class="pre">los</span> <span class="pre">mejores</span> <span class="pre">parámetros</span> <span class="pre">encontrados</span></code>, podemos llamar a <code class="docutils literal notranslate"><span class="pre">score</span></code> en el conjunto de pruebas</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Al elegir los parámetros mediante la validación cruzada, <code class="docutils literal notranslate"><span class="pre">encontramos</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">que</span> <span class="pre">alcanza</span> <span class="pre">el</span> <span class="pre">97%</span> <span class="pre">de</span> <span class="pre">precisión</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code>. <code class="docutils literal notranslate"><span class="pre">Lo</span> <span class="pre">importante</span> <span class="pre">aquí</span> <span class="pre">es</span> <span class="pre">que</span> <span class="pre">no</span> <span class="pre">utilizamos</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">para</span> <span class="pre">elegir</span> <span class="pre">los</span> <span class="pre">parámetros</span></code>. Los parámetros encontrados se anotan en el atributo <code class="docutils literal notranslate"><span class="pre">best_params_</span></code> y la mejor precisión de la validación cruzada (la precisión media sobre las diferentes divisiones para esta configuración de parámetros) se almacena en <code class="docutils literal notranslate"><span class="pre">best_score_</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best parameters: {&#39;C&#39;: 10, &#39;gamma&#39;: 0.1}
Best cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>De nuevo, tenga cuidado de no confundir <code class="docutils literal notranslate"><span class="pre">best_score_</span></code> con el rendimiento de generalización del modelo calculado por el método score en el conjunto de prueba. El uso del método score (o la evaluación de la salida del método de predicción) emplea un modelo entrenado en todo el conjunto de entrenamiento. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">atributo</span> <span class="pre">best_score_</span> <span class="pre">almacena</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada,</span> <span class="pre">con</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">realizada</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code>.</p>
</div>
<ul class="simple">
<li><p>A veces es útil tener <code class="docutils literal notranslate"><span class="pre">acceso</span> <span class="pre">al</span> <span class="pre">modelo</span> <span class="pre">real</span> <span class="pre">que</span> <span class="pre">se</span> <span class="pre">encontró</span></code>, por ejemplo, para ver los <code class="docutils literal notranslate"><span class="pre">coeficientes</span> <span class="pre">o</span> <span class="pre">la</span> <span class="pre">importancia</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">características</span></code>. Puede acceder al modelo con los mejores parámetros entrenados en todo el conjunto de entrenamiento utilizando el atributo <code class="docutils literal notranslate"><span class="pre">best_estimator_</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best estimator:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best estimator:
SVC(C=10, gamma=0.1)
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como el propio <code class="docutils literal notranslate"><span class="pre">grid_search</span></code> tiene métodos de predicción y score, no es necesario utilizar <code class="docutils literal notranslate"><span class="pre">best_estimator_</span></code> para hacer predicciones o evaluar el modelo.</p></li>
</ul>
</section>
<section id="analisis-del-resultado-de-la-validacion-cruzada">
<h3>Análisis del resultado de la validación cruzada<a class="headerlink" href="#analisis-del-resultado-de-la-validacion-cruzada" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>A menudo es útil visualizar los resultados de la validación cruzada, para entender cómo la generalización del modelo depende de los parámetros que estamos buscando. Como los <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> son bastante costosos desde el punto de vista computacional, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">buena</span> <span class="pre">idea</span> <span class="pre">empezar</span> <span class="pre">con</span> <span class="pre">grids</span> <span class="pre">de</span> <span class="pre">múltiples</span> <span class="pre">medidas,</span> <span class="pre">ya</span> <span class="pre">sean</span> <span class="pre">grandes</span> <span class="pre">o</span> <span class="pre">pequeños</span></code>. A continuación, podemos inspeccionar los resultados del <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> validado, y posiblemente ampliar nuestra búsqueda. Los resultados de un <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> se pueden encontrar en el atributo <code class="docutils literal notranslate"><span class="pre">cv_results_</span></code>, que es un diccionario que almacena todos los aspectos de la búsqueda. Este contiene muchos detalles, como se puede ver en la siguiente salida, y es mejor verlo después de convertirlo en un <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> de <code class="docutils literal notranslate"><span class="pre">pandas</span></code>. Mostramos solo algunas columnas, para que se puedan diferenciar en el book, pero en su máquina puede visualizarla todas usando la orden <code class="docutils literal notranslate"><span class="pre">results.head()</span></code>. <code class="docutils literal notranslate"><span class="pre">GridSearchCV.cv_results_</span></code> incluye los <code class="docutils literal notranslate"><span class="pre">resultados</span> <span class="pre">de</span> <span class="pre">tiempo</span> <span class="pre">para</span> <span class="pre">scoring</span> <span class="pre">y</span> <span class="pre">ajuste</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">en</span> <span class="pre">cada</span> <span class="pre">pliegue</span></code>. Por ejemplo <code class="docutils literal notranslate"><span class="pre">mean_score_time</span></code> es la cantidad media de tiempo que se necesita para scoring en los datos de cada pliegue <code class="docutils literal notranslate"><span class="pre">cv</span></code>, para cada conjunto de parámetros que definió en el <code class="docutils literal notranslate"><span class="pre">grid-search</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">)</span>
<span class="n">results</span><span class="p">[[</span><span class="s1">&#39;mean_fit_time&#39;</span><span class="p">,</span> <span class="s1">&#39;std_fit_time&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_score_time&#39;</span><span class="p">,</span>
         <span class="s1">&#39;std_score_time&#39;</span><span class="p">,</span> <span class="s1">&#39;param_C&#39;</span><span class="p">,</span> <span class="s1">&#39;param_gamma&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mean_fit_time</th>
      <th>std_fit_time</th>
      <th>mean_score_time</th>
      <th>std_score_time</th>
      <th>param_C</th>
      <th>param_gamma</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000801</td>
      <td>0.000400</td>
      <td>0.000200</td>
      <td>0.000400</td>
      <td>0.001</td>
      <td>0.001</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.000401</td>
      <td>0.000491</td>
      <td>0.000200</td>
      <td>0.000400</td>
      <td>0.001</td>
      <td>0.01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000413</td>
      <td>0.000506</td>
      <td>0.000401</td>
      <td>0.000491</td>
      <td>0.001</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.000600</td>
      <td>0.000490</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.001</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.000585</td>
      <td>0.000557</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.001</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<ul class="simple">
<li><p>Cada fila de resultados corresponde a un ajuste de parámetros concreto. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">cada</span> <span class="pre">ajuste,</span> <span class="pre">se</span> <span class="pre">registran</span> <span class="pre">los</span> <span class="pre">resultados</span> <span class="pre">de</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">divisiones</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada,</span> <span class="pre">así</span> <span class="pre">como</span> <span class="pre">la</span> <span class="pre">media</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">desviación</span> <span class="pre">estándar</span> <span class="pre">de</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">divisiones</span></code>. Como buscamos una red bidimensional de parámetros (<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code>), esto se visualiza mejor como un <code class="docutils literal notranslate"><span class="pre">mapa</span> <span class="pre">de</span> <span class="pre">calor</span></code>. Primero <code class="docutils literal notranslate"><span class="pre">extraemos</span> <span class="pre">las</span> <span class="pre">puntuaciones</span> <span class="pre">medias</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span></code> y luego las reformamos para que los ejes correspondan a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">mean_test_score</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> 
                      <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> 
                      <span class="n">xticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> 
                      <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                      <span class="n">yticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> 
                      <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/574b93cb7e7a0902269687fd7cafd481a8a74f847dcb8e9795aa150b90e906bc.png" src="_images/574b93cb7e7a0902269687fd7cafd481a8a74f847dcb8e9795aa150b90e906bc.png" />
</div>
</div>
<ul class="simple">
<li><p>Cada punto del mapa de calor corresponde a una ejecución de validación cruzada, con un parámetro en particular. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">color</span> <span class="pre">codifica</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span></code>, siendo los colores claros los relacionados con alta precisión y los colores oscuros con baja precisión. Se puede ver que <code class="docutils literal notranslate"><span class="pre">SVC</span> <span class="pre">es</span> <span class="pre">muy</span> <span class="pre">sensible</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">configuración</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span></code>. Para muchos de los ajustes de los parámetros, la precisión está en torno al 37%, lo que es bastante malo; para otros ajustes, la precisión está en torno al 96%.</p></li>
<li><p>De este gráfico se desprenden varias cosas. En primer lugar, <code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">que</span> <span class="pre">ajustamos</span> <span class="pre">son</span> <span class="pre">muy</span> <span class="pre">importantes</span> <span class="pre">para</span> <span class="pre">obtener</span> <span class="pre">un</span> <span class="pre">buen</span> <span class="pre">rendimiento</span></code>. Ambos parámetros <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">y</span> <span class="pre">gamma)</span></code> son muy importantes, ya que su ajuste puede cambiar la precisión del 37% al 96%. Además, <code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">rangos</span> <span class="pre">que</span> <span class="pre">elegimos</span> <span class="pre">para</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">son</span> <span class="pre">rangos</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">que</span> <span class="pre">vemos</span> <span class="pre">cambios</span> <span class="pre">significativos</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">resultado</span></code>. También es importante tener en cuenta que <code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">rangos</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">son</span> <span class="pre">lo</span> <span class="pre">suficientemente</span> <span class="pre">amplios:</span> <span class="pre">los</span> <span class="pre">valores</span> <span class="pre">óptimos</span> <span class="pre">de</span> <span class="pre">cada</span> <span class="pre">parámetro</span> <span class="pre">no</span> <span class="pre">están</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">bordes</span> <span class="pre">del</span> <span class="pre">gráfico</span></code>.</p></li>
<li><p>Veamos algunos gráficos en los que <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">resultado</span> <span class="pre">es</span> <span class="pre">menos</span> <span class="pre">ideal</span></code>, porque los rangos de búsqueda no fueron elegidos correctamente</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">param_grid_linear</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">param_grid_one_log</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">param_grid_range</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>

<span class="k">for</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">param_grid_linear</span><span class="p">,</span> <span class="n">param_grid_one_log</span><span class="p">,</span> <span class="n">param_grid_range</span><span class="p">],</span> <span class="n">axes</span><span class="p">):</span>
    <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">[</span><span class="s1">&#39;mean_test_score&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    
    <span class="n">scores_image</span> <span class="o">=</span> <span class="n">mglearn</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> 
                                         <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> 
                                         <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                                         <span class="n">xticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span>
                                         <span class="n">yticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> 
                                         <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> 
                                         <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e8d444391b5c87f0e8fbe824776d8a82a321828406b0e9b71b5bcd257b7a800b.png" src="_images/e8d444391b5c87f0e8fbe824776d8a82a321828406b0e9b71b5bcd257b7a800b.png" />
</div>
</div>
<ul class="simple">
<li><p>El primer panel no muestra ningún cambio, con scores aproximadamente constantes en toda la red de parámetros. En este caso, esto se debe a una escala y un <code class="docutils literal notranslate"><span class="pre">rango</span> <span class="pre">inadecuado</span> <span class="pre">para</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code>. Sin embargo, <code class="docutils literal notranslate"><span class="pre">si</span> <span class="pre">no</span> <span class="pre">se</span> <span class="pre">aprecia</span> <span class="pre">ningún</span> <span class="pre">cambio</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">a</span> <span class="pre">lo</span> <span class="pre">largo</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">diferentes</span> <span class="pre">ajustes</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros,</span> <span class="pre">también</span> <span class="pre">puede</span> <span class="pre">ser</span> <span class="pre">que</span> <span class="pre">un</span> <span class="pre">parámetro</span> <span class="pre">no</span> <span class="pre">sea</span> <span class="pre">importante</span> <span class="pre">en</span> <span class="pre">absoluto</span></code>. Suele ser bueno probar primero valores muy extremos, para ver si hay algún cambio en la precisión como resultado de cambiar un parámetro. El segundo panel muestra un patrón de rayas verticales. Esto indica que sólo el ajuste del parámetro <code class="docutils literal notranslate"><span class="pre">gamma</span></code> hace alguna diferencia. Esto podría significar que el parámetro <code class="docutils literal notranslate"><span class="pre">gamma</span> <span class="pre">busca</span> <span class="pre">valores</span> <span class="pre">interesantes,</span> <span class="pre">pero</span> <span class="pre">el</span> <span class="pre">parámetro</span> <span class="pre">C</span> <span class="pre">no</span> <span class="pre">lo</span> <span class="pre">hace,</span> <span class="pre">o</span> <span class="pre">podría</span> <span class="pre">significar</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">parámetro</span> <span class="pre">C</span> <span class="pre">no</span> <span class="pre">es</span> <span class="pre">importante</span></code>.</p></li>
<li><p>El tercer panel muestra <code class="docutils literal notranslate"><span class="pre">cambios</span> <span class="pre">tanto</span> <span class="pre">en</span> <span class="pre">C</span> <span class="pre">como</span> <span class="pre">en</span> <span class="pre">gamma</span></code>. Sin embargo, podemos ver que en toda la toda la parte inferior izquierda del gráfico, no ocurre nada interesante. Probablemente podemos excluir los valores muy pequeños de las futuras búsquedas en la red. <code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">configuración</span> <span class="pre">óptima</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">está</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">parte</span> <span class="pre">superior</span> <span class="pre">derecha</span></code>. <code class="docutils literal notranslate"><span class="pre">Como</span> <span class="pre">el</span> <span class="pre">óptimo</span> <span class="pre">está</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">borde</span> <span class="pre">del</span> <span class="pre">gráfico,</span> <span class="pre">podemos</span> <span class="pre">esperar</span> <span class="pre">que</span> <span class="pre">puede</span> <span class="pre">haber</span> <span class="pre">valores</span> <span class="pre">aún</span> <span class="pre">mejores</span> <span class="pre">más</span> <span class="pre">allá</span> <span class="pre">de</span> <span class="pre">este</span> <span class="pre">límite,</span> <span class="pre">y</span> <span class="pre">podríamos</span> <span class="pre">cambiar</span> <span class="pre">nuestro</span> <span class="pre">rango</span> <span class="pre">de</span> <span class="pre">búsqueda</span> <span class="pre">para</span> <span class="pre">incluir</span> <span class="pre">más</span> <span class="pre">parámetros</span> <span class="pre">en</span> <span class="pre">esta</span> <span class="pre">región</span></code>. Ajustar la red de parámetros basándose en las puntuaciones de validación cruzada es perfectamente correcto, y una buena manera de explorar la importancia de los diferentes parámetros. Sin embargo, <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">debería</span> <span class="pre">probar</span> <span class="pre">diferentes</span> <span class="pre">rangos</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">pruebas</span> <span class="pre">final</span></code>, ya que, como hemos dicho antes, <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">evaluación</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">pruebas</span> <span class="pre">sólo</span> <span class="pre">debería</span> <span class="pre">realizarse</span> <span class="pre">una</span> <span class="pre">vez</span> <span class="pre">que</span> <span class="pre">sepamos</span> <span class="pre">exactamente</span> <span class="pre">qué</span> <span class="pre">modelo</span> <span class="pre">queremos</span> <span class="pre">utilizar</span></code>.</p></li>
</ul>
</section>
<section id="busqueda-sobre-espacios-que-no-son-una-red">
<h3>Búsqueda sobre espacios que no son una red<a class="headerlink" href="#busqueda-sobre-espacios-que-no-son-una-red" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>En algunos casos, probar todas las combinaciones posibles de todos los parámetros, como suele hacer <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, no es una buena idea. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">SVC</span></code> tiene un parámetro de <code class="docutils literal notranslate"><span class="pre">kernel</span></code>, y dependiendo del <code class="docutils literal notranslate"><span class="pre">kernel</span></code> que se elija, otros parámetros serán relevantes. Si <code class="docutils literal notranslate"><span class="pre">kernel='linear'</span></code>, el modelo es lineal, y sólo se utiliza el parámetro <code class="docutils literal notranslate"><span class="pre">C</span></code>. Si <code class="docutils literal notranslate"><span class="pre">kernel='rbf'</span></code>, se utilizan los parámetros <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code> (pero no otros parámetros como el grado). En este caso, la búsqueda de todas las combinaciones posibles de <code class="docutils literal notranslate"><span class="pre">C,</span> <span class="pre">gamma</span> <span class="pre">y</span> <span class="pre">kernel</span></code> no tendría sentido: si <code class="docutils literal notranslate"><span class="pre">kernel='linear',</span> <span class="pre">gamma</span></code> no se utiliza, y probar diferentes valores de <code class="docutils literal notranslate"><span class="pre">gamma</span></code> sería una pérdida de tiempo. Recuerde que <code class="docutils literal notranslate"><span class="pre">kernel='rbf'</span></code> es el <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">de</span> <span class="pre">función</span> <span class="pre">de</span> <span class="pre">base</span> <span class="pre">radial</span> <span class="pre">(RBF)</span></code> con mapeo de características <span class="math notranslate nohighlight">\(\phi(\boldsymbol{x})=\exp(\|\boldsymbol{x}-x_{i}\|/2\sigma^2),~\gamma=1/\sigma^2\)</span>. Para ver todas las opciones de kernel gaussianos (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/gaussian_process.html#gp-kernels">Kernels for Gaussian Processes</a>).</p></li>
<li><p>Para tratar este tipo de parámetros “condicionales”, <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> permite que param_grid sea una lista de diccionarios. Cada diccionario de la lista se expande en una red <code class="docutils literal notranslate"><span class="pre">(grid)</span></code> independiente. Una posible búsqueda en red que incluya el núcleo (<code class="docutils literal notranslate"><span class="pre">kernel</span></code>) y los parámetros podría ser así:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;rbf&#39;</span><span class="p">],</span>
               <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
               <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]},</span>
              <span class="p">{</span><span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">],</span>
               <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List of grids:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>List of grids:
[{&#39;kernel&#39;: [&#39;rbf&#39;], &#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100], &#39;gamma&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}, {&#39;kernel&#39;: [&#39;linear&#39;], &#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>En la primera red, el parámetro del <code class="docutils literal notranslate"><span class="pre">kernel</span></code> se establece siempre en <code class="docutils literal notranslate"><span class="pre">'rbf'</span></code> (no que la entrada de <code class="docutils literal notranslate"><span class="pre">kernel</span></code> es una lista de longitud uno), y se varían los parámetros <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code>. <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">la</span> <span class="pre">segunda</span> <span class="pre">red,</span> <span class="pre">el</span> <span class="pre">parámetro</span> <span class="pre">kernel</span> <span class="pre">siempre</span> <span class="pre">se</span> <span class="pre">establece</span> <span class="pre">como</span> <span class="pre">lineal,</span> <span class="pre">y</span> <span class="pre">sólo</span> <span class="pre">se</span> <span class="pre">varía</span> <span class="pre">C</span></code>. Ahora apliquemos esta búsqueda de parámetros más compleja</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best parameters: {&#39;C&#39;: 10, &#39;gamma&#39;: 0.1, &#39;kernel&#39;: &#39;rbf&#39;}
Best cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Observemos de nuevo el <code class="docutils literal notranslate"><span class="pre">cv_results_</span></code>. Como era de esperar, si el núcleo es <code class="docutils literal notranslate"><span class="pre">&quot;lineal&quot;</span></code>, sólo varía <code class="docutils literal notranslate"><span class="pre">C</span></code>. Nótese que el <code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">tiene</span> <span class="pre">un</span> <span class="pre">total</span> <span class="pre">de</span> <span class="pre">16</span> <span class="pre">columnas</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span> <span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">])</span>
<span class="n">results</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>mean_fit_time</th>
      <td>0.000623</td>
      <td>0.000612</td>
      <td>0.0002</td>
      <td>0.000311</td>
      <td>0.000616</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>std_fit_time</th>
      <td>0.00051</td>
      <td>0.0005</td>
      <td>0.0004</td>
      <td>0.000406</td>
      <td>0.000504</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>mean_score_time</th>
      <td>0.0004</td>
      <td>0.0</td>
      <td>0.0002</td>
      <td>0.000402</td>
      <td>0.000201</td>
      <td>0.000411</td>
    </tr>
    <tr>
      <th>std_score_time</th>
      <td>0.00049</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>0.000492</td>
      <td>0.000402</td>
      <td>0.000504</td>
    </tr>
    <tr>
      <th>param_C</th>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
    </tr>
    <tr>
      <th>param_gamma</th>
      <td>0.001</td>
      <td>0.01</td>
      <td>0.1</td>
      <td>1</td>
      <td>10</td>
      <td>100</td>
    </tr>
    <tr>
      <th>param_kernel</th>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
    </tr>
    <tr>
      <th>params</th>
      <td>{'C': 0.001, 'gamma': 0.001, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 0.01, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 0.1, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 1, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 10, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 100, 'kernel': 'rbf'}</td>
    </tr>
    <tr>
      <th>split0_test_score</th>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
    </tr>
    <tr>
      <th>split1_test_score</th>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
    </tr>
    <tr>
      <th>split2_test_score</th>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
    </tr>
    <tr>
      <th>split3_test_score</th>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
    </tr>
    <tr>
      <th>split4_test_score</th>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
    </tr>
    <tr>
      <th>mean_test_score</th>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
    </tr>
    <tr>
      <th>std_test_score</th>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
    </tr>
    <tr>
      <th>rank_test_score</th>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(16, 42)
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Uso de diferentes estrategias de validación cruzada con la búsqueda en red</p>
<p>Al igual que <code class="docutils literal notranslate"><span class="pre">cross_val_score,</span> <span class="pre">GridSearchCV</span></code> utiliza por defecto la validación cruzada estratificada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> para la clasificación, y la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">k-fold</span></code> para la regresión. Sin embargo, también puede pasar cualquier divisor de validación cruzada, como se describe en <code class="docutils literal notranslate"><span class="pre">&quot;Más</span> <span class="pre">control</span> <span class="pre">sobre</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada&quot;</span></code>, como parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code> en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>. En particular, para obtener una única división en un conjunto de entrenamiento y otro de validación, puede utilizar <code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code> o <code class="docutils literal notranslate"><span class="pre">StratifiedShuffleSplit</span></code> con <code class="docutils literal notranslate"><span class="pre">n_iter=1</span></code> (número de iteraciones de reordenamiento y división). Esto puede ser útil para conjuntos de datos muy grandes o para modelos muy lentos.</p>
</div>
</section>
<section id="validacion-cruzada-anidada">
<h3>Validación cruzada anidada<a class="headerlink" href="#validacion-cruzada-anidada" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>En los ejemplos anteriores, pasamos de utilizar una única división de los datos en conjuntos de entrenamiento validación y prueba, a <code class="docutils literal notranslate"><span class="pre">dividir</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">prueba,</span> <span class="pre">y</span> <span class="pre">luego</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">entrenamiento</span></code>. Pero al utilizar <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> como se ha descrito anteriormente, <code class="docutils literal notranslate"><span class="pre">seguimos</span> <span class="pre">teniendo</span> <span class="pre">una</span> <span class="pre">única</span> <span class="pre">división</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">prueba</span></code>, lo que puede hacer que nuestros resultados sean inestables y nos haga depender demasiado de esta única división de los datos. Podemos ir un paso más allá, y <code class="docutils literal notranslate"><span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">dividir</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">originales</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">prueba</span> <span class="pre">una</span> <span class="pre">vez,</span> <span class="pre">utilizar</span> <span class="pre">múltiples</span> <span class="pre">divisiones</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada</span></code>. Esto dará lugar a lo que se denomina <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada,</span> <span class="pre">hay</span> <span class="pre">un</span> <span class="pre">bucle</span> <span class="pre">externo</span> <span class="pre">sobre</span> <span class="pre">las</span> <span class="pre">divisiones</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">de</span> <span class="pre">prueba.</span> <span class="pre">Para</span> <span class="pre">cada</span> <span class="pre">uno</span> <span class="pre">de</span> <span class="pre">ellos,</span> <span class="pre">se</span> <span class="pre">ejecuta</span> <span class="pre">una</span> <span class="pre">búsqueda</span> <span class="pre">en</span> <span class="pre">red</span></code> (que puede dar lugar a diferentes parámetros óptimos para cada división en el bucle externo). A continuación, para cada división exterior, se informa del scoring del conjunto de prueba utilizando los mejores parámetros. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">resultado</span> <span class="pre">de</span> <span class="pre">este</span> <span class="pre">procedimiento</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">lista</span> <span class="pre">de</span> <span class="pre">puntuaciones,</span> <span class="pre">no</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">ni</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">parámetros</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Las</span> <span class="pre">puntuaciones</span> <span class="pre">nos</span> <span class="pre">dicen</span> <span class="pre">lo</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">generaliza</span> <span class="pre">un</span> <span class="pre">modelo</span></code>, dados los mejores parámetros encontrados por la red. Como no proporciona un modelo que pueda utilizarse con nuevos datos, la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada</span> <span class="pre">no</span> <span class="pre">suele</span> <span class="pre">utilizarse</span> <span class="pre">cuando</span> <span class="pre">se</span> <span class="pre">busca</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">predictivo</span> <span class="pre">para</span> <span class="pre">aplicarlo</span> <span class="pre">a</span> <span class="pre">datos</span> <span class="pre">futuros</span></code>. Sin embargo, puede ser útil para evaluar lo bien que funciona un modelo determinado en un conjunto de datos concreto. La implementación de la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada</span></code> en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> es sencilla. Llamamos a <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> con una instancia de <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> como modelo</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean cross-validation score: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:  [0.96666667 1.         0.9        0.96666667 1.        ]
Mean cross-validation score:  0.9666666666666668
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El resultado de nuestra <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada</span></code> puede resumirse en que <code class="docutils literal notranslate"><span class="pre">&quot;SVC</span> <span class="pre">puede</span> <span class="pre">alcanzar</span> <span class="pre">un</span> <span class="pre">96.67%</span> <span class="pre">de</span> <span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">del</span> <span class="pre">iris&quot;</span></code>, nada más y nada menos. Aquí, utilizamos la validación cruzada estratificada de cinco pliegues (<code class="docutils literal notranslate"><span class="pre">5-fold</span></code>) tanto en el bucle interno como en el externo. Como nuestra red de parámetros contiene 36 combinaciones de parámetros, <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">resultado</span> <span class="pre">es</span> <span class="pre">la</span> <span class="pre">cantidad</span> <span class="pre">de</span> <span class="pre">36</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">=</span> <span class="pre">900</span> <span class="pre">modelos</span> <span class="pre">construidos,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">hace</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">anidada</span> <span class="pre">sea</span> <span class="pre">un</span> <span class="pre">procedimiento</span> <span class="pre">muy</span> <span class="pre">costoso</span></code>.</p></li>
<li><p>Aquí, <code class="docutils literal notranslate"><span class="pre">utilizamos</span> <span class="pre">el</span> <span class="pre">mismo</span> <span class="pre">divisor</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">bucle</span> <span class="pre">interno</span> <span class="pre">y</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">externo</span></code>; sin embargo, esto no es necesario y se puede utilizar cualquier combinación de estrategias de validación cruzada en el bucle interno y en el externo. Puede ser un poco complicado entender lo que está sucediendo en la línea simple dada anteriormente, y puede ser útil <code class="docutils literal notranslate"><span class="pre">visualizarlo</span> <span class="pre">como</span> <span class="pre">bucles</span> <span class="pre">for,</span> <span class="pre">como</span> <span class="pre">se</span> <span class="pre">hace</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">siguiente</span> <span class="pre">implementación</span> <span class="pre">simplificada</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nested_cv</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inner_cv</span><span class="p">,</span> <span class="n">outer_cv</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">,</span> <span class="n">parameter_grid</span><span class="p">):</span>
    <span class="n">outer_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">training_samples</span><span class="p">,</span> <span class="n">test_samples</span> <span class="ow">in</span> <span class="n">outer_cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">best_parms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">parameter_grid</span><span class="p">:</span>
            <span class="n">cv_scores</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">inner_train</span><span class="p">,</span> <span class="n">inner_test</span> <span class="ow">in</span> <span class="n">inner_cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">training_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">training_samples</span><span class="p">]):</span>
                <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
                <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">inner_train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">inner_train</span><span class="p">])</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">inner_test</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">inner_test</span><span class="p">])</span>
                <span class="n">cv_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="n">mean_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">mean_score</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">)</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">training_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">training_samples</span><span class="p">])</span>
        <span class="n">outer_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">test_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_samples</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outer_scores</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">ParameterGrid</span><span class="p">,</span> <span class="n">StratifiedKFold</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">nested_cv</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="n">StratifiedKFold</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">SVC</span><span class="p">,</span> <span class="n">ParameterGrid</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]
</pre></div>
</div>
</div>
</div>
</section>
<section id="paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">
<h3>Paralelización de la validación cruzada y la búsqueda en red<a class="headerlink" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Si bien la ejecución de una <code class="docutils literal notranslate"><span class="pre">búsqueda</span> <span class="pre">en</span> <span class="pre">red</span></code> sobre muchos parámetros y en grandes conjuntos de datos puede ser <code class="docutils literal notranslate"><span class="pre">computacionalmente</span> <span class="pre">un</span> <span class="pre">reto</span></code>, también es un paralelismo tedioso. Esto significa que la construcción de un modelo utilizando un ajuste de parámetros particular en una división de validación cruzada particular <code class="docutils literal notranslate"><span class="pre">puede</span> <span class="pre">hacerse</span> <span class="pre">con</span> <span class="pre">total</span> <span class="pre">independencia</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">demás</span> <span class="pre">ajustes</span> <span class="pre">de</span> <span class="pre">parámetros</span> <span class="pre">y</span> <span class="pre">modelos</span></code>. <code class="docutils literal notranslate"><span class="pre">Esto</span> <span class="pre">hace</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">búsqueda</span> <span class="pre">en</span> <span class="pre">red</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">sean</span> <span class="pre">candidatas</span> <span class="pre">ideales</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">paralelización</span> <span class="pre">en</span> <span class="pre">múltiples</span> <span class="pre">núcleos</span> <span class="pre">de</span> <span class="pre">CPU</span> <span class="pre">o</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">clúster</span></code>. Se puede hacer uso de múltiples núcleos en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> y <code class="docutils literal notranslate"><span class="pre">cross_validation</span></code> estableciendo el parámetro <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> con el número de núcleos de CPU que desee utilizar. <code class="docutils literal notranslate"><span class="pre">Puede</span> <span class="pre">establecer</span> <span class="pre">n_jobs=-1</span> <span class="pre">para</span> <span class="pre">utilizar</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">núcleos</span> <span class="pre">disponibles</span></code>.</p></li>
<li><p>Debe tener en cuenta que <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> no permite el anidamiento de operaciones paralelas. Por lo tanto, si está utilizando la opción <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> en su modelo (por ejemplo, <code class="docutils literal notranslate"><span class="pre">random</span> <span class="pre">forest</span></code>), no puede utilizarla en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> para buscar sobre este modelo. Si su <code class="docutils literal notranslate"><span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">y</span> <span class="pre">su</span> <span class="pre">modelo</span> <span class="pre">son</span> <span class="pre">muy</span> <span class="pre">grandes,</span> <span class="pre">puede</span> <span class="pre">ser</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">uso</span> <span class="pre">de</span> <span class="pre">muchos</span> <span class="pre">núcleos</span> <span class="pre">consuma</span> <span class="pre">demasiada</span> <span class="pre">memoria</span></code>, y deberías controlar el uso de la memoria cuando construyas modelos grandes en paralelo. <code class="docutils literal notranslate"><span class="pre">También</span> <span class="pre">es</span> <span class="pre">posible</span> <span class="pre">paralelizar</span> <span class="pre">la</span> <span class="pre">búsqueda</span> <span class="pre">en</span> <span class="pre">red</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">en</span> <span class="pre">varias</span> <span class="pre">máquinas</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">clúster</span></code>. Sin embargo, es posible utilizar el marco paralelo de <code class="docutils literal notranslate"><span class="pre">IPython</span></code> para las búsquedas paralelas de la red, también puede <code class="docutils literal notranslate"><span class="pre">escribir</span> <span class="pre">el</span> <span class="pre">bucle</span> <span class="pre">for</span> <span class="pre">sobre</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">como</span> <span class="pre">lo</span> <span class="pre">hicimos</span> <span class="pre">en</span> <span class="pre">&quot;Búsqueda</span> <span class="pre">simple</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">red&quot;</span></code>. <strong><code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">los</span> <span class="pre">usuarios</span> <span class="pre">de</span> <span class="pre">Spark,</span> <span class="pre">también</span> <span class="pre">existe</span> <span class="pre">el</span> <span class="pre">paquete</span> <span class="pre">spark-sklearn,</span> <span class="pre">recientemente</span> <span class="pre">desarrollado,</span> <span class="pre">que</span> <span class="pre">permite</span> <span class="pre">ejecutar</span> <span class="pre">una</span> <span class="pre">búsqueda</span> <span class="pre">grid</span> <span class="pre">sobre</span> <span class="pre">un</span> <span class="pre">cluster</span> <span class="pre">Spark</span> <span class="pre">ya</span> <span class="pre">establecido</span></code></strong>.</p></li>
</ul>
</section>
</section>
<section id="metricas-de-evaluacion-y-scoring">
<h2>Métricas de evaluación y scoring<a class="headerlink" href="#metricas-de-evaluacion-y-scoring" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Hasta ahora, hemos evaluado el <code class="docutils literal notranslate"><span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">clasificación</span> <span class="pre">utilizando</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">(accuracy)</span></code> (la fracción de muestras correctamente clasificadas) y el <code class="docutils literal notranslate"><span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">regresión</span></code> mediante el <span class="math notranslate nohighlight">\(R^2\)</span>. Sin embargo, éstas son sólo dos de las muchas formas posibles de resumir la eficacia de un modelo supervisado en un conjunto de datos determinado. <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">la</span> <span class="pre">práctica,</span> <span class="pre">estas</span> <span class="pre">métricas</span> <span class="pre">de</span> <span class="pre">evaluación</span> <span class="pre">pueden</span> <span class="pre">no</span> <span class="pre">ser</span> <span class="pre">apropiadas</span> <span class="pre">para</span> <span class="pre">su</span> <span class="pre">aplicación,</span> <span class="pre">y</span> <span class="pre">es</span> <span class="pre">importante</span> <span class="pre">elegir</span> <span class="pre">la</span> <span class="pre">métrica</span> <span class="pre">correcta</span> <span class="pre">cuando</span> <span class="pre">se</span> <span class="pre">selecciona</span> <span class="pre">entre</span> <span class="pre">modelos</span> <span class="pre">y</span> <span class="pre">se</span> <span class="pre">ajustan</span> <span class="pre">los</span> <span class="pre">parámetros</span></code>.</p></li>
</ul>
<section id="tenga-en-cuenta-el-objetivo-final">
<h3>Tenga en cuenta el objetivo final<a class="headerlink" href="#tenga-en-cuenta-el-objetivo-final" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Al seleccionar una métrica, siempre hay que tener en cuenta el objetivo final de la aplicación de aprendizaje automático. En la práctica, normalmente nos interesa no sólo hacer predicciones precisas, sino que utilizar estas predicciones como parte de un proceso de decisiones. <code class="docutils literal notranslate"><span class="pre">Antes</span> <span class="pre">de</span> <span class="pre">elegir</span> <span class="pre">una</span> <span class="pre">métrica</span> <span class="pre">de</span> <span class="pre">aprendizaje</span> <span class="pre">automático,</span> <span class="pre">debería</span> <span class="pre">pensar</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">objetivo</span> <span class="pre">de</span> <span class="pre">alto</span> <span class="pre">nivel</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">aplicación,</span> <span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">llamado</span> <span class="pre">métrica</span> <span class="pre">de</span> <span class="pre">negocio</span></code>. <code class="docutils literal notranslate"><span class="pre">Las</span> <span class="pre">consecuencias</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">elección</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">algoritmo</span> <span class="pre">concreto</span> <span class="pre">para</span> <span class="pre">una</span> <span class="pre">aplicación</span> <span class="pre">de</span> <span class="pre">aprendizaje</span> <span class="pre">automático</span> <span class="pre">se</span> <span class="pre">denominan</span> <span class="pre">impacto</span> <span class="pre">empresarial</span></code>.</p></li>
<li><p>Puede que el objetivo de alto nivel sea evitar accidentes de tráfico, o reducir el número de ingresos hospitalarios. También podría ser conseguir más usuarios para su sitio web, o que los usuarios gasten más dinero en su tienda. Al elegir un modelo o ajustar los parámetros, <code class="docutils literal notranslate"><span class="pre">debe</span> <span class="pre">elegir</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">o</span> <span class="pre">los</span> <span class="pre">valores</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">que</span> <span class="pre">influyan</span> <span class="pre">más</span> <span class="pre">positivamente</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">métrica</span> <span class="pre">del</span> <span class="pre">negocio</span></code>. A menudo, esto es difícil, ya que <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">evaluación</span> <span class="pre">del</span> <span class="pre">impacto</span> <span class="pre">comercial</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">particular</span> <span class="pre">puede</span> <span class="pre">requerir</span> <span class="pre">ponerlo</span> <span class="pre">en</span> <span class="pre">producción</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">sistema</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">vida</span> <span class="pre">real</span></code>.</p></li>
<li><p>En las primeras fases de desarrollo, y para ajustar los parámetros, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">es</span> <span class="pre">inviable</span> <span class="pre">poner</span> <span class="pre">los</span> <span class="pre">modelos</span> <span class="pre">en</span> <span class="pre">producción</span> <span class="pre">sólo</span> <span class="pre">para</span> <span class="pre">probarlos,</span> <span class="pre">debido</span> <span class="pre">a</span> <span class="pre">los</span> <span class="pre">elevados</span> <span class="pre">riesgos</span> <span class="pre">empresariales</span> <span class="pre">o</span> <span class="pre">personales</span> <span class="pre">que</span> <span class="pre">puede</span> <span class="pre">conllevar</span></code>. Imagínese que se evalúa la <code class="docutils literal notranslate"><span class="pre">capacidad</span> <span class="pre">que</span> <span class="pre">tiene</span> <span class="pre">un</span> <span class="pre">coche</span> <span class="pre">autodirigido</span> <span class="pre">de</span> <span class="pre">evitar</span> <span class="pre">a</span> <span class="pre">los</span> <span class="pre">peatones</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">coche,</span> <span class="pre">dejándolo</span> <span class="pre">circular</span> <span class="pre">sin</span> <span class="pre">verificarlo</span> <span class="pre">primero</span></code>. Si el modelo es malo, los peatones tendrán problemas. Por lo tanto, a menudo tenemos que encontrar un procedimiento de evaluación alternativo, utilizando una métrica de evaluación que sea más fácil de calcular. Por ejemplo, podríamos probar la <code class="docutils literal notranslate"><span class="pre">clasificación</span> <span class="pre">de</span> <span class="pre">imágenes</span> <span class="pre">de</span> <span class="pre">peatones</span> <span class="pre">frente</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">de</span> <span class="pre">no</span> <span class="pre">peatones</span> <span class="pre">y</span> <span class="pre">medir</span> <span class="pre">la</span> <span class="pre">precisión</span></code>.</p></li>
<li><p>Hay que tener en cuenta que esto es sólo un sustituto, y que vale la pena encontrar la métrica más cercana al objetivo original de la empresa, que sea factible de evaluar. Esta métrica más cercana debe utilizarse siempre que sea posible para la evaluación y selección de modelos. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">resultado</span> <span class="pre">de</span> <span class="pre">esta</span> <span class="pre">evaluación</span> <span class="pre">puede</span> <span class="pre">no</span> <span class="pre">ser</span> <span class="pre">un</span> <span class="pre">solo</span> <span class="pre">número</span> <span class="pre">-</span> <span class="pre">consecuencia</span> <span class="pre">de</span> <span class="pre">su</span> <span class="pre">algoritmo</span> <span class="pre">puede</span> <span class="pre">ser</span> <span class="pre">que</span> <span class="pre">tenga</span> <span class="pre">un</span> <span class="pre">10%</span> <span class="pre">más</span> <span class="pre">de</span> <span class="pre">clientes,</span> <span class="pre">pero</span> <span class="pre">que</span> <span class="pre">cada</span> <span class="pre">cliente</span> <span class="pre">gaste</span> <span class="pre">un</span> <span class="pre">15%</span> <span class="pre">menos</span> <span class="pre">-</span> <span class="pre">pero</span> <span class="pre">debería</span> <span class="pre">capturar</span> <span class="pre">el</span> <span class="pre">impacto</span> <span class="pre">empresarial</span> <span class="pre">esperado</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">elección</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">otro.</span></code> En esta sección, primero discutiremos las métricas para el importante caso especial de la clasificación binaria, y luego pasaremos a la clasificación multiclase, y por último, a la regresión.</p></li>
</ul>
</section>
<section id="metricas-para-la-clasificacion-binaria">
<h3>Métricas para la clasificación binaria<a class="headerlink" href="#metricas-para-la-clasificacion-binaria" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>La clasificación binaria es probablemente la aplicación más común y conceptualmente simple de aprendizaje automático en la práctica. <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span> <span class="pre">todavía</span> <span class="pre">hay</span> <span class="pre">una</span> <span class="pre">serie</span> <span class="pre">de</span> <span class="pre">advertencias</span> <span class="pre">en</span> <span class="pre">evaluar</span> <span class="pre">incluso</span> <span class="pre">esta</span> <span class="pre">sencilla</span> <span class="pre">tarea</span></code>. Antes de entrar en las métricas alternativas, echemos un vistazo a la forma en que se mide la precisión, la cual puede ser engañosa. Recordemos que para la clasificación binaria, a menudo hablamos de una <code class="docutils literal notranslate"><span class="pre">clase</span> <span class="pre">positiva</span></code> y una <code class="docutils literal notranslate"><span class="pre">clase</span> <span class="pre">negativa</span></code>, entendiendo que la clase positiva es la que estamos buscando.</p></li>
</ul>
</section>
<section id="tipos-de-errores">
<h3>Tipos de errores<a class="headerlink" href="#tipos-de-errores" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>A menudo, la precisión (<code class="docutils literal notranslate"><span class="pre">accuracy</span></code>), la cual divide el número de predicciones correctas por el número total de predicciones, no es una buena medida del rendimiento predictivo, ya que el número de errores que cometemos no contiene toda la información que nos interesa. <code class="docutils literal notranslate"><span class="pre">Imagine</span> <span class="pre">una</span> <span class="pre">aplicación</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">detección</span> <span class="pre">temprana</span> <span class="pre">del</span> <span class="pre">cáncer</span> <span class="pre">mediante</span> <span class="pre">una</span> <span class="pre">prueba</span> <span class="pre">automatizada.</span> <span class="pre">Si</span> <span class="pre">la</span> <span class="pre">prueba</span> <span class="pre">es</span> <span class="pre">negativa,</span> <span class="pre">el</span> <span class="pre">paciente</span> <span class="pre">se</span> <span class="pre">considerará</span> <span class="pre">sano,</span> <span class="pre">mientras</span> <span class="pre">que</span> <span class="pre">si</span> <span class="pre">la</span> <span class="pre">prueba</span> <span class="pre">es</span> <span class="pre">positiva,</span> <span class="pre">el</span> <span class="pre">paciente</span> <span class="pre">se</span> <span class="pre">someterá</span> <span class="pre">a</span> <span class="pre">un</span> <span class="pre">examen</span> <span class="pre">adicional</span></code>. En este caso, llamaríamos <code class="docutils literal notranslate"><span class="pre">clase</span> <span class="pre">positiva</span></code> a una prueba positiva (un indicio de cáncer), y <code class="docutils literal notranslate"><span class="pre">clase</span> <span class="pre">negativa</span></code> a una prueba negativa. <code class="docutils literal notranslate"><span class="pre">No</span> <span class="pre">podemos</span> <span class="pre">suponer</span> <span class="pre">que</span> <span class="pre">nuestro</span> <span class="pre">modelo</span> <span class="pre">funcione</span> <span class="pre">siempre</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">perfección,</span> <span class="pre">este</span> <span class="pre">cometerá</span> <span class="pre">errores</span></code>. Para cualquier aplicación, tenemos que preguntarnos cuáles son las consecuencias de estos errores en el mundo real.</p></li>
<li><p>Un posible error es que un <code class="docutils literal notranslate"><span class="pre">paciente</span> <span class="pre">sano</span> <span class="pre">sea</span> <span class="pre">clasificado</span> <span class="pre">como</span> <span class="pre">positivo</span></code>, lo que lleva a pruebas adicionales. Esto conlleva algunos costes y una molestia para el paciente (y posiblemente angustia mental). Una <code class="docutils literal notranslate"><span class="pre">predicción</span> <span class="pre">positiva</span> <span class="pre">incorrecta</span> <span class="pre">se</span> <span class="pre">denomina</span></code> <strong><code class="docutils literal notranslate"><span class="pre">falso</span> <span class="pre">positivo</span></code></strong>.  Otro error posible es que un <code class="docutils literal notranslate"><span class="pre">paciente</span> <span class="pre">enfermo</span> <span class="pre">sea</span> <span class="pre">clasificado</span> <span class="pre">como</span> <span class="pre">negativo</span></code>, y no reciba más pruebas ni tratamiento. <strong><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">cáncer</span> <span class="pre">no</span> <span class="pre">diagnosticado</span> <span class="pre">podría</span> <span class="pre">dar</span> <span class="pre">lugar</span> <span class="pre">a</span> <span class="pre">graves</span> <span class="pre">problemas</span> <span class="pre">de</span> <span class="pre">salud,</span> <span class="pre">e</span> <span class="pre">incluso</span> <span class="pre">podría</span> <span class="pre">ser</span> <span class="pre">mortal</span></code></strong>. Un error de este tipo - una <code class="docutils literal notranslate"><span class="pre">predicción</span> <span class="pre">negativa</span> <span class="pre">incorrecta</span> <span class="pre">se</span> <span class="pre">denomina</span></code> <strong><code class="docutils literal notranslate"><span class="pre">falso</span> <span class="pre">negativo</span></code></strong>. En estadística, un <code class="docutils literal notranslate"><span class="pre">falso</span> <span class="pre">positivo</span> <span class="pre">también</span> <span class="pre">se</span> <span class="pre">conoce</span> <span class="pre">como</span> <span class="pre">error</span> <span class="pre">de</span> <span class="pre">tipo</span> <span class="pre">I</span></code>, y un <code class="docutils literal notranslate"><span class="pre">falso</span> <span class="pre">negativo</span> <span class="pre">como</span> <span class="pre">error</span> <span class="pre">de</span> <span class="pre">tipo</span> <span class="pre">II</span></code>. Nos ceñiremos a los términos <code class="docutils literal notranslate"><span class="pre">&quot;falso</span> <span class="pre">negativo&quot;</span> <span class="pre">y</span> <span class="pre">&quot;falso</span> <span class="pre">positivo&quot;</span></code>, ya que son más explícitos y fáciles de recordar. En el ejemplo del diagnóstico de cáncer, está claro que <code class="docutils literal notranslate"><span class="pre">queremos</span> <span class="pre">evitar</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">negativos</span></code> en la medida de lo posible, <code class="docutils literal notranslate"><span class="pre">mientras</span> <span class="pre">que</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">positivos</span> <span class="pre">pueden</span> <span class="pre">ser</span> <span class="pre">un</span> <span class="pre">problema,</span> <span class="pre">pueden</span> <span class="pre">considerarse</span> <span class="pre">más</span> <span class="pre">bien</span> <span class="pre">una</span> <span class="pre">molestia</span> <span class="pre">menor</span></code>.</p></li>
<li><p>Aunque este es un ejemplo especialmente drástico, <code class="docutils literal notranslate"><span class="pre">las</span> <span class="pre">consecuencias</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">positivos</span> <span class="pre">y</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">negativos</span> <span class="pre">no</span> <span class="pre">suelen</span> <span class="pre">ser</span> <span class="pre">las</span> <span class="pre">mismas</span></code>. En las <code class="docutils literal notranslate"><span class="pre">aplicaciones</span> <span class="pre">comerciales,</span> <span class="pre">podría</span> <span class="pre">ser</span> <span class="pre">posible</span> <span class="pre">asignar</span> <span class="pre">valores</span> <span class="pre">en</span> <span class="pre">dólares</span> <span class="pre">a</span> <span class="pre">ambos</span> <span class="pre">tipos</span> <span class="pre">de</span> <span class="pre">errores,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">permitiría</span> <span class="pre">medir</span> <span class="pre">el</span> <span class="pre">error</span> <span class="pre">de</span> <span class="pre">una</span> <span class="pre">predicción</span> <span class="pre">concreta</span> <span class="pre">en</span> <span class="pre">dólares,</span> <span class="pre">en</span> <span class="pre">lugar</span> <span class="pre">de</span> <span class="pre">en</span> <span class="pre">precisión</span></code>. Esto podría ser mucho más significativo para tomar decisiones comerciales sobre qué modelo utilizar.</p></li>
</ul>
</section>
<section id="conjuntos-de-datos-desequilibrados">
<h3>Conjuntos de datos desequilibrados<a class="headerlink" href="#conjuntos-de-datos-desequilibrados" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Los tipos de errores desempeñan un papel importante cuando una de las dos clases es mucho más frecuente que la otra. Esto es muy común en la práctica; un buen ejemplo es la predicción de <code class="docutils literal notranslate"><span class="pre">clicks</span></code>, en la que cada punto de datos representa una “impresión”, es decir, un elemento que se ha mostrado a un usuario. Este elemento puede ser un anuncio, una historia relacionada o una persona relacionada a la que seguir en las redes sociales. El objetivo es, si se muestra un elemento concreto, predecir si un usuario hará click en él (indicando que está interesado). La mayoría de las cosas que se muestran a los usuarios en Internet (en particular, los anuncios) no darán lugar a un click. Es posible que tenga que mostrar a un usuario 100 anuncios o artículos antes de que encuentre algo lo suficientemente interesante como para hacer click.</p></li>
<li><p>Esto da lugar a un conjunto de datos en el que, por cada 99 puntos de datos “no click”, hay 1 punto de datos “con click”. <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">otras</span> <span class="pre">palabras,</span> <span class="pre">el</span> <span class="pre">99%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">pertenecen</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">&quot;no</span> <span class="pre">click&quot;</span></code>. <strong><code class="docutils literal notranslate"><span class="pre">Conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">que</span> <span class="pre">una</span> <span class="pre">clase</span> <span class="pre">es</span> <span class="pre">mucho</span> <span class="pre">más</span> <span class="pre">frecuente</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">otra</span> <span class="pre">se</span> <span class="pre">denominan</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">con</span> <span class="pre">clases</span> <span class="pre">desequilibradas</span></code></strong>. En realidad, los datos desequilibrados son la norma, y <code class="docutils literal notranslate"><span class="pre">es</span> <span class="pre">raro</span> <span class="pre">que</span> <span class="pre">los</span> <span class="pre">eventos</span> <span class="pre">de</span> <span class="pre">interés</span> <span class="pre">tengan</span> <span class="pre">una</span> <span class="pre">frecuencia</span> <span class="pre">igual</span> <span class="pre">o</span> <span class="pre">incluso</span> <span class="pre">similar</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">datos</span></code>. Supongamos que construimos un clasificador que tiene una precisión del 99% en la tarea de predicción de clicks. ¿Qué nos dice esto? <code class="docutils literal notranslate"><span class="pre">Un</span> <span class="pre">99%</span> <span class="pre">de</span> <span class="pre">precisión</span> <span class="pre">suena</span> <span class="pre">impresionante,</span> <span class="pre">pero</span> <span class="pre">este</span> <span class="pre">no</span> <span class="pre">toma</span> <span class="pre">en</span> <span class="pre">cuenta</span> <span class="pre">el</span> <span class="pre">desequilibrio</span> <span class="pre">de</span> <span class="pre">clases</span></code>.</p></li>
<li><p>Se puede conseguir un 99% de precisión sin construir un modelo de aprendizaje automático, prediciendo siempre “no click”. Por otro lado, incluso con datos desequilibrados, un modelo con un 99% de precisión podría ser bastante bueno. Sin embargo, <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">no</span> <span class="pre">nos</span> <span class="pre">permite</span> <span class="pre">distinguir</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">constante</span> <span class="pre">&quot;no</span> <span class="pre">click&quot;</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">potencialmente</span> <span class="pre">bueno</span></code>. Para ilustrarlo, crearemos un conjunto de datos desequilibrados 9:1 a partir del conjunto de datos <code class="docutils literal notranslate"><span class="pre">digits</span></code>, clasificando el dígito 9 contra las otras nueve clases.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_digits</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digits</span> <span class="o">=</span> <span class="n">load_digits</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data shape: &quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;; Target shape&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data shape:  (1797, 64) ; Target shape (1797,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,
       13., 14., 15., 16.])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span> <span class="c1"># Boolean</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Podemos utilizar <code class="docutils literal notranslate"><span class="pre">DummyClassifier</span></code> para predecir siempre la clase mayoritaria (aquí “not nine”) <code class="docutils literal notranslate"><span class="pre">para</span> <span class="pre">ver</span> <span class="pre">lo</span> <span class="pre">poco</span> <span class="pre">informativa</span> <span class="pre">que</span> <span class="pre">puede</span> <span class="pre">ser</span> <span class="pre">el</span> <span class="pre">(accuracy)</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dummy_majority</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;most_frequent&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_most_frequent</span> <span class="o">=</span> <span class="n">dummy_majority</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique predicted labels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pred_most_frequent</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dummy_majority</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unique predicted labels: [False]
Test score: 0.90
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Obtuvimos una precisión cercana al 90% sin aprender nada. Esto puede parecer sorprendente, pero pero piénselo un momento. <code class="docutils literal notranslate"><span class="pre">Imagine</span> <span class="pre">que</span> <span class="pre">alguien</span> <span class="pre">le</span> <span class="pre">dice</span> <span class="pre">que</span> <span class="pre">su</span> <span class="pre">modelo</span> <span class="pre">tiene</span> <span class="pre">un</span> <span class="pre">90%</span> <span class="pre">de</span> <span class="pre">precisión.</span> <span class="pre">Podrías</span> <span class="pre">pensar</span> <span class="pre">que</span> <span class="pre">han</span> <span class="pre">hecho</span> <span class="pre">un</span> <span class="pre">buen</span> <span class="pre">trabajo.</span> <span class="pre">Pero</span> <span class="pre">dependiendo</span> <span class="pre">del</span> <span class="pre">problema,</span> <span class="pre">¡eso</span> <span class="pre">podría</span> <span class="pre">ser</span> <span class="pre">posible</span> <span class="pre">con</span> <span class="pre">sólo</span> <span class="pre">predecir</span> <span class="pre">una</span> <span class="pre">clase!</span> <span class="pre">Comparemos</span> <span class="pre">esto</span> <span class="pre">con</span> <span class="pre">el</span> <span class="pre">uso</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">clasificador</span> <span class="pre">real</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test score: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Según la precisión, el <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier</span> <span class="pre">es</span> <span class="pre">sólo</span> <span class="pre">ligeramente</span> <span class="pre">mejor</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">predictor</span> <span class="pre">constante.</span> <span class="pre">Esto</span> <span class="pre">podría</span> <span class="pre">indicar</span> <span class="pre">que</span> <span class="pre">algo</span> <span class="pre">está</span> <span class="pre">mal</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">forma</span> <span class="pre">en</span> <span class="pre">que</span> <span class="pre">utilizamos</span> <span class="pre">DecisionTreeClassifier,</span> <span class="pre">o</span> <span class="pre">bien</span> <span class="pre">que</span> <span class="pre">accuracy</span> <span class="pre">no</span> <span class="pre">es</span> <span class="pre">una</span> <span class="pre">buena</span> <span class="pre">medida</span> <span class="pre">en</span> <span class="pre">este</span> <span class="pre">caso</span></code>. Para comparar, evaluemos otro clasificador, <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_logreg</span> <span class="o">=</span> <span class="n">logreg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;logreg score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>logreg score: 0.98
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El clasificador <code class="docutils literal notranslate"><span class="pre">dummy</span></code> que produce resultados aleatorios es claramente el peor de todos (según su <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>), mientras que <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> produce muy buenos resultados. Esto hace que sea muy difícil juzgar cuál de estos resultados es realmente útil. El problema es que accuracy es una medida inadecuada para cuantificar el rendimiento predictivo en este entorno desequilibrado. <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">el</span> <span class="pre">resto</span> <span class="pre">de</span> <span class="pre">este</span> <span class="pre">capítulo,</span> <span class="pre">exploraremos</span> <span class="pre">métricas</span> <span class="pre">alternativas</span> <span class="pre">que</span> <span class="pre">proporcionen</span> <span class="pre">una</span> <span class="pre">mejor</span> <span class="pre">orientación</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">de</span> <span class="pre">modelos</span></code>. En particular, nos gustaría disponer de métricas que nos digan cuán mejor es un modelo, en vez de hacer predicciones “más frecuentes” o predicciones aleatorias, como se calculan en <code class="docutils literal notranslate"><span class="pre">pred_most_frequent</span></code>. <code class="docutils literal notranslate"><span class="pre">Si</span> <span class="pre">utilizamos</span> <span class="pre">una</span> <span class="pre">métrica</span> <span class="pre">adecuada</span> <span class="pre">para</span> <span class="pre">evaluar</span> <span class="pre">nuestros</span> <span class="pre">modelos,</span> <span class="pre">debería</span> <span class="pre">ser</span> <span class="pre">capaz</span> <span class="pre">de</span> <span class="pre">eliminar</span> <span class="pre">estas</span> <span class="pre">predicciones</span> <span class="pre">sin</span> <span class="pre">sentido</span></code>.</p></li>
</ul>
</section>
<section id="matrices-de-confusion">
<h3>Matrices de confusión<a class="headerlink" href="#matrices-de-confusion" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Una de las formas más completas de representar el resultado de la evaluación de la clasificación binaria es el uso de <code class="docutils literal notranslate"><span class="pre">matrices</span> <span class="pre">de</span> <span class="pre">confusión</span></code>. Inspeccionemos las predicciones de <code class="docutils literal notranslate"><span class="pre">LogisticRegres</span></code> de la sección anterior utilizando la función <code class="docutils literal notranslate"><span class="pre">confusion_matrix</span></code>. Ya hemos almacenado las predicciones del conjunto de prueba en <code class="docutils literal notranslate"><span class="pre">pred_logreg</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">confusion</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Confusion matrix:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">confusion</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Confusion matrix:
[[402   1]
 [  6  41]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La salida de <code class="docutils literal notranslate"><span class="pre">confusion_matrix</span></code> es una <code class="docutils literal notranslate"><span class="pre">matriz</span> <span class="pre">de</span> <span class="pre">dos</span> <span class="pre">por</span> <span class="pre">dos,</span> <span class="pre">donde</span> <span class="pre">las</span> <span class="pre">filas</span> <span class="pre">corresponden</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">clases</span> <span class="pre">verdaderas</span> <span class="pre">y</span> <span class="pre">las</span> <span class="pre">columnas</span> <span class="pre">corresponden</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">clases</span> <span class="pre">predichas</span></code>. Cada entrada cuenta la frecuencia con la que una muestra que pertenece a la clase correspondiente a la fila (aquí “not nine” y “nine”) fue clasificada como la clase correspondiente a la columna.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_confusion_matrix_illustration</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d947ff930450462101c587a9d26fc803e19f8774dcd6fe49fb355acdfd2dc296.png" src="_images/d947ff930450462101c587a9d26fc803e19f8774dcd6fe49fb355acdfd2dc296.png" />
</div>
</div>
<ul class="simple">
<li><p>Las entradas de la <code class="docutils literal notranslate"><span class="pre">diagonal</span> <span class="pre">principal</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">matriz</span> <span class="pre">de</span> <span class="pre">confusión</span> <span class="pre">corresponden</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">clasificaciones</span> <span class="pre">correctas,</span> <span class="pre">mientras</span> <span class="pre">que</span> <span class="pre">las</span> <span class="pre">demás</span> <span class="pre">entradas</span> <span class="pre">nos</span> <span class="pre">indican</span> <span class="pre">cuántas</span> <span class="pre">muestras</span> <span class="pre">se</span> <span class="pre">han</span> <span class="pre">clasificado</span> <span class="pre">erróneamente</span> <span class="pre">en</span> <span class="pre">una</span> <span class="pre">clase</span></code>. Si declaramos que “nine” es la clase positiva, podemos relacionar las entradas de la matriz de confusión con los términos <code class="docutils literal notranslate"><span class="pre">falso</span> <span class="pre">positivo</span> <span class="pre">y</span> <span class="pre">falso</span> <span class="pre">negativo</span></code> que hemos introducido anteriormente. Para completar el cuadro, llamamos <code class="docutils literal notranslate"><span class="pre">verdaderos</span> <span class="pre">positivos</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">correctamente</span> <span class="pre">clasificadas</span> <span class="pre">que</span> <span class="pre">pertenecen</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">positiva</span> <span class="pre">y</span> <span class="pre">verdaderos</span> <span class="pre">negativos</span> <span class="pre">a</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">correctamente</span> <span class="pre">clasificadas</span> <span class="pre">que</span> <span class="pre">pertenecen</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">negativa.</span> <span class="pre">Estos</span> <span class="pre">términos</span> <span class="pre">suelen</span> <span class="pre">abreviarse</span> <span class="pre">como</span></code> <strong>FP, FN, TP y TN</strong>, y conducen a la siguiente interpretación de la matriz de confusión</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_binary_confusion_matrix</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9d8734ae1a11f137c1779678fe7a6963260e9641e3bc97fa46b8b0de7ae9701e.png" src="_images/9d8734ae1a11f137c1779678fe7a6963260e9641e3bc97fa46b8b0de7ae9701e.png" />
</div>
</div>
<ul class="simple">
<li><p>Ahora utilicemos la <code class="docutils literal notranslate"><span class="pre">matriz</span> <span class="pre">de</span> <span class="pre">confusión</span></code> para comparar los modelos que hemos ajustado antes (los dos modelos <code class="docutils literal notranslate"><span class="pre">dummy,</span> <span class="pre">árbol</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">y</span> <span class="pre">regresión</span> <span class="pre">logística</span></code>)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Dummy model:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dummy model:
[[403   0]
 [ 47   0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Decision tree:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Decision tree:
[[390  13]
 [ 24  23]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Logistic Regression&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Logistic Regression
[[402   1]
 [  6  41]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Si se observa la matriz de confusión, está claro que algo va mal con <code class="docutils literal notranslate"><span class="pre">pred_most_frequent</span></code> porque siempre predice la misma clase, tiene cero verdaderos y falsos positivos (0). <code class="docutils literal notranslate"><span class="pre">Las</span> <span class="pre">predicciones</span> <span class="pre">realizadas</span> <span class="pre">por</span> <span class="pre">el</span> <span class="pre">árbol</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">tienen</span> <span class="pre">mucho</span> <span class="pre">más</span> <span class="pre">sentido</span> <span class="pre">que</span> <span class="pre">las</span> <span class="pre">predicciones</span> <span class="pre">dummy,</span> <span class="pre">aunque</span> <span class="pre">el</span> <span class="pre">accuracy</span> <span class="pre">era</span> <span class="pre">casi</span> <span class="pre">el</span> <span class="pre">misma</span></code>. Por último, podemos ver que la regresión logística es mejor que <code class="docutils literal notranslate"><span class="pre">pred_tree</span></code> en todos los aspectos: tiene más verdaderos positivos y verdaderos negativos, mientras que tiene menos falsos positivos y falsos negativos. <code class="docutils literal notranslate"><span class="pre">De</span> <span class="pre">esta</span> <span class="pre">comparación</span> <span class="pre">se</span> <span class="pre">desprende</span> <span class="pre">que,</span> <span class="pre">sólo</span> <span class="pre">el</span> <span class="pre">árbol</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">regresión</span> <span class="pre">logística</span> <span class="pre">dan</span> <span class="pre">resultados</span> <span class="pre">razonables,</span> <span class="pre">y</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">regresión</span> <span class="pre">logística</span> <span class="pre">funciona</span> <span class="pre">mejor</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">árbol</span> <span class="pre">en</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">aspectos</span></code>. Sin embargo, la inspección de la matriz de confusión completa es un poco acumulativa, y aunque obtuvimos mucha información al observar todos los aspectos de la matriz, <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">proceso</span> <span class="pre">fue</span> <span class="pre">muy</span> <span class="pre">manual</span> <span class="pre">y</span> <span class="pre">cualitativo</span></code>. Hay varias formas de resumir la información de la matriz de confusión, las cuales discutiremos a continuación.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Accuracy</p>
<p>Ya vimos una forma de resumir el resultado en la <code class="docutils literal notranslate"><span class="pre">matriz</span> <span class="pre">de</span> <span class="pre">confusión</span></code>, calculando su <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, que puede expresarse como</p>
<div class="math notranslate nohighlight">
\[
\text{Accuracy}=\frac{TP+TN}{TP+TN+FP+FN}.
\]</div>
<p>En otras palabras, el <code class="docutils literal notranslate"><span class="pre">accuracy</span> <span class="pre">es</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">predicciones</span> <span class="pre">correctas</span> <span class="pre">(TP</span> <span class="pre">y</span> <span class="pre">TN)</span> <span class="pre">dividido</span> <span class="pre">por</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">muestras</span></code> (todas las entradas de la matriz de confusión sumadas).</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Precision,</span> <span class="pre">recall</span> <span class="pre">y</span> <span class="pre">f-score</span></code>. Hay otras formas de resumir la matriz de confusión, siendo las más comunes: <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span> <span class="pre">y</span> <span class="pre">f-score</span></code>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Precision</p>
<p><code class="docutils literal notranslate"><span class="pre">Precision</span></code> mide cuántas de las muestras predichas como positivas son realmente positivas, es decir, <code class="docutils literal notranslate"><span class="pre">precision</span></code> intenta responder a la siguiente pregunta: ¿qué proporción de identificaciones positivas fue correcta?</p>
<div class="math notranslate nohighlight">
\[
\text{Precision} = \frac{TP}{TP+FP} 
\]</div>
<p><code class="docutils literal notranslate"><span class="pre">Precision</span></code> se utiliza como métrica de rendimiento cuando <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">objetivo</span> <span class="pre">es</span> <span class="pre">limitar</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">falsos</span> <span class="pre">positivos</span></code>.</p>
</div>
<ul class="simple">
<li><p>Como ejemplo, imaginemos un modelo para predecir si un nuevo medicamento será eficaz en el tratamiento de una enfermedad en los ensayos clínicos. <code class="docutils literal notranslate"><span class="pre">Los</span> <span class="pre">ensayos</span> <span class="pre">clínicos</span> <span class="pre">son</span> <span class="pre">notoriamente</span> <span class="pre">caros,</span> <span class="pre">y</span> <span class="pre">una</span> <span class="pre">empresa</span> <span class="pre">farmacéutica</span> <span class="pre">sólo</span> <span class="pre">querrá</span> <span class="pre">realizar</span> <span class="pre">un</span> <span class="pre">experimento</span> <span class="pre">si</span> <span class="pre">está</span> <span class="pre">muy</span> <span class="pre">seguro</span> <span class="pre">de</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">fármaco</span> <span class="pre">funcionará</span> <span class="pre">realmente.</span> <span class="pre">Por</span> <span class="pre">lo</span> <span class="pre">tanto,</span> <span class="pre">es</span> <span class="pre">importante</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">no</span> <span class="pre">produzca</span> <span class="pre">muchos</span> <span class="pre">falsos</span> <span class="pre">positivos</span></code>, es decir, que tenga <code class="docutils literal notranslate"><span class="pre">precision</span></code> alto. <code class="docutils literal notranslate"><span class="pre">Precision</span></code> <code class="docutils literal notranslate"><span class="pre">también</span> <span class="pre">se</span> <span class="pre">conoce</span> <span class="pre">como</span> <span class="pre">valor</span> <span class="pre">predictivo</span> <span class="pre">positivo</span> <span class="pre">(VPP)</span></code>. Nótese que: <span class="math notranslate nohighlight">\(FP\rightarrow0\)</span> cuando <span class="math notranslate nohighlight">\(\text{Precision}\rightarrow1\)</span> y viceversa; similarmente, <span class="math notranslate nohighlight">\(FN\rightarrow0\)</span> cuando <span class="math notranslate nohighlight">\(\text{Recall}\rightarrow1\)</span> y viceversa.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Recall</p>
<p>El <code class="docutils literal notranslate"><span class="pre">recall</span></code> mide cuántas de las muestras de la clase positiva son realmente predichas positivas, es decir, <code class="docutils literal notranslate"><span class="pre">recall</span></code> intenta responder a la siguiente pregunta: ¿qué proporción de positivos reales se identificó en forma correcta?</p>
<div class="math notranslate nohighlight">
\[
\text{Recall} = \frac{TP}{TP+FN} 
\]</div>
<p><code class="docutils literal notranslate"><span class="pre">Recall</span></code> se utiliza como métrica de rendimiento cuando <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">objetivo</span> <span class="pre">es</span> <span class="pre">limitar</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">falsos</span> <span class="pre">negativos</span></code>.</p>
</div>
<ul class="simple">
<li><p>Existe un equilibrio entre la optimización del <code class="docutils literal notranslate"><span class="pre">recall</span></code> y el <code class="docutils literal notranslate"><span class="pre">precision</span></code>. Se puede obtener de forma sencilla, una recuperación perfecta si se predice que todas las muestras pertenecen a la clase positiva. Si se predice que todas las muestras pertenecen a la clase positiva, no habrá falsos negativos ni verdaderos negativos. Sin embargo, predecir todas las muestras como positivas, dará lugar a muchos falsos positivos y, por lo tanto, su <code class="docutils literal notranslate"><span class="pre">precision</span></code> será muy baja. Por otro lado, si se encuentra un modelo que predice sólo el punto de datos del que se está más seguro como positivo y el resto como negativo, entonces <code class="docutils literal notranslate"><span class="pre">precision</span></code> será perfecto (suponiendo que este punto de datos sea de hecho positivo), pero el <code class="docutils literal notranslate"><span class="pre">recall</span></code> será muy malo.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p><code class="docutils literal notranslate"><span class="pre">Precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> son sólo dos de las muchas medidas de clasificación derivadas de <code class="docutils literal notranslate"><span class="pre">TP,</span> <span class="pre">FP,</span> <span class="pre">TN</span> <span class="pre">y</span> <span class="pre">FN</span></code>. Puede encontrar un gran resumen de todas las medidas en <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">Sensitivity_and_specificity</a>. En la comunidad del aprendizaje automático, <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> son las medidas más utilizadas para la clasificación binaria, aunque pueden utilizar otras métricas relacionadas.</p>
</div>
<div class="tip admonition">
<p class="admonition-title"><span class="math notranslate nohighlight">\(f_{1}\)</span>-score</p>
<p>Por lo tanto, aunque <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> sean medidas muy importantes, si sólo se tiene en cuenta una de ellas no se obtiene una visión completa. Una forma de resumirlas es usando el <code class="docutils literal notranslate"><span class="pre">f-score</span> <span class="pre">o</span> <span class="pre">f-measure</span></code>, que es la <code class="docutils literal notranslate"><span class="pre">media</span> <span class="pre">armónica</span> <span class="pre">entre</span> <span class="pre">precision</span> <span class="pre">y</span> <span class="pre">recall</span></code>:</p>
<div class="math notranslate nohighlight">
\[
F=2\cdot\frac{\text{precision}\cdot\text{recall}}{\text{precision}+\text{recall}}.
\]</div>
<p>Esta variante concreta también se conoce como <span class="math notranslate nohighlight">\(f_{1}\)</span>-score.</p>
</div>
<ul class="simple">
<li><p>Como tiene en cuenta a <code class="docutils literal notranslate"><span class="pre">precision</span></code> (precisión) y <code class="docutils literal notranslate"><span class="pre">recall</span></code> (recuperación) el <span class="math notranslate nohighlight">\(f_{1}\)</span>-score puede ser una medida mejor que <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> (exactitud) en conjuntos de datos de clasificación binaria desequilibrados. Vamos a aplicarlo a las predicciones del conjunto de datos “nine vs. rest” que hemos calculado antes. En este caso, supondremos que la clase “nine” es la clase positiva (está etiquetada como <code class="docutils literal notranslate"><span class="pre">True</span></code> mientras que el resto está etiquetado como <code class="docutils literal notranslate"><span class="pre">False</span></code>), por lo que la clase positiva es la clase minoritaria.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">f1_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score dummy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score dummy: 0.00
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score tree: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score tree: 0.55
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score logistic regression: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score logistic regression: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Podemos ver una distinción bastante fuerte entre las predicciones dummy y las predicciones del árbol, lo que no estaba claro cuando se miraba <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> por sí sola. Utilizando <span class="math notranslate nohighlight">\(f\)</span>-score para la evaluación, resumimos el rendimiento predictivo de nuevo en un número. <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span></code> <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span> <span class="pre">parece</span> <span class="pre">captar</span> <span class="pre">nuestra</span> <span class="pre">intuición</span> <span class="pre">de</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">es</span> <span class="pre">un</span> <span class="pre">buen</span> <span class="pre">modelo</span> <span class="pre">mucho</span> <span class="pre">mejor</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">accuracy</span></code>.</p></li>
<li><p>Sin embargo, una desventaja del <span class="math notranslate nohighlight">\(f\)</span>-score es que es más difícil de interpretar y explicar que accuracy. Si queremos un resumen más completo de <code class="docutils literal notranslate"><span class="pre">precision</span></code>, <code class="docutils literal notranslate"><span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f_{1}\)</span>-score, podemos utilizar la función de conveniencia <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> para calcular los tres a la vez e imprimirlos en un formato agradable. Las dos últimas filas corresponden a <code class="docutils literal notranslate"><span class="pre">macro</span> <span class="pre">avg</span></code> que da a cada predicción un peso similar al calcular la pérdida, pero para datos desequilibrados como lo es este caso, se quiera dar más importancia a alguna predicción en función de su proporción, en ese caso se utiliza la <code class="docutils literal notranslate"><span class="pre">weighted</span> <span class="pre">avg</span></code>. Para mas información acerca del uso de <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html">sklearn.metrics.classification_report</a>).</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.90      1.00      0.94       403
        nine       0.00      0.00      0.00        47

    accuracy                           0.90       450
   macro avg       0.45      0.50      0.47       450
weighted avg       0.80      0.90      0.85       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> produce una línea por clase (aquí, <code class="docutils literal notranslate"><span class="pre">True</span></code> y <code class="docutils literal notranslate"><span class="pre">False</span></code>) e informa <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code>. Si consideramos la clase positiva por “not nine”, podemos ver en la salida de <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> que obtenemos un <span class="math notranslate nohighlight">\(f\)</span>-score de 0.94 con el modelo <code class="docutils literal notranslate"><span class="pre">dummy</span></code>. Además, para la clase “not nine” tenemos un <code class="docutils literal notranslate"><span class="pre">recall</span></code> de 1, ya que clasificamos todas las muestras como “not nine”.</p></li>
<li><p>La última columna junto al <span class="math notranslate nohighlight">\(f\)</span>-score proporciona el soporte de cada clase, lo que significa simplemente el número de muestras en esta clase según la verdad básica. La última fila del informe de clasificación muestra una media ponderada (por el número de muestras en la clase) de los números de cada clase. Aquí hay dos informes más, uno para el clasificador <code class="docutils literal notranslate"><span class="pre">arbol</span> <span class="pre">de</span> <span class="pre">decisión</span></code> y otro para la <code class="docutils literal notranslate"><span class="pre">regresión</span> <span class="pre">logística</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.94      0.97      0.95       403
        nine       0.64      0.49      0.55        47

    accuracy                           0.92       450
   macro avg       0.79      0.73      0.75       450
weighted avg       0.91      0.92      0.91       450
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.99      1.00      0.99       403
        nine       0.98      0.87      0.92        47

    accuracy                           0.98       450
   macro avg       0.98      0.93      0.96       450
weighted avg       0.98      0.98      0.98       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como puede observar al mirar los informes, las diferencias entre los modelos <code class="docutils literal notranslate"><span class="pre">dummy</span></code> y un modelo muy bueno ya no son tan claras. La elección de la clase que se declarada como clase positiva, tiene un gran impacto en las métricas. Mientras que el <span class="math notranslate nohighlight">\(f\)</span>-score de la clasificación <code class="docutils literal notranslate"><span class="pre">dummy</span></code> es de 0.13 (frente a 0.89 para la <code class="docutils literal notranslate"><span class="pre">regresión</span> <span class="pre">logística</span></code>) en la clase “nine” es de 0.90 frente a 0.99, lo que parece un resultado razonable. Sin embargo, si se observan todas las cifras juntas, se obtiene una imagen bastante precisa, y podemos ver claramente la superioridad de la regresión logística.</p></li>
</ul>
</section>
<section id="teniendo-en-cuenta-la-incertidumbre">
<h3>Teniendo en cuenta la incertidumbre<a class="headerlink" href="#teniendo-en-cuenta-la-incertidumbre" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>La matriz de confusión y el informe de clasificación proporcionan un análisis muy detallado de un conjunto concreto de predicciones. Sin embargo, las propias predicciones ya arrojan mucha información que está contenida en el modelo. Como ya comentamos, la mayoría de los clasificadores proporcionan un método <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> para <code class="docutils literal notranslate"><span class="pre">evaluar</span> <span class="pre">el</span> <span class="pre">grado</span> <span class="pre">de</span> <span class="pre">certeza</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">predicciones</span></code>. Hacer predicciones puede verse como un umbral para <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> en un punto fijo determinado. En la clasificación binaria utilizamos 0 para <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> y 0.5 para <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>.</p></li>
<li><p>El siguiente es un ejemplo de una tarea de <code class="docutils literal notranslate"><span class="pre">clasificación</span> <span class="pre">binaria</span> <span class="pre">desequilibrada,</span> <span class="pre">con</span> <span class="pre">400</span> <span class="pre">puntos</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">negativa</span> <span class="pre">clasificados</span> <span class="pre">contra</span> <span class="pre">50</span> <span class="pre">puntos</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">positiva</span></code>. Los datos de entrenamiento se muestran a la izquierda en la siguiente figura. Entrenamos un modelo <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">SVM</span></code> en estos datos, y los gráficos a la derecha de los datos de entrenamiento ilustran los valores de la función de decisión como un mapa de calor. <code class="docutils literal notranslate"><span class="pre">Puede</span> <span class="pre">ver</span> <span class="pre">un</span> <span class="pre">círculo</span> <span class="pre">negro</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">gráfico</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">parte</span> <span class="pre">superior</span> <span class="pre">central,</span> <span class="pre">que</span> <span class="pre">denota</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">donde</span> <span class="pre">la</span> <span class="pre">función</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">es</span> <span class="pre">exactamente</span> <span class="pre">cero</span></code>. Los puntos dentro de este se clasificarán como la clase positiva, y los puntos fuera de ella como la clase negativa</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mglearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">.05</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_decision_threshold</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1523d2ed512a7331891d64f4334304f50dd8e7b5dd05ed303ff4f5b6f4c967b4.png" src="_images/1523d2ed512a7331891d64f4334304f50dd8e7b5dd05ed303ff4f5b6f4c967b4.png" />
</div>
</div>
<ul class="simple">
<li><p>Podemos utilizar la función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> para evaluar <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> de ambas clases</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       0.49      1.00      0.66        49
           1       0.00      0.00      0.00        51

    accuracy                           0.49       100
   macro avg       0.24      0.50      0.33       100
weighted avg       0.24      0.49      0.32       100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[49  0]
 [51  0]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Para la <code class="docutils literal notranslate"><span class="pre">clase</span> <span class="pre">1</span></code>, obtenemos un <code class="docutils literal notranslate"><span class="pre">recall</span></code> bastante pequeño, y un <code class="docutils literal notranslate"><span class="pre">precision</span></code> mixto. Como la clase 0 es mucho más grande, el clasificador se centra en acertar la clase 0 y no la clase 1, más pequeña. Supongamos que, en nuestra aplicación, es más importante tener un alto <code class="docutils literal notranslate"><span class="pre">recall</span></code> para la clase 1, como en el ejemplo del cáncer. <code class="docutils literal notranslate"><span class="pre">Esto</span> <span class="pre">significa</span> <span class="pre">que</span> <span class="pre">estamos</span> <span class="pre">dispuestos</span> <span class="pre">a</span> <span class="pre">arriesgar</span> <span class="pre">más</span> <span class="pre">falsos</span> <span class="pre">positivos</span> <span class="pre">(clase</span> <span class="pre">1</span> <span class="pre">falsa)</span> <span class="pre">a</span> <span class="pre">cambio</span> <span class="pre">de</span> <span class="pre">más</span> <span class="pre">positivos</span> <span class="pre">verdaderos</span> <span class="pre">(que</span> <span class="pre">aumentarán</span> <span class="pre">el</span> <span class="pre">recall)</span></code>. Las predicciones generadas por <code class="docutils literal notranslate"><span class="pre">svc.predict</span></code> realmente no cumplen con este requisito, pero <code class="docutils literal notranslate"><span class="pre">podemos</span> <span class="pre">ajustar</span> <span class="pre">las</span> <span class="pre">predicciones</span> <span class="pre">para</span> <span class="pre">que</span> <span class="pre">se</span> <span class="pre">centren</span> <span class="pre">en</span> <span class="pre">un</span> <span class="pre">mayor</span> <span class="pre">recall</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">1,</span> <span class="pre">cambiando</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">0</span></code>. Por defecto, los puntos con un valor de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> mayor que 0 se clasificarán como clase 1. <code class="docutils literal notranslate"><span class="pre">Queremos</span> <span class="pre">que</span> <span class="pre">más</span> <span class="pre">puntos</span> <span class="pre">se</span> <span class="pre">clasifiquen</span> <span class="pre">como</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">1,</span> <span class="pre">así</span> <span class="pre">que</span> <span class="pre">tenemos</span> <span class="pre">que</span> <span class="pre">reducir</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">(threshold)</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_pred_lower_threshold</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.015</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Veamos el informe de clasificación de esta predicción</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_lower_threshold</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       0.00      0.00      0.00        49
           1       0.51      1.00      0.68        51

    accuracy                           0.51       100
   macro avg       0.26      0.50      0.34       100
weighted avg       0.26      0.51      0.34       100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_lower_threshold</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0 49]
 [ 0 51]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como se esperaba, <code class="docutils literal notranslate"><span class="pre">recall</span> <span class="pre">y</span> <span class="pre">precision</span></code> para la clase 1 subió. Ahora estamos clasificando una <code class="docutils literal notranslate"><span class="pre">región</span> <span class="pre">más</span> <span class="pre">grande</span> <span class="pre">del</span> <span class="pre">espacio</span> <span class="pre">como</span> <span class="pre">clase</span> <span class="pre">1</span></code>, como se ilustra en el panel superior derecho de la anterior figura. <code class="docutils literal notranslate"><span class="pre">Si</span> <span class="pre">valora</span> <span class="pre">más</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">recuperación,</span> <span class="pre">o</span> <span class="pre">al</span> <span class="pre">revés,</span> <span class="pre">o</span> <span class="pre">sus</span> <span class="pre">datos</span> <span class="pre">están</span> <span class="pre">muy</span> <span class="pre">desequilibrados,</span> <span class="pre">cambiar</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">de</span> <span class="pre">decisión</span> <span class="pre">es</span> <span class="pre">la</span> <span class="pre">forma</span> <span class="pre">más</span> <span class="pre">fácil</span> <span class="pre">de</span> <span class="pre">obtener</span> <span class="pre">mejores</span> <span class="pre">resultados</span></code>. <em>Como la función de decisión puede tener rangos arbitrarios, es difícil proporcionar una regla general sobre cómo elegir un umbral</em>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Si</span> <span class="pre">establece</span> <span class="pre">un</span> <span class="pre">umbral,</span> <span class="pre">debe</span> <span class="pre">tener</span> <span class="pre">cuidado</span> <span class="pre">de</span> <span class="pre">no</span> <span class="pre">hacerlo</span> <span class="pre">utilizando</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span></code>. Como con cualquier otro parámetro, establecer un umbral de decisión en el conjunto de prueba es probable que produzca resultados demasiado optimistas. <code class="docutils literal notranslate"><span class="pre">Utilice</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">o</span> <span class="pre">aplique</span> <span class="pre">validación</span> <span class="pre">cruzada</span></code>.</p></li>
<li><p>La <code class="docutils literal notranslate"><span class="pre">media</span> <span class="pre">geométrica</span> <span class="pre">o</span> <span class="pre">G-mean</span></code> es una métrica de clasificación desequilibrada que, si se optimiza, <code class="docutils literal notranslate"><span class="pre">buscará</span> <span class="pre">un</span> <span class="pre">equilibrio</span> <span class="pre">entre</span> <span class="pre">la</span> <span class="pre">precision</span> <span class="pre">y</span> <span class="pre">recall</span></code>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\text{G-mean}=\sqrt{\text{precision}\times\text{recall}}.
\]</div>
<ul class="simple">
<li><p>Un enfoque consistiría en <code class="docutils literal notranslate"><span class="pre">probar</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">con</span> <span class="pre">cada</span> <span class="pre">umbral</span></code> devuelto por la llamada <code class="docutils literal notranslate"><span class="pre">precision_recall_curve()</span></code> y <code class="docutils literal notranslate"><span class="pre">seleccionar</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">con</span> <span class="pre">el</span> <span class="pre">mayor</span> <span class="pre">valor</span> <span class="pre">G-mean</span></code>. Otras técnicas de oversampling, tales como <code class="docutils literal notranslate"><span class="pre">SMOTE</span></code> también pueden ser adecuadas, para datos de entrenamiento desbalanceados.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>La elección de un umbral para los modelos que aplican el método <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> puede ser más fácil, ya que la salida de <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> está en una escala fija de 0 a 1. <code class="docutils literal notranslate"><span class="pre">Por</span> <span class="pre">defecto,</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">de</span> <span class="pre">0.5</span> <span class="pre">significa</span> <span class="pre">que</span> <span class="pre">si</span> <span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">está</span> <span class="pre">más</span> <span class="pre">del</span> <span class="pre">50%</span> <span class="pre">&quot;seguro&quot;</span> <span class="pre">de</span> <span class="pre">que</span> <span class="pre">un</span> <span class="pre">punto</span> <span class="pre">es</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">positiva,</span> <span class="pre">se</span> <span class="pre">clasificará</span> <span class="pre">como</span> <span class="pre">tal</span></code>. Aumentar el umbral significa que el modelo debe estar más seguro para tomar una decisión positiva (y menos para tomar una decisión negativa).</p></li>
<li><p>Aunque trabajar con probabilidades puede ser más intuitivo que trabajar con umbrales arbitrarios, <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">modelos</span> <span class="pre">proporcionan</span> <span class="pre">modelos</span> <span class="pre">realistas</span> <span class="pre">de</span> <span class="pre">incertidumbre</span></code> (un <code class="docutils literal notranslate"><span class="pre">DecisionTree</span></code> que crece en toda su profundidad está siempre 100% seguro de sus decisiones, aunque a menudo se equivoque). Esto se relaciona con el concepto de calibración: <code class="docutils literal notranslate"><span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">calibrado</span> <span class="pre">es</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">que</span> <span class="pre">proporciona</span> <span class="pre">una</span> <span class="pre">medida</span> <span class="pre">de</span> <span class="pre">su</span> <span class="pre">incertidumbre</span></code>. Discutir la calibración en detalle está fuera del alcance de este curso, pero puede encontrar más detalles en el artículo <code class="docutils literal notranslate"><span class="pre">&quot;Predicting</span> <span class="pre">Good</span> <span class="pre">Probabilities</span> <span class="pre">with</span> <span class="pre">Supervised</span> <span class="pre">Learning&quot;</span> <span class="pre">de</span> <span class="pre">Alexandru</span> <span class="pre">Niculescu-Mizil</span> <span class="pre">y</span> <span class="pre">Rich</span> <span class="pre">Caruana</span></code>.</p></li>
</ul>
</section>
</section>
<section id="curvas-precision-recall-y-roc">
<h2>Curvas precision-recall y ROC<a class="headerlink" href="#curvas-precision-recall-y-roc" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Como acabamos de comentar, cambiar el umbral que se utiliza para tomar una decisión de clasificación en un modelo es una forma de ajustar el equilibrio entre <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> para una clase determinada. Tal vez quiera <code class="docutils literal notranslate"><span class="pre">fallar</span> <span class="pre">menos</span> <span class="pre">del</span> <span class="pre">10%</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">muestras</span> <span class="pre">positivas,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">significa</span> <span class="pre">un</span> <span class="pre">recall</span> <span class="pre">deseado</span> <span class="pre">del</span> <span class="pre">90%</span></code>. <code class="docutils literal notranslate"><span class="pre">Esta</span> <span class="pre">decisión</span> <span class="pre">depende</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">aplicación,</span> <span class="pre">y</span> <span class="pre">debe</span> <span class="pre">ser</span> <span class="pre">impulsada</span> <span class="pre">por</span> <span class="pre">objetivos</span> <span class="pre">empresariales</span></code>.</p></li>
<li><p>Una vez que se ha establecido un objetivo concreto por ejemplo, un valor de <code class="docutils literal notranslate"><span class="pre">recall</span></code> o de <code class="docutils literal notranslate"><span class="pre">precision</span></code> para una clase, se puede establecer un umbral adecuado. <code class="docutils literal notranslate"><span class="pre">Siempre</span> <span class="pre">es</span> <span class="pre">posible</span> <span class="pre">establecer</span> <span class="pre">un</span> <span class="pre">umbral</span> <span class="pre">para</span> <span class="pre">cumplir</span> <span class="pre">un</span> <span class="pre">objetivo</span> <span class="pre">concreto,</span> <span class="pre">como</span> <span class="pre">el</span> <span class="pre">90%</span> <span class="pre">de</span> <span class="pre">recall</span></code>. Lo difícil es desarrollar un modelo que siga teniendo una precisión razonable con este umbral: si clasifica todo como como positivo, tendrá un <code class="docutils literal notranslate"><span class="pre">recall</span></code> del 100%, pero su modelo será inútil. <code class="docutils literal notranslate"><span class="pre">Establecer</span> <span class="pre">un</span> <span class="pre">requisito</span> <span class="pre">para</span> <span class="pre">un</span> <span class="pre">clasificador,</span> <span class="pre">como</span> <span class="pre">el</span> <span class="pre">90%</span> <span class="pre">de</span> <span class="pre">recall,</span> <span class="pre">suele</span> <span class="pre">denominarse</span></code> <strong><code class="docutils literal notranslate"><span class="pre">establecer</span> <span class="pre">el</span> <span class="pre">punto</span> <span class="pre">operativo</span></code></strong>.</p></li>
<li><p>La fijación de un <code class="docutils literal notranslate"><span class="pre">punto</span> <span class="pre">operativo</span></code> suele ser útil en el ámbito empresarial para <code class="docutils literal notranslate"><span class="pre">ofrecer</span> <span class="pre">garantías</span> <span class="pre">de</span> <span class="pre">rendimiento</span> <span class="pre">a</span> <span class="pre">los</span> <span class="pre">clientes</span> <span class="pre">o</span> <span class="pre">a</span> <span class="pre">otros</span> <span class="pre">grupos</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">organización</span></code>. A menudo, cuando se desarrolla un nuevo modelo, no está del todo claro cuál será el <code class="docutils literal notranslate"><span class="pre">punto</span> <span class="pre">operativo</span></code>. Por esta razón, y para entender mejor un problema de modelamiento, es instructivo examinar todos los umbrales posibles, o todas las compensaciones posibles de <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Esto</span> <span class="pre">es</span> <span class="pre">posible</span> <span class="pre">gracias</span> <span class="pre">a</span> <span class="pre">una</span> <span class="pre">herramienta</span> <span class="pre">llamada</span> <span class="pre">curva</span> <span class="pre">precision-recall</span></code>. Puede encontrar la función para calcular la curva <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_curve.html">precision_recall_curve()</a> <code class="docutils literal notranslate"><span class="pre">en</span> <span class="pre">el</span> <span class="pre">módulo</span> <span class="pre">sklearn.metrics</span></code>. Esta necesita el etiquetado real y las incertidumbres predichas, creadas a través de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La función <code class="docutils literal notranslate"><span class="pre">precision_recall_curve</span></code> devuelve una <code class="docutils literal notranslate"><span class="pre">lista</span> <span class="pre">de</span> <span class="pre">valores</span> <span class="pre">precision</span> <span class="pre">y</span> <span class="pre">recall</span> <span class="pre">para</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">umbrales</span> <span class="pre">posibles</span></code> (todos los valores que aparecen en la función de decisión) en orden para que podamos trazar una curva, como se podrá observar en la figura que presentaremos a continuación. Puede utilizar más puntos de datos para obtener una curva más suave. Recuerde que <code class="docutils literal notranslate"><span class="pre">make_blobs</span></code> generar puntos gaussianos isotrópicos para la agrupación (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html">sklearn.datasets.make_blobs</a>).</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Para este ejemplo, usaremos el conjunto de datos de <code class="docutils literal notranslate"><span class="pre">cancer</span> <span class="pre">de</span> <span class="pre">mama</span></code>, importado por medio de <code class="docutils literal notranslate"><span class="pre">load_breast_cancer</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">.05</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Encontrar el <code class="docutils literal notranslate"><span class="pre">umbral</span> <span class="pre">más</span> <span class="pre">cercano</span> <span class="pre">a</span> <span class="pre">cero</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">close_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">recall</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;precision recall curve&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Precision&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Recall&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/5fbef75fa775f57142e1c7944dcaa5b238c0a2d6087c25c339b60aa5a7748b29.png" src="_images/5fbef75fa775f57142e1c7944dcaa5b238c0a2d6087c25c339b60aa5a7748b29.png" />
</div>
</div>
<ul class="simple">
<li><p>Cada punto de la curva corresponde a un posible umbral de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code>. Podemos ver, por ejemplo, que podemos conseguir un <code class="docutils literal notranslate"><span class="pre">recall</span> <span class="pre">aproximado</span> <span class="pre">de</span> <span class="pre">0.99</span></code> con un <code class="docutils literal notranslate"><span class="pre">precision</span> <span class="pre">de</span> <span class="pre">aproximadamente</span> <span class="pre">0.63</span></code>. <strong><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">círculo</span> <span class="pre">negro</span> <span class="pre">marca</span> <span class="pre">el</span> <span class="pre">punto</span> <span class="pre">que</span> <span class="pre">corresponde</span> <span class="pre">a</span> <span class="pre">un</span> <span class="pre">umbral</span> <span class="pre">de</span> <span class="pre">0,</span> <span class="pre">el</span> <span class="pre">umbral</span> <span class="pre">por</span> <span class="pre">defecto</span> <span class="pre">de</span> <span class="pre">decision_function</span></code></strong>. Este punto es la compensación que se elige al llamar al método <code class="docutils literal notranslate"><span class="pre">predict</span></code>. Cuanto más cerca esté la curva de la esquina superior derecha, mejor será el clasificador. <code class="docutils literal notranslate"><span class="pre">Un</span> <span class="pre">punto</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">parte</span> <span class="pre">superior</span> <span class="pre">derecha</span> <span class="pre">significa</span> <span class="pre">alto</span> <span class="pre">precision</span> <span class="pre">y</span> <span class="pre">alto</span> <span class="pre">recall</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">mismo</span> <span class="pre">umbral</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">curva</span> <span class="pre">comienza</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">esquina</span> <span class="pre">superior</span> <span class="pre">izquierda,</span> <span class="pre">que</span> <span class="pre">corresponde</span> <span class="pre">a</span> <span class="pre">un</span> <span class="pre">umbral</span> <span class="pre">muy</span> <span class="pre">bajo,</span> <span class="pre">clasificando</span> <span class="pre">todo</span> <span class="pre">como</span> <span class="pre">clase</span> <span class="pre">positiva</span></code>. Al aumentar el umbral, la curva se desplaza hacia un mayor <code class="docutils literal notranslate"><span class="pre">precision</span></code>, pero también hacia un menor <code class="docutils literal notranslate"><span class="pre">recall</span></code>. Aumentando el umbral cada vez más, llegamos a una situación donde los puntos clasificados como positivos son verdaderos positivos, lo que lleva a un <code class="docutils literal notranslate"><span class="pre">precision</span></code> muy alto pero a un <code class="docutils literal notranslate"><span class="pre">recall</span></code> más bajo. Cuanto más se mantenga el modelo en un nivel alto para <code class="docutils literal notranslate"><span class="pre">precision</span></code>, mejor.</p></li>
<li><p>Si observamos un poco más esta curva en particular, podemos ver que con este modelo es posible obtener un <code class="docutils literal notranslate"><span class="pre">precision</span></code> de hasta alrededor de 0.6 con un <code class="docutils literal notranslate"><span class="pre">recall</span></code> muy alto. Si queremos un <code class="docutils literal notranslate"><span class="pre">precision</span></code> mucho mayor, tenemos que sacrificar una gran cantidad de <code class="docutils literal notranslate"><span class="pre">recall</span></code>. <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">otras</span> <span class="pre">palabras,</span> <span class="pre">a</span> <span class="pre">la</span> <span class="pre">izquierda,</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">es</span> <span class="pre">relativamente</span> <span class="pre">plana,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">significa</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">recall</span> <span class="pre">no</span> <span class="pre">disminuye</span> <span class="pre">mucho</span> <span class="pre">cuando</span> <span class="pre">necesitamos</span> <span class="pre">mayor</span> <span class="pre">precision</span></code>. Para un precision superior a 0.5, cada ganancia de <code class="docutils literal notranslate"><span class="pre">precision</span></code> nos cuesta mucho <code class="docutils literal notranslate"><span class="pre">recall</span></code>.</p></li>
<li><p>Diferentes clasificadores pueden funcionar bien en diferentes partes de la curva, es decir, en <code class="docutils literal notranslate"><span class="pre">diferentes</span> <span class="pre">puntos</span> <span class="pre">de</span> <span class="pre">operación</span></code>. Comparemos el modelo <code class="docutils literal notranslate"><span class="pre">SVM</span></code> que hemos entrenado con un <code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code> entrenado en el mismo conjunto de datos. El <code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code> no tiene una función de decisión, sólo <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>. La función <code class="docutils literal notranslate"><span class="pre">precision_recall_curve</span></code> espera como segundo argumento una medida de certeza para la clase positiva (clase 1), por lo que pasamos la probabilidad de que una muestra sea de la clase 1, es decir, <code class="docutils literal notranslate"><span class="pre">rf.predict_proba(X_test)[:,</span> <span class="pre">1]</span></code>. El umbral por defecto para <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> en la clasificación binaria es 0.5, por lo que este es el punto marcado en la curva. Por defecto, <code class="docutils literal notranslate"><span class="pre">max_features=sqrt(n_features)</span></code> en la clase <code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-3 {color: black;}#sk-container-id-3 pre{padding: 0;}#sk-container-id-3 div.sk-toggleable {background-color: white;}#sk-container-id-3 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-3 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-3 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-3 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-3 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-3 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-3 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-3 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-3 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-3 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-3 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-3 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-3 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-3 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-3 div.sk-item {position: relative;z-index: 1;}#sk-container-id-3 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-3 div.sk-item::before, #sk-container-id-3 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-3 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-3 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-3 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-3 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-3 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-3 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-3 div.sk-label-container {text-align: center;}#sk-container-id-3 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-3 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-3" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>RandomForestClassifier(max_features=2, random_state=0)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-5" type="checkbox" checked><label for="sk-estimator-id-5" class="sk-toggleable__label sk-toggleable__label-arrow">RandomForestClassifier</label><div class="sk-toggleable__content"><pre>RandomForestClassifier(max_features=2, random_state=0)</pre></div></div></div></div></div></div></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code> tiene <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>, pero no <code class="docutils literal notranslate"><span class="pre">decision_function</span></code>. El método <code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code> devuelve una matriz bidimensional que contiene las <code class="docutils literal notranslate"><span class="pre">probabilidades</span> <span class="pre">estimadas</span> <span class="pre">para</span> <span class="pre">cada</span> <span class="pre">instancia</span> <span class="pre">y</span> <span class="pre">cada</span> <span class="pre">clase</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">precision_rf</span><span class="p">,</span> <span class="n">recall_rf</span><span class="p">,</span> <span class="n">thresholds_rf</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;svc&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">recall</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> 
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero svc&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_rf</span><span class="p">,</span> <span class="n">recall_rf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;rf&quot;</span><span class="p">)</span>

<span class="n">close_default_rf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds_rf</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="n">recall_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold 0.5 rf&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Precision&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Recall&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/df49d33afde3b2a98beb86a11cc9a2489ebe2ea98f76519a6d4777391cd35610.png" src="_images/df49d33afde3b2a98beb86a11cc9a2489ebe2ea98f76519a6d4777391cd35610.png" />
</div>
</div>
<ul class="simple">
<li><p>En el gráfico de comparación podemos ver que el bosque aleatorio funciona mejor en los extremos, para requisitos de <code class="docutils literal notranslate"><span class="pre">recall</span></code> o de <code class="docutils literal notranslate"><span class="pre">precision</span></code> muy altos. Alrededor de cualquier nivel de precision, <code class="docutils literal notranslate"><span class="pre">RF</span></code> tiene un mejor rendimiento. Si sólo nos fijamos en el <span class="math notranslate nohighlight">\(f_{1}\)</span>-score para comparar el rendimiento general, habríamos pasado por alto estas sutilezas. El <span class="math notranslate nohighlight">\(f_{1}\)</span>-score sólo capta un punto de la curva <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>, el dado por el <code class="docutils literal notranslate"><span class="pre">umbral</span> <span class="pre">por</span> <span class="pre">defecto</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1_score of random forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1_score of svc: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1_score of random forest: 0.973
f1_score of svc: 0.773
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La comparación de dos curvas <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code> proporciona una visión muy detallada, pero <code class="docutils literal notranslate"><span class="pre">es</span> <span class="pre">un</span> <span class="pre">proceso</span> <span class="pre">bastante</span> <span class="pre">manual</span></code>. Para la comparación automática de modelos, es posible que queramos resumir la información contenida en la curva, sin limitarnos a un umbral o punto de operación. Una forma concreta de resumir la curva <code class="docutils literal notranslate"><span class="pre">precisión-recall</span></code> es <strong><code class="docutils literal notranslate"><span class="pre">calcular</span> <span class="pre">la</span> <span class="pre">integral</span> <span class="pre">o</span> <span class="pre">el</span> <span class="pre">área</span> <span class="pre">bajo</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">precision-recall,</span> <span class="pre">también</span> <span class="pre">conocida</span> <span class="pre">como</span> <span class="pre">precisión</span> <span class="pre">media</span></code></strong>. Para calcular la precisión media se puede utilizar la función <code class="docutils literal notranslate"><span class="pre">average_precision_score</span></code>. Como tenemos que calcular la curva ROC y considerar múltiples umbrales, el resultado de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> debe pasarse a <code class="docutils literal notranslate"><span class="pre">average_precision_score</span></code>, no el resultado de <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">average_precision_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ap_rf</span> <span class="o">=</span> <span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ap_svc</span> <span class="o">=</span> <span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average precision of random forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ap_rf</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average precision of svc: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ap_svc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average precision of random forest: 0.997
Average precision of svc: 0.962
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Al promediar todos los umbrales posibles, vemos que el bosque aleatorio y el SVC tienen un rendimiento similar, con <code class="docutils literal notranslate"><span class="pre">RF</span></code> ligeramente por delante. Esto es bastante diferente del resultado que obtuvimos antes con <span class="math notranslate nohighlight">\(f_{1}\)</span>-score. Como la <code class="docutils literal notranslate"><span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">es</span> <span class="pre">el</span> <span class="pre">área</span> <span class="pre">área</span> <span class="pre">bajo</span> <span class="pre">una</span> <span class="pre">curva</span> <span class="pre">que</span> <span class="pre">va</span> <span class="pre">de</span> <span class="pre">0</span> <span class="pre">a</span> <span class="pre">1,</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">siempre</span> <span class="pre">devuelve</span> <span class="pre">un</span> <span class="pre">valor</span> <span class="pre">entre</span> <span class="pre">0</span> <span class="pre">(worst)</span> <span class="pre">y</span> <span class="pre">1</span> <span class="pre">(best)</span></code>. La precisión media de un clasificador que asigna <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> al azar es la fracción de muestras positivas en el conjunto de datos.</p></li>
</ul>
<section id="caracteristicas-operativas-del-receptor-roc-y-auc">
<h3>Características operativas del receptor (ROC) y AUC<a class="headerlink" href="#caracteristicas-operativas-del-receptor-roc-y-auc" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Existe otra herramienta que se utiliza habitualmente para analizar el comportamiento de los clasificadores a diferentes umbrales: la <code class="docutils literal notranslate"><span class="pre">receiver</span> <span class="pre">operating</span> <span class="pre">characteristics</span> <span class="pre">curve</span></code> o <code class="docutils literal notranslate"><span class="pre">ROC</span> <span class="pre">curve</span></code>. Al igual que la curva <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>, la curva ROC considera todas los posibles umbrales para un clasificador determinado, pero en lugar de informar sobre su <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code>, muestra la tasa de falsos positivos <code class="docutils literal notranslate"><span class="pre">false</span> <span class="pre">positive</span> <span class="pre">rate</span> <span class="pre">(FPR)</span></code> frente a la tasa de verdaderos positivos <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">positive</span> <span class="pre">rate</span> <span class="pre">(TPR)</span></code>. Recordemos que la tasa de verdaderos positivos es simplemente otro nombre para el <code class="docutils literal notranslate"><span class="pre">recall</span></code>, mientras que la <code class="docutils literal notranslate"><span class="pre">tasa</span> <span class="pre">de</span> <span class="pre">falsos</span> <span class="pre">positivos</span></code>, es la fracción de falsos positivos entre todas las muestras negativas, esto es, la <strong><code class="docutils literal notranslate"><span class="pre">proporción</span> <span class="pre">de</span> <span class="pre">negativos</span> <span class="pre">reales,</span> <span class="pre">clasificados</span> <span class="pre">de</span> <span class="pre">forma</span> <span class="pre">incorrecta</span></code></strong>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
FPR=\frac{FP}{FP+TN}.
\]</div>
<ul class="simple">
<li><p>Nótese que <span class="math notranslate nohighlight">\(FPR\)</span> se utiliza como métrica de rendimiento cuando el objetivo es <code class="docutils literal notranslate"><span class="pre">limitar</span> <span class="pre">el</span> <span class="pre">número</span> <span class="pre">de</span> <span class="pre">verdaderos</span> <span class="pre">negativos</span></code>. La curva ROC puede calcularse mediante la función <code class="docutils literal notranslate"><span class="pre">roc_curve</span></code>. Nótese que si <span class="math notranslate nohighlight">\(FPR\rightarrow 0\)</span> entonces el número de <span class="math notranslate nohighlight">\(TN\)</span> crece.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR (recall)&quot;</span><span class="p">)</span>
<span class="n">close_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/42522fd7f54c027e928ee2e6ec976ed8a6db5a0cb666af8e51ad4a86905e6ff0.png" src="_images/42522fd7f54c027e928ee2e6ec976ed8a6db5a0cb666af8e51ad4a86905e6ff0.png" />
</div>
</div>
<ul class="simple">
<li><p>Nótese que, <code class="docutils literal notranslate"><span class="pre">los</span> <span class="pre">valores</span> <span class="pre">más</span> <span class="pre">pequeños</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">eje</span></code> <span class="math notranslate nohighlight">\(x\)</span> <code class="docutils literal notranslate"><span class="pre">indican</span> <span class="pre">menos</span> <span class="pre">falsos</span> <span class="pre">positivos</span> <span class="pre">(FP)</span> <span class="pre">y</span> <span class="pre">más</span> <span class="pre">verdaderos</span> <span class="pre">negativos</span> <span class="pre">(TN).</span> <span class="pre">Los</span> <span class="pre">valores</span> <span class="pre">más</span> <span class="pre">grandes</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">eje</span></code> <span class="math notranslate nohighlight">\(y\)</span> <code class="docutils literal notranslate"><span class="pre">indican</span> <span class="pre">más</span> <span class="pre">verdaderos</span> <span class="pre">positivos</span> <span class="pre">(TP)</span> <span class="pre">y</span> <span class="pre">menos</span> <span class="pre">falsos</span> <span class="pre">negativos</span> <span class="pre">(FN)</span></code>. En cuanto a la curva <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>, a menudo queremos resumir la curva ROC utilizando un solo número, <code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">área</span> <span class="pre">bajo</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">(comúnmente</span> <span class="pre">se</span> <span class="pre">denomina</span> <span class="pre">simplemente</span> <span class="pre">AUC,</span> <span class="pre">y</span> <span class="pre">se</span> <span class="pre">entiende</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">en</span> <span class="pre">cuestión</span> <span class="pre">es</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">ROC)</span></code>. Podemos calcular el área bajo la curva <code class="docutils literal notranslate"><span class="pre">ROC</span></code> con la función <code class="docutils literal notranslate"><span class="pre">roc_auc_score</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rf_auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">svc_auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC for Random Forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rf_auc</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC for SVC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">svc_auc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AUC for Random Forest: 0.995
AUC for SVC: 0.940
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fpr_rf</span><span class="p">,</span> <span class="n">tpr_rf</span><span class="p">,</span> <span class="n">thresholds_rf</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve SVC&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_rf</span><span class="p">,</span> <span class="n">tpr_rf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve RF&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR (recall)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero SVC&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">close_default_rf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds_rf</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="n">tpr_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold 0.5 RF&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/177843ae81ec1dc626d71f329aa17b416d69a54214f1d82b197574fc8bc89067.png" src="_images/177843ae81ec1dc626d71f329aa17b416d69a54214f1d82b197574fc8bc89067.png" />
</div>
</div>
<ul class="simple">
<li><p>Comparando el bosque aleatorio y las SVM utilizando el AUC-score, encontramos que el bosque aleatorio es ligeramente poco mejor que SVM. <code class="docutils literal notranslate"><span class="pre">Recordemos</span> <span class="pre">que</span> <span class="pre">la</span> <span class="pre">precisión</span> <span class="pre">media</span> <span class="pre">es</span> <span class="pre">el</span> <span class="pre">área</span> <span class="pre">bajo</span> <span class="pre">una</span> <span class="pre">curva</span> <span class="pre">que</span> <span class="pre">va</span> <span class="pre">de</span> <span class="pre">0</span> <span class="pre">a</span> <span class="pre">1,</span> <span class="pre">siempre</span> <span class="pre">devuelve</span> <span class="pre">un</span> <span class="pre">valor</span> <span class="pre">entre</span> <span class="pre">0</span> <span class="pre">(worst)</span> <span class="pre">y</span> <span class="pre">1</span> <span class="pre">(best)</span></code>. La predicción aleatoria siempre produce un AUC de 0.5, independientemente de lo desequilibradas que estén las clases de un conjunto de datos. <code class="docutils literal notranslate"><span class="pre">Esto</span> <span class="pre">hace</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">AUC</span> <span class="pre">sea</span> <span class="pre">una</span> <span class="pre">métrica</span> <span class="pre">mucho</span> <span class="pre">mejor</span> <span class="pre">para</span> <span class="pre">los</span> <span class="pre">problemas</span> <span class="pre">de</span> <span class="pre">clasificación</span> <span class="pre">desequilibrada</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">accuracy</span></code>.</p></li>
<li><p>El <code class="docutils literal notranslate"><span class="pre">AUC</span></code> puede interpretarse como la evaluación del ranking de muestras positivas. Equivale a la probabilidad de que un punto elegido al azar de la clase positiva tenga un scoring más alto, según el clasificador, que de forma aleatoria toma un punto al azar de la clase negativa. Así, un AUC perfecto de 1 significa que todos los puntos positivos tienen un scoring más alto que todos los puntos negativos. <code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">los</span> <span class="pre">problemas</span> <span class="pre">de</span> <span class="pre">clasificación</span> <span class="pre">con</span> <span class="pre">clases</span> <span class="pre">desequilibradas,</span> <span class="pre">utilizar</span> <span class="pre">el</span> <span class="pre">AUC</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">del</span> <span class="pre">modelo</span> <span class="pre">es</span> <span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">mucho</span> <span class="pre">más</span> <span class="pre">significativo</span> <span class="pre">que</span> <span class="pre">el</span> <span class="pre">uso</span> <span class="pre">de</span> <span class="pre">accuracy</span></code>. Volvamos al problema que estudiamos antes de clasificar todos los nueves del conjunto de datos de dígitos frente a todos los demás dígitos. Clasificaremos el conjunto de datos con una SVM con tres ajustes diferentes anchos de banda del kernel, <code class="docutils literal notranslate"><span class="pre">gamma</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]:</span>
    <span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
    <span class="n">auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
    <span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span> <span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gamma = </span><span class="si">{:.2f}</span><span class="s2"> accuracy = </span><span class="si">{:.2f}</span><span class="s2"> AUC = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="n">auc</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;gamma=</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>gamma = 1.00 accuracy = 0.63 AUC = 0.51
gamma = 0.07 accuracy = 0.63 AUC = 0.94
gamma = 0.01 accuracy = 0.63 AUC = 0.95
</pre></div>
</div>
<img alt="_images/ddd9b4dcd9024a7eb7327ac54b86ce3d0d47edde797272fc356868604553c606.png" src="_images/ddd9b4dcd9024a7eb7327ac54b86ce3d0d47edde797272fc356868604553c606.png" />
</div>
</div>
<ul class="simple">
<li><p>Los valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> de los tres ajustes de <code class="docutils literal notranslate"><span class="pre">gamma</span></code> son <code class="docutils literal notranslate"><span class="pre">0.51,</span> <span class="pre">0.94,</span> <span class="pre">y</span> <span class="pre">0.95</span></code>. Con <code class="docutils literal notranslate"><span class="pre">gamma=1.0</span></code> el AUC está realmente al nivel del azar, lo que significa que el resultado de la función de decisión es tan bueno como el azar. Con <code class="docutils literal notranslate"><span class="pre">gamma=0.07</span></code>, el rendimiento mejora drásticamente hasta un AUC de 0.94. Por último, con <code class="docutils literal notranslate"><span class="pre">gamma=0.01</span></code>, obtenemos un AUC de <code class="docutils literal notranslate"><span class="pre">0.95</span></code>. <code class="docutils literal notranslate"><span class="pre">Esto</span> <span class="pre">significa</span> <span class="pre">que</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">puntos</span> <span class="pre">positivos</span> <span class="pre">están</span> <span class="pre">mejor</span> <span class="pre">clasificados</span> <span class="pre">que</span> <span class="pre">los</span> <span class="pre">negativos</span> <span class="pre">según</span> <span class="pre">la</span> <span class="pre">función</span> <span class="pre">de</span> <span class="pre">decisión</span></code>. En otras palabras, con el umbral adecuado, este modelo puede clasificar los datos perfectamente. Sabiendo esto, podemos ajustar el umbral de este modelo y obtener grandes predicciones.</p></li>
<li><p>Si sólo hubiéramos utilizado <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, nunca habríamos descubierto esto. <code class="docutils literal notranslate"><span class="pre">Por</span> <span class="pre">este</span> <span class="pre">motivo,</span> <span class="pre">recomendamos</span> <span class="pre">altamente</span> <span class="pre">utilizar</span> <span class="pre">el</span> <span class="pre">AUC</span> <span class="pre">cuando</span> <span class="pre">se</span> <span class="pre">evalúan</span> <span class="pre">los</span> <span class="pre">modelos</span> <span class="pre">con</span> <span class="pre">datos</span> <span class="pre">desequilibrados</span></code>. Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">AUC</span></code> no utiliza el umbral por defecto, por lo que podría ser necesario ajustar el umbral de decisión para obtener resultados de clasificación útiles de un modelo con un AUC alto.</p></li>
</ul>
</section>
</section>
<section id="metricas-para-la-clasificacion-multiclase">
<h2>Métricas para la clasificación multiclase<a class="headerlink" href="#metricas-para-la-clasificacion-multiclase" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Ahora que hemos discutido en profundidad la evaluación de las tareas de clasificación binaria, nos movemos a las métricas para evaluar la clasificación multiclase. <code class="docutils literal notranslate"><span class="pre">Básicamente,</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">métricas</span> <span class="pre">para</span> <span class="pre">clasificación</span> <span class="pre">multiclase</span> <span class="pre">se</span> <span class="pre">derivan</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">métricas</span> <span class="pre">de</span> <span class="pre">clasificación</span> <span class="pre">binaria,</span> <span class="pre">pero</span> <span class="pre">promediadas</span> <span class="pre">sobre</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">clases</span></code>. Un <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> para la clasificación multiclase se define de nuevo como la fracción de ejemplos clasificados correctamente. Y de nuevo, cuando las clases están desequilibradas, el <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> no es una buena medida de evaluación.</p></li>
<li><p>Imagínese un problema de clasificación de tres clases con un 85% de puntos que pertenecen a la clase A, el 10% a la clase B y el 5% a la clase C. ¿Qué significa tener un 85% de precisión en este conjunto de datos?. En general, los resultados de la clasificación multiclase son más difíciles de entender que los resultados de la clasificación binaria. Además del <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, las herramientas habituales son la <code class="docutils literal notranslate"><span class="pre">matriz</span> <span class="pre">de</span> <span class="pre">confusión</span></code> y el <code class="docutils literal notranslate"><span class="pre">informe</span> <span class="pre">de</span> <span class="pre">clasificación</span></code> que vimos en el caso binario en la sección anterior. Apliquemos estos dos métodos de evaluación detallados a la tarea de clasificar los 10 dígitos diferentes escritos a mano en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">digits</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Confusion matrix:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Accuracy: 0.951
Confusion matrix:
[[37  0  0  0  0  0  0  0  0  0]
 [ 0 40  0  0  0  0  0  0  2  1]
 [ 0  1 40  3  0  0  0  0  0  0]
 [ 0  0  0 43  0  0  0  0  1  1]
 [ 0  0  0  0 37  0  0  1  0  0]
 [ 0  0  0  0  0 46  0  0  0  2]
 [ 0  1  0  0  0  0 51  0  0  0]
 [ 0  0  0  1  1  0  0 46  0  0]
 [ 0  3  1  0  0  0  0  0 43  1]
 [ 0  0  0  0  0  1  0  0  1 45]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El modelo tiene un accuracy del 95.1%, lo que ya nos dice que lo estamos haciendo bastante bien. La matriz de confusión nos proporciona algunos detalles más. Como en el caso binario, <code class="docutils literal notranslate"><span class="pre">cada</span> <span class="pre">fila</span> <span class="pre">corresponde</span> <span class="pre">a</span> <span class="pre">una</span> <span class="pre">etiqueta</span> <span class="pre">verdadera</span> <span class="pre">y</span> <span class="pre">cada</span> <span class="pre">columna</span> <span class="pre">a</span> <span class="pre">una</span> <span class="pre">etiqueta</span> <span class="pre">predicha</span></code>. En la siguiente figura se puede encontrar una mejor representación visual</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores_image</span> <span class="o">=</span> <span class="n">mglearn</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">),</span> 
                                     <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Predicted label&#39;</span><span class="p">,</span>
                                     <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;True label&#39;</span><span class="p">,</span> 
                                     <span class="n">xticklabels</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target_names</span><span class="p">,</span>
                                     <span class="n">yticklabels</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target_names</span><span class="p">,</span> 
                                     <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray_r</span><span class="p">,</span> 
                                     <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Confusion matrix&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/68b03fd95dd2e18f487c0e1949dc6c6dd8b5e7add8b7d349348dc814aadf4f24.png" src="_images/68b03fd95dd2e18f487c0e1949dc6c6dd8b5e7add8b7d349348dc814aadf4f24.png" />
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Para</span> <span class="pre">la</span> <span class="pre">primera</span> <span class="pre">clase,</span> <span class="pre">el</span> <span class="pre">dígito</span> <span class="pre">0,</span> <span class="pre">hay</span> <span class="pre">37</span> <span class="pre">muestras</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">clase,</span> <span class="pre">y</span> <span class="pre">todas</span> <span class="pre">estas</span> <span class="pre">muestras</span> <span class="pre">fueron</span> <span class="pre">clasificadas</span> <span class="pre">como</span> <span class="pre">clase</span> <span class="pre">0</span> <span class="pre">(no</span> <span class="pre">hay</span> <span class="pre">falsos</span> <span class="pre">negativos</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">clase</span> <span class="pre">0)</span></code>. Podemos ver el por qué todas las demás entradas de la primera fila de la matriz de confusión son 0. También podemos ver que ningún otro dígito fue clasificado erróneamente como 0, porque todas las demás entradas de la primera columna de la matriz de confusión son 0 (no hay falsos positivos para la clase 0). <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span> <span class="pre">algunos</span> <span class="pre">dígitos</span> <span class="pre">se</span> <span class="pre">confundieron</span> <span class="pre">con</span> <span class="pre">otros;</span> <span class="pre">por</span> <span class="pre">ejemplo,</span> <span class="pre">el</span> <span class="pre">dígito</span> <span class="pre">2</span> <span class="pre">(tercera</span> <span class="pre">fila),</span> <span class="pre">tres</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">cuales</span> <span class="pre">fueron</span> <span class="pre">clasificados</span> <span class="pre">como</span> <span class="pre">el</span> <span class="pre">dígito</span> <span class="pre">3</span> <span class="pre">(cuarta</span> <span class="pre">columna)</span> <span class="pre">y</span> <span class="pre">uno</span> <span class="pre">fué</span> <span class="pre">clasificado</span> <span class="pre">como</span> <span class="pre">el</span> <span class="pre">dígito</span> <span class="pre">1</span> <span class="pre">(segunda</span> <span class="pre">columna)</span></code>. También hubo un dígito 8 que se clasificó como 2 (tercera columna, novena fila). Con la función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code>, podemos calcular <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span>-score para cada clase.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       1.00      1.00      1.00        37
           1       0.89      0.93      0.91        43
           2       0.98      0.91      0.94        44
           3       0.91      0.96      0.93        45
           4       0.97      0.97      0.97        38
           5       0.98      0.96      0.97        48
           6       1.00      0.98      0.99        52
           7       0.98      0.96      0.97        48
           8       0.91      0.90      0.91        48
           9       0.90      0.96      0.93        47

    accuracy                           0.95       450
   macro avg       0.95      0.95      0.95       450
weighted avg       0.95      0.95      0.95       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>No es de extrañar que los valores para <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> sean un 1 perfecto para la clase 0, ya que no hay confusiones con esta clase. Para la clase 6, en cambio, el <code class="docutils literal notranslate"><span class="pre">precision</span></code> es de 1 porque ninguna otra clase se clasificó erróneamente como 6. <code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">métrica</span> <span class="pre">más</span> <span class="pre">utilizada</span> <span class="pre">para</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">desequilibrados</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">entorno</span> <span class="pre">multiclase</span> <span class="pre">es</span> <span class="pre">la</span> <span class="pre">versión</span> <span class="pre">multiclase</span> <span class="pre">del</span></code> <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code>.</p></li>
<li><p>La idea detrás del <span class="math notranslate nohighlight">\(f\)</span>-score multiclase es calcular un <span class="math notranslate nohighlight">\(f\)</span>-score <code class="docutils literal notranslate"><span class="pre">binario</span> <span class="pre">por</span> <span class="pre">clase,</span> <span class="pre">siendo</span> <span class="pre">esa</span> <span class="pre">clase</span> <span class="pre">la</span> <span class="pre">positiva</span> <span class="pre">y</span> <span class="pre">las</span> <span class="pre">otras</span> <span class="pre">clases</span> <span class="pre">las</span> <span class="pre">negativas</span></code>. Luego, estos <span class="math notranslate nohighlight">\(f\)</span>-scores por clase se promedian utilizando una de las siguientes estrategias:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">promedio</span> <span class="pre">&quot;macro&quot;</span></code> calcula los <span class="math notranslate nohighlight">\(f\)</span>-scores no ponderadas por clase. De este modo, se da el mismo peso a todas las clases, independientemente de su tamaño.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">promedio</span> <span class="pre">&quot;weighted&quot;</span></code> calcula la media de los <span class="math notranslate nohighlight">\(f\)</span>-scores por clase, ponderada por su soporte. Esto es lo que se indica en el informe de clasificación.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">promedio</span> <span class="pre">&quot;micro&quot;</span></code> calcula el número total de falsos positivos, falsos negativos y verdaderos positivos en todas las clases, y luego calcula <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code> utilizando estos recuentos.</p></li>
</ul>
</li>
<li><p>Si se preocupa por igual de cada muestra, se recomienda utilizar el “micro” <span class="math notranslate nohighlight">\(f\)</span>-score; si le importa cada clase por igual, se recomienda utilizar la media macro <span class="math notranslate nohighlight">\(f\)</span>-score.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Macro average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;macro&quot;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weighted average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Micro average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;micro&quot;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Macro average f1 score: 0.952
Weighted average f1 score: 0.951
Micro average f1 score: 0.951
</pre></div>
</div>
</div>
</div>
</section>
<section id="metricas-de-regresion">
<h2>Métricas de regresión<a class="headerlink" href="#metricas-de-regresion" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>La evaluación de la regresión puede hacerse con un detalle similar al que hicimos para la clasificación. Por ejemplo, analizando la sobrepredicción del objetivo frente a la subpredicción del objetivo. <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">mayoría</span> <span class="pre">de</span> <span class="pre">las</span> <span class="pre">aplicaciones</span> <span class="pre">que</span> <span class="pre">hemos</span> <span class="pre">visto,</span> <span class="pre">el</span> <span class="pre">uso</span> <span class="pre">del</span> <span class="pre">$R^2$</span> <span class="pre">por</span> <span class="pre">defecto</span> <span class="pre">utilizado</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">score</span> <span class="pre">de</span> <span class="pre">todos</span> <span class="pre">los</span> <span class="pre">regresores</span> <span class="pre">es</span> <span class="pre">suficiente</span></code>. A veces, las <code class="docutils literal notranslate"><span class="pre">decisiones</span> <span class="pre">empresariales</span> <span class="pre">se</span> <span class="pre">toman</span> <span class="pre">sobre</span> <span class="pre">la</span> <span class="pre">base</span> <span class="pre">de</span> <span class="pre">error</span> <span class="pre">medio</span> <span class="pre">al</span> <span class="pre">cuadrado</span> <span class="pre">o</span> <span class="pre">el</span> <span class="pre">error</span> <span class="pre">medio</span> <span class="pre">absoluto,</span> <span class="pre">lo</span> <span class="pre">que</span> <span class="pre">podría</span> <span class="pre">incentivar</span> <span class="pre">el</span> <span class="pre">ajustar</span> <span class="pre">los</span> <span class="pre">modelos</span> <span class="pre">utilizando</span> <span class="pre">estas</span> <span class="pre">métricas</span></code>. En general, sin embargo, hemos encontrado que <span class="math notranslate nohighlight">\(R^2\)</span> es una métrica más intuitiva para evaluar los modelos de regresión. En el curso de <code class="docutils literal notranslate"><span class="pre">Time</span> <span class="pre">Series</span> <span class="pre">Forecasting</span></code> profundizaremos en el uso de este tipo de métricas, así como tambíen: <code class="docutils literal notranslate"><span class="pre">MAE,</span> <span class="pre">MAPE,</span> <span class="pre">MSE,</span> <span class="pre">RMSE</span></code>.</p></li>
</ul>
<section id="uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">
<h3>Uso de métricas de evaluación en la selección de modelos<a class="headerlink" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Hemos discutido muchos métodos de evaluación en detalle, y cómo aplicarlos para ciertos conjuntos de datos y un modelo. Sin embargo, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">queremos</span> <span class="pre">utilizar</span> <span class="pre">métricas</span> <span class="pre">como</span> <span class="pre">AUC</span> <span class="pre">en</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">de</span> <span class="pre">modelos</span> <span class="pre">utilizando</span> <span class="pre">GridSearchCV</span> <span class="pre">o</span> <span class="pre">cross_val_score</span></code>. Afortunadamente, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> proporciona una manera muy simple de lograr esto, a través del argumento <code class="docutils literal notranslate"><span class="pre">scoring</span></code> que se puede utilizar en ambos <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> y <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>. Es posible simplemente proporcionar una cadena que describa la métrica de evaluación que desea utilizar. Digamos, por ejemplo, que queremos evaluar el clasificador SVM en la tarea “nine vs. rest” en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">digits</span></code>, utilizando el scoring AUC. El cambio del scoring por defecto (accuracy) a AUC se puede hacer proporcionando “<code class="docutils literal notranslate"><span class="pre">roc_auc</span></code>” como parámetro de scoring</p></li>
</ul>
<ul class="simple">
<li><p>Scoring por defecto para la clasificación es <code class="docutils literal notranslate"><span class="pre">accuracy</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Default scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Default scoring: [0.975      0.99166667 1.         0.99442897 0.98050139]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Proporcionar <code class="docutils literal notranslate"><span class="pre">scoring=&quot;accuracy&quot;</span></code> no cambia los resultados</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">explicit_accuracy</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;accuracy&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Explicit accuracy scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">explicit_accuracy</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Explicit accuracy scoring: [0.975      0.99166667 1.         0.99442897 0.98050139]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Ahora asignemos <code class="docutils literal notranslate"><span class="pre">scoring=&quot;roc_auc&quot;</span></code> para modificar la técnica de <code class="docutils literal notranslate"><span class="pre">scoring</span></code> utilizada</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">roc_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;roc_auc&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roc_auc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AUC scoring: [0.99717078 0.99854252 1.         0.999828   0.98400413]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Del mismo modo, podemos cambiar la métrica utilizada para elegir los mejores parámetros en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Proporcionamos una red a manera de ilustración del punto</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]}</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando el score <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> por defecto</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grid-Search with accuracy&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters:&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score (accuracy)): </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set AUC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Grid-Search with accuracy
Best parameters: {&#39;gamma&#39;: 0.0001}
Best cross-validation score (accuracy)): 0.976
Test set AUC: 0.992
Test set accuracy: 0.973
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando el scoring AUC en su lugar</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;roc_auc&quot;</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Grid-Search with AUC&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters:&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score (AUC): </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set AUC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Grid-Search with AUC
Best parameters: {&#39;gamma&#39;: 0.01}
Best cross-validation score (AUC): 0.998
Test set AUC: 1.000
Test set accuracy: 1.000
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Cuando se utiliza <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, se selecciona el parámetro <code class="docutils literal notranslate"><span class="pre">gamma=0.0001</span></code>, mientras que cuando se utiliza el AUC se selecciona <code class="docutils literal notranslate"><span class="pre">gamma=0.01</span></code>. Accuracy score para la validación cruzada es coherente con el <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> del conjunto de prueba en ambos casos. <code class="docutils literal notranslate"><span class="pre">Sin</span> <span class="pre">embargo,</span> <span class="pre">al</span> <span class="pre">utilizar</span> <span class="pre">AUC</span> <span class="pre">se</span> <span class="pre">encontró</span> <span class="pre">un</span> <span class="pre">mejor</span> <span class="pre">ajuste</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">parámetros</span> <span class="pre">en</span> <span class="pre">en</span> <span class="pre">términos</span> <span class="pre">de</span> <span class="pre">AUC</span> <span class="pre">e</span> <span class="pre">incluso</span> <span class="pre">en</span> <span class="pre">términos</span> <span class="pre">de</span> <span class="pre">accuracy</span></code>. Los valores más importantes del parámetro de scoring para la clasificación son <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> (por defecto); <code class="docutils literal notranslate"><span class="pre">roc_auc</span></code> para el área bajo la curva ROC; <code class="docutils literal notranslate"><span class="pre">average_precision</span></code> para el área bajo la curva de <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>; <code class="docutils literal notranslate"><span class="pre">f1,</span> <span class="pre">f1_macro,</span> <span class="pre">f1_micro</span></code> y <code class="docutils literal notranslate"><span class="pre">f1_weighted</span></code> para <span class="math notranslate nohighlight">\(f_{1}\)</span>-score binario y las diferentes variantes ponderadas.</p></li>
<li><p>En cuanto a la regresión, los valores más utilizados son <code class="docutils literal notranslate"><span class="pre">r2</span></code> para el score <span class="math notranslate nohighlight">\(R^{2}\)</span>, <code class="docutils literal notranslate"><span class="pre">mean_squared_error</span></code> para el error medio al cuadrado y <code class="docutils literal notranslate"><span class="pre">mean_absolute_error</span></code> para el error medio absoluto. Puede encontrar una lista completa de argumentos admitidos en la <a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules">documentación</a> o consultando el diccionario SCORER definido en el módulo <code class="docutils literal notranslate"><span class="pre">metrics.scorer</span></code>.</p></li>
</ul>
<div class="admonition-resumen-y-conclusiones admonition">
<p class="admonition-title">Resumen y conclusiones</p>
<ul class="simple">
<li><p>En esta sección hemos hablado de la validación cruzada, el grid-search y las métricas de evaluación, los pilares de la evaluación y la mejora de los algoritmos de aprendizaje automático. Las herramientas descritas en este capítulo, junto con los algoritmos descritos, son el pan de cada día para cualquier profesional del aprendizaje automático. Hay dos puntos particulares que hemos hecho en este capítulo que merecen ser repetidos, porque a menudo son pasados por alto por quienes inician investigación en este campo.</p></li>
<li><p>El primero tiene que ver con la validación cruzada. <code class="docutils literal notranslate"><span class="pre">La</span> <span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">o</span> <span class="pre">el</span> <span class="pre">uso</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">pruebas</span> <span class="pre">nos</span> <span class="pre">permite</span> <span class="pre">evaluar</span> <span class="pre">un</span> <span class="pre">modelo</span> <span class="pre">de</span> <span class="pre">aprendizaje</span> <span class="pre">automático</span> <span class="pre">tal</span> <span class="pre">y</span> <span class="pre">como</span> <span class="pre">se</span> <span class="pre">comportará</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">futuro</span></code>. Sin embargo, si utilizamos el conjunto de prueba o la validación cruzada para seleccionar un modelo o los parámetros del mismo, “agotamos” los datos de prueba, y <code class="docutils literal notranslate"><span class="pre">utilizar</span> <span class="pre">los</span> <span class="pre">mismos</span> <span class="pre">datos</span> <span class="pre">para</span> <span class="pre">evaluar</span> <span class="pre">el</span> <span class="pre">rendimiento</span> <span class="pre">de</span> <span class="pre">nuestro</span> <span class="pre">modelo</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">futuro</span> <span class="pre">nos</span> <span class="pre">llevará</span> <span class="pre">a</span> <span class="pre">estimaciones</span> <span class="pre">demasiado</span> <span class="pre">optimistas</span></code>. Por lo tanto, tenemos que recurrir a una división en <code class="docutils literal notranslate"><span class="pre">datos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">construcción</span> <span class="pre">del</span> <span class="pre">modelo,</span> <span class="pre">datos</span> <span class="pre">de</span> <span class="pre">validación</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">selección</span> <span class="pre">del</span> <span class="pre">modelo</span> <span class="pre">y</span> <span class="pre">los</span> <span class="pre">parámetros-datos</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">para</span> <span class="pre">la</span> <span class="pre">evaluación</span> <span class="pre">del</span> <span class="pre">modelo</span></code>. En lugar de una simple división, podemos sustituir cada una de estas divisiones con la validación cruzada. La forma más comúnmente utilizada (como se describió anteriormente) es la de entrenamiento/prueba para la evaluación, y el uso de la validación cruzada en el conjunto de entrenamiento para la selección de modelos y parámetros.</p></li>
<li><p>El segundo punto tiene que ver con la importancia de la métrica de evaluación o la función de scoring de evaluación utilizada para la selección y la evaluación del modelo. La teoría de cómo tomar decisiones empresariales a partir de las predicciones de un modelo de machine learning, se sale de los alcances del curso (ver por ejemplo <a class="reference external" href="https://www.oreilly.com/library/view/data-science-for/9781449374273/">Data Science for Business</a>). Sin embargo, rara vez el objetivo final de una tarea de aprendizaje automático es la construcción de un modelo con una gran precisión (accuracy). Asegúrese de que la que la métrica que elija para evaluar y seleccionar un modelo sea un buen sustituto de aquello para lo que se utilizará el modelo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">realidad,</span> <span class="pre">los</span> <span class="pre">problemas</span> <span class="pre">de</span> <span class="pre">clasificación</span> <span class="pre">rara</span> <span class="pre">vez</span> <span class="pre">tienen</span> <span class="pre">clases</span> <span class="pre">equilibradas,</span> <span class="pre">y</span> <span class="pre">a</span> <span class="pre">menudo</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">positivos</span> <span class="pre">y</span> <span class="pre">los</span> <span class="pre">falsos</span> <span class="pre">negativos</span> <span class="pre">tienen</span> <span class="pre">consecuencias</span> <span class="pre">muy</span> <span class="pre">diferentes</span></code>. Asegúrese de entender cuáles son estas consecuencias y elija un método de evaluación en consecuencia. Las técnicas de evaluación y selección de modelos que hemos descrito hasta ahora son las herramientas más importantes en la caja de herramientas de un científico de datos. <code class="docutils literal notranslate"><span class="pre">El</span> <span class="pre">grid-search</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">validación</span> <span class="pre">cruzada,</span> <span class="pre">tal</span> <span class="pre">y</span> <span class="pre">como</span> <span class="pre">la</span> <span class="pre">hemos</span> <span class="pre">descrito</span> <span class="pre">en</span> <span class="pre">esta</span> <span class="pre">sección,</span> <span class="pre">sólo</span> <span class="pre">pueden</span> <span class="pre">aplicarse</span> <span class="pre">a</span> <span class="pre">un</span> <span class="pre">único</span> <span class="pre">modelo</span> <span class="pre">supervisado</span></code>. Sin embargo, ya hemos visto que muchos modelos requieren un preprocesamiento y que en algunas aplicaciones, como por ejemplo, el reconocimiento de caras en imágenes, puede ser útil extraer una representación de los datos. En la siguiente sección, presentaremos la clase <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>, que nos permite utilizar grid-search y validación cruzada en cadenas complejas de algoritmos.</p></li>
</ul>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="practical_pca.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Análisis de Componentes Principales</p>
      </div>
    </a>
    <a class="right-next"
       href="chains_pipelines.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Cadenas de Algoritmos y Pipelines</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-validation">Cross-Validation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-en-scikit-learn">Validación cruzada en scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ventajas-de-la-validacion-cruzada">Ventajas de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-estratificada-k-fold-y-otras-estrategias">Validación cruzada estratificada <span class="math notranslate nohighlight">\(k\)</span>-fold y otras estrategias</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mas-control-sobre-la-validacion-cruzada">Más control sobre la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-exclusion-leave-one-out">Validación cruzada con exclusión (leave-one-out)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-aleatoria-y-dividida">Validación cruzada aleatoria y dividida</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-grupos">Validación cruzada con grupos</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search">Grid Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-simple">Grid Search simple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">El peligro de sobreajustar los parámetros y el conjunto de validación</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-con-validacion-cruzada">Grid Search con validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisis-del-resultado-de-la-validacion-cruzada">Análisis del resultado de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-sobre-espacios-que-no-son-una-red">Búsqueda sobre espacios que no son una red</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-anidada">Validación cruzada anidada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">Paralelización de la validación cruzada y la búsqueda en red</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-evaluacion-y-scoring">Métricas de evaluación y scoring</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tenga-en-cuenta-el-objetivo-final">Tenga en cuenta el objetivo final</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-binaria">Métricas para la clasificación binaria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tipos-de-errores">Tipos de errores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjuntos-de-datos-desequilibrados">Conjuntos de datos desequilibrados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-de-confusion">Matrices de confusión</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#teniendo-en-cuenta-la-incertidumbre">Teniendo en cuenta la incertidumbre</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#curvas-precision-recall-y-roc">Curvas precision-recall y ROC</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caracteristicas-operativas-del-receptor-roc-y-auc">Características operativas del receptor (ROC) y AUC</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-multiclase">Métricas para la clasificación multiclase</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-regresion">Métricas de regresión</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">Uso de métricas de evaluación en la selección de modelos</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Lihki Rubio PhD in Mathematical Engineering
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright Department of Mathematics and Statistics.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>