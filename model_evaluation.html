
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>9. Evaluación de modelos &#8212; Machine Learning</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=530fe47d" />
    <link rel="stylesheet" type="text/css" href="_static/.ipynb_checkpoints/custom-checkpoint.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'model_evaluation';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/custom.js?v=14184634"></script>
    <script src="_static/.ipynb_checkpoints/custom-checkpoint.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Cadenas de Algoritmos y Pipelines" href="chains_pipelines.html" />
    <link rel="prev" title="8. Análisis de Componentes Principales" href="practical_pca.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fotolihki.jpg" class="logo__image only-light" alt="Machine Learning - Home"/>
    <script>document.write(`<img src="_static/fotolihki.jpg" class="logo__image only-dark" alt="Machine Learning - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Profesor: Dr. Lihki Rubio
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="supervised_intro.html">1. Aprendizaje supervisado</a></li>
<li class="toctree-l1"><a class="reference internal" href="knn_model.html">2. <span class="math notranslate nohighlight">\(k\)</span>-vecinos más cercanos</a></li>
<li class="toctree-l1"><a class="reference internal" href="linear_model.html">3. Regresión Ridge y Lasso</a></li>
<li class="toctree-l1"><a class="reference internal" href="bayes_model.html">4. Clasificador Bayesiano</a></li>
<li class="toctree-l1"><a class="reference internal" href="decisiontree_model.html">5. Random Forest y XGBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="svm_model.html">6. Máquinas de vectores de soporte</a></li>
<li class="toctree-l1"><a class="reference internal" href="ann_model.html">7. Redes Neuronales y Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="practical_pca.html">8. Análisis de Componentes Principales</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">9. Evaluación de modelos</a></li>
<li class="toctree-l1"><a class="reference internal" href="chains_pipelines.html">10. Cadenas de Algoritmos y Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">11. Apéndice</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises_sols.html">12. Soluciones a ejercicios</a></li>
<li class="toctree-l1"><a class="reference internal" href="biblio.html">13. Bibliografía</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/model_evaluation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Evaluación de modelos</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-validation">9.1. Cross-Validation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-en-scikit-learn">9.1.1. Validación cruzada en scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ventajas-de-la-validacion-cruzada">9.1.2. Ventajas de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-kfold">9.1.3. Validación cruzada <code class="docutils literal notranslate"><span class="pre">KFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-estratificada-stratifiedkfold">9.1.4. Validación cruzada estratificada <code class="docutils literal notranslate"><span class="pre">StratifiedKFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-shuffle-kfold">9.1.5. Validación cruzada <code class="docutils literal notranslate"><span class="pre">shuffle</span> <span class="pre">KFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-exclusion-leave-one-out">9.1.6. Validación cruzada con exclusión <code class="docutils literal notranslate"><span class="pre">leave-one-out</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-aleatoria-y-divididashufflesplit">9.1.7. Validación cruzada aleatoria y dividida<code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-por-grupos-groupkfold">9.1.8. Validación cruzada por grupos <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search">9.2. Grid Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-simple">9.2.1. Grid Search simple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">9.2.2. El peligro de sobreajustar los parámetros y el conjunto de validación</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-con-validacion-cruzada">9.2.3. Grid Search con validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisis-del-resultado-de-la-validacion-cruzada">9.2.4. Análisis del resultado de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-sobre-espacios-que-no-son-una-red">9.2.5. Búsqueda sobre espacios que no son una red</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-anidada">9.2.6. Validación cruzada anidada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">9.2.7. Paralelización de la validación cruzada y la búsqueda en red</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-evaluacion-y-scoring">9.3. Métricas de evaluación y scoring</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tenga-en-cuenta-el-objetivo-final">9.3.1. Tenga en cuenta el objetivo final</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-binaria">9.3.2. Métricas para la clasificación binaria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tipos-de-errores">9.3.3. Tipos de errores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjuntos-de-datos-desequilibrados">9.3.4. Conjuntos de datos desequilibrados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-de-confusion">9.3.5. Matrices de confusión</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#teniendo-en-cuenta-la-incertidumbre">9.3.6. Teniendo en cuenta la incertidumbre</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#curvas-precision-recall-y-roc">9.4. Curvas precision-recall y ROC</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caracteristicas-operativas-del-receptor-roc-y-auc">9.4.1. Características operativas del receptor (ROC) y AUC</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-multiclase">9.5. Métricas para la clasificación multiclase</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-regresion">9.6. Métricas de regresión</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">9.6.1. Uso de métricas de evaluación en la selección de modelos</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#por-que-usar-pyspark-para-modelos-de-machine-learning-con-grandes-volumenes-de-datos">9.7. ¿Por qué usar <code class="docutils literal notranslate"><span class="pre">PySpark</span></code> para modelos de Machine Learning con grandes volúmenes de datos?</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="evaluacion-de-modelos">
<h1><span class="section-number">9. </span>Evaluación de modelos<a class="headerlink" href="#evaluacion-de-modelos" title="Link to this heading">#</a></h1>
<div class="tip admonition">
<p class="admonition-title">Introducción</p>
<ul class="simple">
<li><p>Después de discutir los <em><strong>fundamentos del aprendizaje supervisado y sus algoritmos</strong></em>, abordaremos la <em><strong>evaluación de modelos</strong></em> y la <em><strong>selección de parámetros</strong></em>. Nos enfocaremos en modelos supervisados, específicamente en <em><strong>regresión y clasificación</strong></em>, ya que la evaluación en aprendizaje no supervisado es más cualitativa.</p></li>
<li><p>Para evaluar modelos supervisados, dividimos el conjunto de datos en <em><strong>entrenamiento y prueba</strong></em> usando <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code>, construimos un modelo con <code class="docutils literal notranslate"><span class="pre">fit</span></code>, y lo evaluamos en el conjunto de prueba con <code class="docutils literal notranslate"><span class="pre">score</span></code>, que calcula la fracción de muestras correctamente clasificadas.</p></li>
</ul>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Creamos un conjunto de <em><strong>datos sintético</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Dividimos</strong></em> los datos y las etiquetas en un <em><strong>conjunto de entrenamiento y otro de prueba</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Instanciar</strong></em> el modelo y <em><strong>ajustarlo al conjunto de entrenamiento</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Evaluar</strong></em> el modelo en el <em><strong>conjunto de prueba</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set score: 0.88
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Evaluar</strong></em> el modelo en el <em><strong>conjunto de entrenamiento</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Train set score: 0.91
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p>Recuerde que la razón por la que dividimos nuestros datos en conjuntos de entrenamiento y de prueba, es que estamos interesados en medir lo bien que nuestro modelo se generaliza a nuevos datos (<em>no vistos anteriormente</em>).</p></li>
<li><p><em><strong>No nos interesa lo bien que nuestro modelo se ajusta al conjunto de entrenamiento, sino lo bien que puede hacer predicciones sobre datos no observados durante el entrenamiento</strong></em>.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>En esta sección, ampliaremos dos aspectos de esta evaluación. En primer lugar, introduciremos la <em><strong>validación cruzada</strong></em> (<code class="docutils literal notranslate"><span class="pre">cross-validation</span></code>), una forma más sólida de <em><strong>evaluar el rendimiento de la generalización</strong></em>, y discutiremos los <em><strong>métodos para evaluar el rendimiento de la clasificación y la regresión</strong></em> que van más allá de las medidas por defecto <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> y <span class="math notranslate nohighlight">\(R^2\)</span> proporcionadas por el método <code class="docutils literal notranslate"><span class="pre">score</span></code>.</p></li>
<li><p>También hablaremos del <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, un método eficaz para ajustar los parámetros de los modelos supervisados y obtener el <em><strong>mejor rendimiento de la generalización</strong></em>.</p></li>
</ul>
<section id="cross-validation">
<h2><span class="section-number">9.1. </span>Cross-Validation<a class="headerlink" href="#cross-validation" title="Link to this heading">#</a></h2>
<div class="tip admonition">
<p class="admonition-title">Introducción</p>
<ul class="simple">
<li><p>La <em><strong>validación cruzada</strong></em> (<code class="docutils literal notranslate"><span class="pre">cross-validation</span></code>) es un <em><strong>método estadístico para evaluar el rendimiento de la generalización</strong></em> que es <em>más estable y exhaustivo que el uso de una división en un conjunto de entrenamiento y otro de prueba</em>.</p></li>
<li><p>En la validación cruzada, <em><strong>los datos se dividen repetidamente y se entrenan múltiples modelos</strong></em>. La versión más utilizada de la validación cruzada es <code class="docutils literal notranslate"><span class="pre">k-fold</span> <span class="pre">cross-validation</span></code>, donde <code class="docutils literal notranslate"><span class="pre">k</span></code> es un número <em><strong>especificado por el usuario, normalmente 5 o 10</strong></em>.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>Cuando se realiza la validación cruzada <code class="docutils literal notranslate"><span class="pre">five-fold</span></code>, <em><strong>los datos se dividen primero en cinco partes de tamaño (aproximadamente) igual, llamadas pliegues (<code class="docutils literal notranslate"><span class="pre">folds</span></code>)</strong></em>. A continuación, se entrena una secuencia de modelos. <em><strong>El primer modelo se entrena utilizando el primer pliegue como conjunto de prueba, y los pliegues restantes (2-5) se utilizan como conjunto de entrenamiento. El modelo se construye utilizando los datos de los pliegues 2-5, y luego se evalúa accuracy en el pliegue 1</strong></em>.</p></li>
<li><p>A continuación, luego se construye otro modelo, esta vez utilizando el <em><strong>pliegue 2 como conjunto de prueba y los datos de los pliegues 1, 3, 4 y 5 como conjunto de entrenamiento</strong></em>. Este proceso se repite utilizando los pliegues 3, 4 y 5 como conjuntos de prueba. <em><strong>Para cada una de estas cinco divisiones de los datos en conjuntos de entrenamiento y de prueba, calculamos</strong></em> <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>. Al final, hemos recogido cinco valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_cross_validation</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/562d28b67da460fdd1de3a076bf6d3f8c4a24cbde422e043ab6049c7bc5af0ab.png" src="_images/562d28b67da460fdd1de3a076bf6d3f8c4a24cbde422e043ab6049c7bc5af0ab.png" />
</div>
</div>
<ul class="simple">
<li><p>Normalmente, la primera quinta parte de los datos es conocida como el <em><strong>primer fold</strong></em>, la segunda quinta parte de los datos es el
<em><strong>segundo fold</strong></em>, y así sucesivamente.</p></li>
</ul>
<section id="validacion-cruzada-en-scikit-learn">
<h3><span class="section-number">9.1.1. </span>Validación cruzada en scikit-learn<a class="headerlink" href="#validacion-cruzada-en-scikit-learn" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>La validación cruzada se implementa en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> utilizando la función <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">model_selection</span></code>. <em><strong>Los parámetros de la función</strong></em> <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> <em><strong>son, el modelo que queremos evaluar, los datos de entrenamiento y las etiquetas reales</strong></em>. Vamos a evaluar <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code>.</p></li>
<li><p>Utilizaremos los <em><strong>parámetros por defecto de este modelo</strong></em>, más adelante estudiaremos como conseguir los más óptimos por medio de <code class="docutils literal notranslate"><span class="pre">grid-search</span></code>, por ahora solo estamos interesados en <em><strong>evaluar el modelo por defecto usando</strong></em> <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>. Para más información acerca de los argumentos del modelo (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">sklearn.linear_model.LogisticRegression</a>).</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Iris dataset</p>
<ul class="simple">
<li><p><strong>Objetivo Principal</strong>: <em>Predecir la especie de una flor <code class="docutils literal notranslate"><span class="pre">iris</span></code> basándose en medidas de sus características morfológicas</em>. El dataset contiene tres especies de <code class="docutils literal notranslate"><span class="pre">iris</span></code>: <code class="docutils literal notranslate"><span class="pre">setosa</span></code>, <code class="docutils literal notranslate"><span class="pre">versicolor</span></code> y <code class="docutils literal notranslate"><span class="pre">virginica</span></code>, y las características medidas son el largo y el ancho del sépalo y el pétalo.</p></li>
<li><p><em><strong>Uso</strong></em>: Este problema de clasificación permite evaluar la <em>capacidad de un modelo para diferenciar entre las especies basándose en características continuas</em>.</p></li>
</ul>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/iris_dataset.png"><img alt="_images/iris_dataset.png" src="_images/iris_dataset.png" style="width: 700.0px; height: 524.8000000000001px;" />
</a>
</figure>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(150, 4)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(150,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">feature_names</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">feature</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Std: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Min: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Max: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  25th percentile (Q1): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Median (Q2): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  75th percentile (Q3): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>sepal length (cm):
  Mean: 5.843333333333334
  Std: 0.8253012917851409
  Min: 4.3
  Max: 7.9
  25th percentile (Q1): 5.1
  Median (Q2): 5.8
  75th percentile (Q3): 6.4

sepal width (cm):
  Mean: 3.0573333333333337
  Std: 0.4344109677354946
  Min: 2.0
  Max: 4.4
  25th percentile (Q1): 2.8
  Median (Q2): 3.0
  75th percentile (Q3): 3.3

petal length (cm):
  Mean: 3.7580000000000005
  Std: 1.759404065775303
  Min: 1.0
  Max: 6.9
  25th percentile (Q1): 1.6
  Median (Q2): 4.35
  75th percentile (Q3): 5.1

petal width (cm):
  Mean: 1.1993333333333336
  Std: 0.7596926279021594
  Min: 0.1
  Max: 2.5
  25th percentile (Q1): 0.3
  Median (Q2): 1.3
  75th percentile (Q3): 1.8
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Target (species):&quot;</span><span class="p">)</span>
<span class="n">unique</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">iris</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> samples&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target (species):
  setosa: 50 samples
  versicolor: 50 samples
  virginica: 50 samples
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Queda como <em>ejercicio para el estudiante, realizar un EDA exahustivo para el dataset</em>, teniendo en cuenta cada una de las variables y sus categorías. Evaluemos el <em><strong>uso de la función</strong></em> <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">);</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [0.96666667 1.         0.93333333 0.96666667 1.        ]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Por defecto</strong></em>, <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> <em><strong>realiza una</strong></em> <code class="docutils literal notranslate"><span class="pre">five-fold</span> <span class="pre">cross</span> <span class="pre">validation</span></code>, devolviendo cinco valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>. Podemos cambiar el número de pliegues <em><strong>(folds)</strong></em> utilizados, cambiando el parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [1.         0.93333333 1.         1.         0.93333333 0.93333333
 0.93333333 1.         1.         1.        ]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Una forma habitual de <em><strong>resumir la precisión de la validación cruzada es calcular la media</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando la <em><strong>validación cruzada media</strong></em> podemos concluir que, esperamos que el modelo sea de precisión en torno al 97% de media. Si observamos las cinco puntuaciones producidas por la validación cruzada de cinco pliegues <em><strong>five-fold cross validation</strong></em>, también podemos concluir que hay una <em><strong>varianza relativamente alta en la precisión entre pliegues, que va del 100% de precisión al 93.33% de precisión aproximadamente</strong></em>.</p></li>
<li><p>Esto podría implicar que <em><strong><code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">modelo</span> <span class="pre">es</span> <span class="pre">muy</span> <span class="pre">dependiente</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">pliegues</span> <span class="pre">particulares</span> <span class="pre">utilizados</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">entrenamiento</span></code></strong></em>, pero también podría ser simplemente una <em><strong>consecuencia del pequeño tamaño del conjunto de datos</strong></em>. Normalmente, <em><strong>si los resultados de</strong></em> <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> <em><strong>varían considerablemente durante la validación cruzada de 5 pliegues</strong></em>, esto puede indicar <em><strong>problemas en el modelo, en los datos, o en el proceso de validación</strong></em>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Varianza alta de <em>accuracy</em> entre pliegues</p>
<ul class="simple">
<li><p><strong>Varianza en los datos</strong>: Si los datos no están bien distribuidos o existen diferencias significativas entre los pliegues, los resultados de accuracy pueden variar mucho entre cada uno. <em>Esto sucede comúnmente cuando los datos presentan sesgos o cuando ciertos pliegues contienen muestras que son más difíciles de clasificar</em>.</p></li>
<li><p><strong>Modelo inestable o de alta varianza</strong>: Algunos modelos, especialmente los que son complejos o sensibles a los datos de entrenamiento (como los árboles de decisión sin poda o redes neuronales profundas con pocos datos), pueden tener un rendimiento inconsistente en diferentes subconjuntos de los datos. <em>En estos casos, el modelo se ajusta demasiado a los pliegues específicos, produciendo fluctuaciones en el</em> <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>.</p></li>
<li><p><strong>Tamaño de la muestra</strong>: <em>Si el conjunto de datos es pequeño, la variabilidad en los pliegues puede ser mayor, ya que cada subconjunto de datos tiene un peso proporcionalmente alto</em>. En estos casos, la validación cruzada puede reflejar variaciones amplificadas.</p></li>
<li><p><strong>Datos atípicos</strong>: <em>La presencia de datos atípicos (outliers) en algunos de los pliegues puede afectar el</em> <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> <em>y producir resultados más dispares</em>. Es importante revisar si los pliegues contienen estos datos y considerar métodos para manejarlos.</p></li>
</ul>
</div>
</section>
<section id="ventajas-de-la-validacion-cruzada">
<h3><span class="section-number">9.1.2. </span>Ventajas de la validación cruzada<a class="headerlink" href="#ventajas-de-la-validacion-cruzada" title="Link to this heading">#</a></h3>
<div class="important admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p>Son varios los beneficios de utilizar la <em><strong>validación cruzada</strong></em> en lugar de una única división en un conjunto de entrenamiento y otro de prueba. En primer lugar, recuerde que <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code> realiza una división aleatoria de los datos. Imaginemos que <em><strong>tenemos “suerte” al dividir aleatoriamente los datos, y todos los ejemplos que son difíciles de clasificar acaban en el conjunto de entrenamiento</strong></em>.</p></li>
<li><p>En ese caso, <em><strong>el conjunto de prueba sólo contendrá ejemplos “fáciles”, y nuestra precisión en el conjunto de prueba será irrealmente alto</strong></em>. Por el contrario, <em><strong>si tenemos “mala suerte”, es posible que pongamos al azar todos los ejemplos difíciles de clasificar en el conjunto de prueba y en consecuencia, obtener una score irrealmente bajo</strong></em>.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>La <em><strong>validación cruzada garantiza que cada ejemplo esté en el conjunto de prueba una vez, obligando al modelo a generalizar bien en todo el conjunto</strong></em>. Proporciona un rango de precisión que muestra el rendimiento en el mejor y peor caso. A diferencia de dividir una sola vez, <em><strong>la validación cruzada usa más datos para entrenamiento</strong></em> (por ejemplo, 80% en cinco pliegues o 90% en diez pliegues), <em><strong>lo que mejora la precisión</strong></em>. Sin embargo, <em><strong>su desventaja es el mayor coste computacional</strong></em>, ya que se entrenan varios modelos en lugar de uno solo.</p></li>
</ul>
<div class="caution admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p>Es importante tener en cuenta que la <em><strong>validación cruzada no es una forma de construir un modelo que pueda aplicarse a nuevos datos. La validación cruzada no devuelve un modelo</strong></em>.</p></li>
<li><p>Cuando se llama a <code class="docutils literal notranslate"><span class="pre">cross_validation_score</span></code>, se construyen internamente múltiples modelos, pero <em><strong>el propósito de la validación cruzada es evaluar lo bien que un algoritmo determinado generalizará</strong></em> cuando es entrenado en un conjunto de datos específico.</p></li>
</ul>
</div>
</section>
<section id="validacion-cruzada-kfold">
<h3><span class="section-number">9.1.3. </span>Validación cruzada <code class="docutils literal notranslate"><span class="pre">KFold</span></code><a class="headerlink" href="#validacion-cruzada-kfold" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Dividir el conjunto de datos en <code class="docutils literal notranslate"><span class="pre">k</span></code> <em><strong>pliegues</strong></em> comenzando por la primera parte de los datos, como descrito en la sección anterior, <em><strong>puede no ser siempre una buena idea</strong></em>. Por ejemplo, veamos el conjunto de datos <code class="docutils literal notranslate"><span class="pre">iris</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iris labels:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Iris labels:
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Podemos <em><strong>ajustar el número de pliegues en</strong></em> <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code> <em><strong>con el parámetro</strong></em> <code class="docutils literal notranslate"><span class="pre">cv</span></code>. No obstante, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> permite mayor control al aceptar un divisor de validación cruzada como parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code>. Aunque <em><strong>los valores predeterminados suelen ser adecuados, en ciertos casos puede ser útil una estrategia diferente</strong></em>.</p></li>
<li><p>Por ejemplo, para replicar resultados con validación cruzada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> en clasificación, se puede importar la clase <code class="docutils literal notranslate"><span class="pre">KFold</span></code> de <code class="docutils literal notranslate"><span class="pre">model_selection</span></code> e instanciarla con el número deseado de pliegues.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
<span class="n">kfold</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Entonces, podemos pasar el objeto <code class="docutils literal notranslate"><span class="pre">kfold</span> <span class="pre">splitter</span></code> como el parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code> a <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kfold</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0. 0. 0.]
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-estratificada-stratifiedkfold">
<h3><span class="section-number">9.1.4. </span>Validación cruzada estratificada <code class="docutils literal notranslate"><span class="pre">StratifiedKFold</span></code><a class="headerlink" href="#validacion-cruzada-estratificada-stratifiedkfold" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>En este conjunto de datos, el <em><strong>primer tercio corresponde a la clase 0, el segundo a la clase 1 y el último a la clase 2</strong></em>. Al realizar una <em><strong>validación cruzada de 3 pliegues, cada pliegue contendría solo una clase en el conjunto de prueba</strong></em> y <em><strong>las otras dos en el conjunto de entrenamiento</strong></em>. Esto causaría que la precisión fuera del 0%, ya que las clases en entrenamiento y prueba no coincidirían en ninguna división, lo cual es ineficaz para evaluar el modelo.</p></li>
<li><p>Como la estrategia simple de <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> falla aquí, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> <em><strong>no la utiliza para clasificación, sino que utiliza la <code class="docutils literal notranslate"><span class="pre">validación</span> <span class="pre">cruzada</span> <span class="pre">estratificada</span> <span class="pre">k-fold</span></code></strong></em>. En la validación cruzada estratificada, dividimos los datos de forma que las <em><strong>proporciones entre las clases sean las mismas en cada pliegue como en todo el conjunto de datos</strong></em>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_stratified_cross_validation</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/a1ae92a3fa489cdeb77047ffc0bc79117f1e2a5eae09fa40d6b490cfa792ff4b.png" src="_images/a1ae92a3fa489cdeb77047ffc0bc79117f1e2a5eae09fa40d6b490cfa792ff4b.png" />
</div>
</div>
<ul class="simple">
<li><p>La validación cruzada estratificada de <code class="docutils literal notranslate"><span class="pre">k</span></code> pliegues <strong><code class="docutils literal notranslate"><span class="pre">distribuye</span> <span class="pre">las</span> <span class="pre">clases</span> <span class="pre">en</span> <span class="pre">cada</span> <span class="pre">pliegue</span> <span class="pre">según</span> <span class="pre">su</span> <span class="pre">proporción</span> <span class="pre">en</span> <span class="pre">el</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos,</span> <span class="pre">evitando</span> <span class="pre">que</span> <span class="pre">un</span> <span class="pre">pliegue</span> <span class="pre">carezca</span> <span class="pre">de</span> <span class="pre">muestras</span> <span class="pre">de</span> <span class="pre">alguna</span> <span class="pre">clase</span></code></strong>. Esto ofrece <em><strong>estimaciones más fiables del rendimiento del clasificador</strong></em> en comparación con la validación cruzada estándar de <code class="docutils literal notranslate"><span class="pre">k</span></code> pliegues, especialmente en conjuntos de datos desbalanceados.</p></li>
<li><p>Para la regresión, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> utiliza la validación cruzada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> estándar por defecto. Sería posible también tratar de hacer cada pliegue representativo de los diferentes valores objetivo de la regresión, pero esta no es una estrategia comúnmente utilizada.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">StratifiedKFold</span>
<span class="n">stratified_kfold</span> <span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">stratified_kfold</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0.98 0.96 0.98]
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-shuffle-kfold">
<h3><span class="section-number">9.1.5. </span>Validación cruzada <code class="docutils literal notranslate"><span class="pre">shuffle</span> <span class="pre">KFold</span></code><a class="headerlink" href="#validacion-cruzada-shuffle-kfold" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Usar <em><strong>validación cruzada triple (no estratificada) en el conjunto de datos iris es ineficaz</strong></em>, ya que cada pliegue corresponde a una clase, impidiendo el aprendizaje. Para evitarlo, <strong>se recomienda aleatorizar los datos en lugar de estratificarlos, configurando</strong> <code class="docutils literal notranslate"><span class="pre">shuffle=True</span></code> en <code class="docutils literal notranslate"><span class="pre">KFold</span></code> <em><strong>y fijando</strong></em> <code class="docutils literal notranslate"><span class="pre">random_state</span></code> para obtener resultados reproducibles. Esta aleatorización mejora significativamente los resultados.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kfold</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kfold</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:
[0.98 0.96 0.96]
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-con-exclusion-leave-one-out">
<h3><span class="section-number">9.1.6. </span>Validación cruzada con exclusión <code class="docutils literal notranslate"><span class="pre">leave-one-out</span></code><a class="headerlink" href="#validacion-cruzada-con-exclusion-leave-one-out" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>El método de <em><strong>validación cruzada</strong></em> <code class="docutils literal notranslate"><span class="pre">leave-one-out</span></code> <em><strong>es una variante de</strong></em> <code class="docutils literal notranslate"><span class="pre">k</span></code> <em><strong>pliegues</strong></em> donde <em><strong>cada pliegue de prueba contiene solo una muestra</strong></em>. Aunque es más lento en conjuntos de datos grandes, puede ofrecer <em><strong><code class="docutils literal notranslate"><span class="pre">mejores</span> <span class="pre">estimaciones</span> <span class="pre">en</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">pequeños</span></code></strong></em>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">LeaveOneOut</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">loo</span> <span class="o">=</span> <span class="n">LeaveOneOut</span><span class="p">()</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">loo</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of cv iterations: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of cv iterations:  150
Mean accuracy: 0.97
</pre></div>
</div>
</div>
</div>
</section>
<section id="validacion-cruzada-aleatoria-y-divididashufflesplit">
<h3><span class="section-number">9.1.7. </span>Validación cruzada aleatoria y dividida<code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code><a class="headerlink" href="#validacion-cruzada-aleatoria-y-divididashufflesplit" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Otra estrategia muy flexible para la validación cruzada es <em><strong>la validación cruzada aleatoria</strong></em> (<code class="docutils literal notranslate"><span class="pre">shuffle-split</span> <span class="pre">cross-validation</span></code>). En la validación cruzada de división aleatoria, cada división (<code class="docutils literal notranslate"><span class="pre">split</span></code>) está compuesta de tantos <code class="docutils literal notranslate"><span class="pre">train_size</span></code> <em><strong>puntos (disyuntos)</strong></em> para el conjunto de entrenamiento y tantos <code class="docutils literal notranslate"><span class="pre">test_size</span></code> <em><strong>puntos (disjuntos)</strong></em> para el conjunto de prueba, se fijen inicialmente.</p></li>
<li><p>Esta división se repite <code class="docutils literal notranslate"><span class="pre">n_iter</span></code> veces, de forma aleatoria. A continuación se muestra <em><strong>la ejecución de cuatro iteraciones de división de un conjunto de datos que consta de <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">puntos</span></code>, con un conjunto de entrenamiento de <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">puntos</span></code> y conjuntos de prueba de <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">puntos</span></code> cada uno</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_shuffle_split</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2f251b3cf0f1cf97660350cef8dd23b09de186e0938347df2faf782915f99081.png" src="_images/2f251b3cf0f1cf97660350cef8dd23b09de186e0938347df2faf782915f99081.png" />
</div>
</div>
<ul class="simple">
<li><p><em>Puede usar enteros para <code class="docutils literal notranslate"><span class="pre">train_size</span></code> y <code class="docutils literal notranslate"><span class="pre">test_size</span></code> para asignarles sus tamaños absolutos, o números de tipo flotante para usar fracciones del conjunto de datos</em>. El siguiente código divide el conjunto de datos en un <em><strong>50% de entrenamiento y un 50% de prueba para 10 iteraciones</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">ShuffleSplit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shuffle_split</span> <span class="o">=</span> <span class="n">ShuffleSplit</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">shuffle_split</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores with partial coverage of the dataset:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores with partial coverage of the dataset:
 [0.85 0.85 0.95 0.85 0.5  0.9  0.85 0.85 0.95 0.75]
Mean score: 0.830
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La <em><strong>validación cruzada aleatoria permite ajustar el número de iteraciones y <code class="docutils literal notranslate"><span class="pre">usar</span> <span class="pre">solo</span> <span class="pre">una</span> <span class="pre">parte</span> <span class="pre">de</span> <span class="pre">los</span> <span class="pre">datos</span> <span class="pre">en</span> <span class="pre">cada</span> <span class="pre">iteración,</span> <span class="pre">lo</span> <span class="pre">cual</span> <span class="pre">es</span> <span class="pre">útil</span> <span class="pre">para</span> <span class="pre">grandes</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">datos</span></code></strong></em>. La variante estratificada, <code class="docutils literal notranslate"><span class="pre">StratifiedShuffleSplit</span></code>, <em><strong>ofrece resultados más fiables en tareas de clasificación</strong></em>.</p></li>
</ul>
</section>
<section id="validacion-cruzada-por-grupos-groupkfold">
<h3><span class="section-number">9.1.8. </span>Validación cruzada por grupos <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code><a class="headerlink" href="#validacion-cruzada-por-grupos-groupkfold" title="Link to this heading">#</a></h3>
<div class="admonition-groupkfold admonition">
<p class="admonition-title">GroupKFold</p>
<ul class="simple">
<li><p>Digamos que quieres construir un sistema para <em><strong>reconocer emociones a partir de imágenes de rostros (o imágenes médicas)</strong></em>, y se recopila un conjunto de datos con imágenes de 100 personas, donde cada persona es capturada varias veces, mostrando varias emociones.</p></li>
<li><p>El objetivo es construir un clasificador que pueda <em><strong>identificar correctamente las emociones de las personas que no están en el conjunto de datos</strong></em>. <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code> es una variación de <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> que <em><strong>garantiza que el mismo grupo no esté representado en los conjuntos de prueba y de entrenamiento</strong></em>.</p></li>
</ul>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p>La validación cruzada estratificada puede medir el rendimiento de un clasificador, pero <em><strong>si hay imágenes de la misma persona en los conjuntos de entrenamiento y prueba, el modelo reconocerá más fácilmente emociones en rostros ya vistos</strong></em>. Para <em><strong>evaluar mejor la generalización a nuevas caras, es recomendable usar</strong></em> <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code>, que permite <em><strong><code class="docutils literal notranslate"><span class="pre">separar</span> <span class="pre">las</span> <span class="pre">imágenes</span> <span class="pre">por</span> <span class="pre">persona</span> <span class="pre">en</span> <span class="pre">los</span> <span class="pre">conjuntos</span> <span class="pre">de</span> <span class="pre">entrenamiento</span> <span class="pre">y</span> <span class="pre">prueba</span></code></strong></em>.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>Este ejemplo ilustra cómo aplicar validación cruzada por grupos usando <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code>, asegurando que las <strong>observaciones de un mismo grupo no se mezclen entre entrenamiento y prueba</strong>. Se usa un conjunto sintético de 12 datos divididos en 4 grupos, <strong>ideal para evitar fugas de información en contextos donde los datos están agrupados</strong> (como pacientes o dispositivos).</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GroupKFold</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dataset sintético con <strong>12 muestras y 4 grupos</strong> (pacientes)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>     <span class="c1"># Paciente 0</span>
          <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Paciente 1</span>
          <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>        <span class="c1"># Paciente 2</span>
          <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>     <span class="c1"># Paciente 3</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gkf</span> <span class="o">=</span> <span class="n">GroupKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fold</span><span class="p">,</span> <span class="p">(</span><span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gkf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">groups</span><span class="p">)):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">train_idx</span><span class="p">])</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">test_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_idx</span><span class="p">])</span>
    
    <span class="n">train_groups</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)[</span><span class="n">train_idx</span><span class="p">])</span>
    <span class="n">test_groups</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)[</span><span class="n">test_idx</span><span class="p">])</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fold </span><span class="si">{</span><span class="n">fold</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train indices: </span><span class="si">{</span><span class="n">train_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test indices:  </span><span class="si">{</span><span class="n">test_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train groups:  </span><span class="si">{</span><span class="n">train_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test groups:   </span><span class="si">{</span><span class="n">test_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Score:         </span><span class="si">{</span><span class="n">score</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fold 1
Train indices: [ 0  1  2  7  8  9 10 11]
Test indices:  [3 4 5 6]
Train groups:  {0, 2, 3}
Test groups:   {1}
Score:         0.75

Fold 2
Train indices: [0 1 2 3 4 5 6]
Test indices:  [ 7  8  9 10 11]
Train groups:  {0, 1}
Test groups:   {2, 3}
Score:         0.40

Fold 3
Train indices: [ 3  4  5  6  7  8  9 10 11]
Test indices:  [0 1 2]
Train groups:  {1, 2, 3}
Test groups:   {0}
Score:         0.67
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><strong>Como puede ver, para cada división, cada grupo está completamente en el conjunto de entrenamiento o completamente en el conjunto de prueba</strong>. Además, <em>observe que los pliegues no tienen exactamente el mismo tamaño debido al desequilibrio de los datos</em>.</p></li>
<li><p>Hay más estrategias de división para la validación cruzada en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, que pueden utilizarse para una variedad aún mayor de casos (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/cross_validation.html">Cross-validation: evaluating estimator performance</a>). Sin embargo, el <code class="docutils literal notranslate"><span class="pre">KFold</span></code> estándar, el <code class="docutils literal notranslate"><span class="pre">StratifiedKFold</span></code> y el <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code> son, como mucho, los más utilizados. En el siguiente link puede encontrar la documentación relacionada con el uso de cada parámetro de la función <code class="docutils literal notranslate"><span class="pre">sklearn.model_selection.cross_val_score</span></code> (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_score.html">Evaluate a score by cross-validation</a>).</p></li>
</ul>
</section>
</section>
<section id="grid-search">
<h2><span class="section-number">9.2. </span>Grid Search<a class="headerlink" href="#grid-search" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Ahora que sabemos cómo evaluar el grado de generalización de un modelo, podemos dar el siguiente paso y <em><strong>mejorar el rendimiento de la generalización del modelo ajustando sus parámetros</strong></em>. Es importante <em><strong>entender lo que significan los parámetros antes de intentar ajustarlos</strong></em>. Encontrar los valores de los parámetros relevantes de un modelo (<em><strong>los que proporcionan el mejor rendimiento de generalización</strong></em>) es una tarea complicada, pero necesaria para casi todos los modelos y conjuntos de datos.</p></li>
<li><p>Al ser una tarea tan común, existen métodos estándar en <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> para ayudarle con ello. El método más utilizado es la <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code>, que básicamente significa <em><strong>probar todas las combinaciones posibles de los parámetros de interés</strong></em>. Considere el caso de un SVM con un <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">RBF</span></code> (función de base radial), como implementado en la clase <code class="docutils literal notranslate"><span class="pre">SVC</span></code>. Hay dos parámetros importantes: el <em><strong>ancho de banda del kernel</strong></em>, <code class="docutils literal notranslate"><span class="pre">gamma</span></code>, y el <em><strong>parámetro de regularización</strong></em>, <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p></li>
<li><p>Digamos que queremos probar los valores <em><strong>0.001, 0.01, 0.1, 1, 10 y 100 para el parámetro</strong></em> <code class="docutils literal notranslate"><span class="pre">C</span></code>, <em><strong>y lo mismo para</strong></em> <code class="docutils literal notranslate"><span class="pre">gamma</span></code>. Como tenemos seis ajustes diferentes para <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code> que queremos probar, tenemos <em><strong>36 combinaciones de parámetros en total</strong></em>. Al ver todas las combinaciones posibles, <em><strong>se crea una tabla (o red) de parámetros para</strong></em> `SVM, como se muestra aquí:</p></li>
</ul>
<figure class="align-center" id="grid-search-svm">
<a class="reference internal image-reference" href="_images/grid_search_svm.png"><img alt="_images/grid_search_svm.png" src="_images/grid_search_svm.png" style="width: 698.5999999999999px; height: 138.6px;" />
</a>
</figure>
<section id="grid-search-simple">
<h3><span class="section-number">9.2.1. </span>Grid Search simple<a class="headerlink" href="#grid-search-simple" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Podemos implementar un <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> sobre los dos parámetros usando un par de <em><strong>ciclos for</strong></em>, entrenando y evaluando un clasificador para cada combinación</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of training set: </span><span class="si">{}</span><span class="s2"> size of test set: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">best_score</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Size of training set: 112 size of test set: 38
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
        <span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_score</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_parameters</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best score: 0.97
Best parameters: {&#39;C&#39;: 100, &#39;gamma&#39;: 0.001}
</pre></div>
</div>
</div>
</div>
</section>
<section id="el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">
<h3><span class="section-number">9.2.2. </span>El peligro de sobreajustar los parámetros y el conjunto de validación<a class="headerlink" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Teniendo en cuenta este resultado, podríamos tener la <em><strong>tentación de decir que hemos encontrado un modelo que funciona con un 97% de precisión</strong></em> en nuestro conjunto de datos. Sin embargo, esta afirmación podría ser demasiado optimista (o simplemente errónea), por la siguiente razón: <em><strong>hemos probado muchos parámetros diferentes y se seleccionó el que tenía la mejor precisión en el conjunto de prueba, pero <code class="docutils literal notranslate"><span class="pre">esta</span> <span class="pre">precisión</span> <span class="pre">no</span> <span class="pre">necesariamente</span> <span class="pre">la</span> <span class="pre">obtendremos</span> <span class="pre">con</span> <span class="pre">nuevos</span> <span class="pre">datos</span></code></strong></em>.</p></li>
<li><p><em><strong>Como hemos utilizado los datos de prueba para ajustar los parámetros, ya no podemos utilizarlos para evaluar la calidad del modelo</strong></em>. Esta es la misma razón por la que necesitamos dividir los datos en conjuntos de entrenamiento y de prueba; <em><strong><code class="docutils literal notranslate"><span class="pre">necesitamos</span> <span class="pre">un</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">datos</span> <span class="pre">independiente</span> <span class="pre">para</span> <span class="pre">evaluar,</span> <span class="pre">uno</span> <span class="pre">que</span> <span class="pre">no</span> <span class="pre">se</span> <span class="pre">haya</span> <span class="pre">utilizado</span> <span class="pre">para</span> <span class="pre">crear</span> <span class="pre">el</span> <span class="pre">modelo</span></code></strong></em>.</p></li>
<li><p>Una forma de resolver este problema es <em><strong>dividir los datos de nuevo, de modo que tengamos tres conjuntos</strong></em>: el <em><strong>conjunto de entrenamiento</strong></em> para construir el modelo, el <em><strong>conjunto de validación</strong></em> (o desarrollo) para seleccionar los parámetros del modelo, y el <em><strong>conjunto de prueba</strong></em> para evaluar el rendimiento de los parámetros seleccionados</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_threefold_split</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/5501ff7c3f118d14e38402fdccef8cfd7743bf2bf85eea65afe759ef3f2c9cf0.png" src="_images/5501ff7c3f118d14e38402fdccef8cfd7743bf2bf85eea65afe759ef3f2c9cf0.png" />
</div>
</div>
<ul class="simple">
<li><p>Después de seleccionar los mejores parámetros utilizando el <em><strong>conjunto de validación</strong></em>, podemos <em><strong>reconstruir un modelo utilizando los parámetros ajustados</strong></em> que encontramos, pero ahora <em><strong>entrenado tanto en los datos de entrenamiento y los datos de validación</strong></em>. De esta forma, podemos utilizar tantos datos como sea posible para construir nuestro modelo. Esto nos lleva a la siguiente implementación</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dividimos los datos en conjunto de <em><strong>entrenamiento+validación</strong></em> y conjunto de <em><strong>prueba</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Dividimos el conjunto de <em><strong>entrenamiento+validación</strong></em> en conjuntos de <em><strong>entrenamiento</strong></em> y <em><strong>validación</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_valid</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of training set: </span><span class="si">{}</span><span class="s2"> size of validation set: </span><span class="si">{}</span><span class="s2"> size of test set: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
      <span class="nb">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_valid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Size of training set: 84 size of validation set: 28 size of test set: 38
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">best_score</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
        <span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span> <span class="c1"># Ajuste del modelo SVC</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">)</span> <span class="c1"># Score para selección de parámetros</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span> <span class="c1"># Almacenamos el mejor score y sus parámetros</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Reconstruimos el modelo en el conjunto combinado de entrenamiento y validación</strong></em>, y lo <em><strong>evaluamos en el conjunto de prueba</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="o">**</span><span class="n">best_parameters</span><span class="p">)</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">)</span>
<span class="n">test_score</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best score on validation set: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_score</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: &quot;</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score with best parameters: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_score</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best score on validation set: 0.96
Best parameters:  {&#39;C&#39;: 10, &#39;gamma&#39;: 0.001}
Test set score with best parameters: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>El mejor score en el conjunto de validación es del 96%</strong></em>: ligeramente inferior a la anterior, probablemente porque utilizamos menos datos para entrenar el modelo (<em><strong>X_train es menor ahora porque dividimos nuestro conjunto de datos dos veces</strong></em>). Sin embargo, el score en el conjunto de prueba, el que realmente nos dice que tan buena es la generalización, es aún más bajo, un 92%. Así que <em><strong>solo podemos afirmar que clasificamos los nuevos datos con un 92% de acierto, y no con un 97% como pensábamos antes</strong></em>.</p></li>
<li><p><em><strong>La distinción entre el conjunto de entrenamiento, el conjunto de validación y el conjunto de prueba es fundamentalmente importante</strong></em> para aplicar los métodos de aprendizaje automático en la práctica. <em><strong>Cualquier decisión tomada basada en la precisión del conjunto de prueba <code class="docutils literal notranslate"><span class="pre">“filtra”</span> <span class="pre">información</span> <span class="pre">del</span> <span class="pre">conjunto</span> <span class="pre">de</span> <span class="pre">prueba</span> <span class="pre">al</span> <span class="pre">modelo</span></code></strong></em>. Por lo tanto, es fundamental mantener un conjunto de prueba separado, que solo se utiliza para la evaluación final.</p></li>
<li><p>Es una buena práctica <em><strong>realizar todo el análisis exploratorio (EDA) y la selección del modelo utilizando la combinación de entrenamiento y validación, y reservar el conjunto de prueba para la evaluación final</strong></em>, incluso en el caso de la visualización exploratoria. En sentido estricto, <em><strong>evaluar más de un modelo en el conjunto de prueba y elegir el mejor de los dos resultará en una estimación demasiado optimista</strong></em> de la precisión del modelo.</p></li>
</ul>
</section>
<section id="grid-search-con-validacion-cruzada">
<h3><span class="section-number">9.2.3. </span>Grid Search con validación cruzada<a class="headerlink" href="#grid-search-con-validacion-cruzada" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><em><strong>Aunque el método de dividir los datos en un conjunto de entrenamiento, uno de validación y otro de prueba que acabamos de ver es factible y se utiliza con relativa frecuencia, es bastante sensible a la forma en que se dividen los datos</strong></em>. De la salida del fragmento de código anterior podemos ver que el <code class="docutils literal notranslate"><span class="pre">grid-search</span></code> selecciona <code class="docutils literal notranslate"><span class="pre">'C':</span> <span class="pre">10,</span> <span class="pre">'gamma':</span> <span class="pre">0.001</span></code>, como los mejores parámetros, mientras que la salida del código de la sección anterior selecciona <code class="docutils literal notranslate"><span class="pre">'C':</span> <span class="pre">100,</span> <span class="pre">'gamma':</span> <span class="pre">0.001</span></code> como los mejores parámetros.</p></li>
<li><p>Para una mejor estimación del rendimiento de la generalización, <em><strong>en lugar de usar una única división en un conjunto de entrenamiento y otro de validación, podemos usar la validación cruzada para evaluar el rendimiento de cada combinación de parámetros</strong></em>. Este método puede codificarse como sigue:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
        <span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span> <span class="c1"># Entrena SVC para cada parámetro</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">svm</span><span class="p">,</span> <span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># Calcula validación cruzada</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="c1"># Calcula media de la validación cruzada para precisión</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">best_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><em><strong>Reconstruimos el modelo en el conjunto combinado de entrenamiento y validación</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="o">**</span><span class="n">best_parameters</span><span class="p">)</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-1 {color: black;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>SVC(C=10, gamma=0.1)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">SVC</label><div class="sk-toggleable__content"><pre>SVC(C=10, gamma=0.1)</pre></div></div></div></div></div></div></div>
</div>
<ul class="simple">
<li><p>Para evaluar la precisión de <code class="docutils literal notranslate"><span class="pre">SVM</span></code> utilizando un ajuste particular de <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code> con <code class="docutils literal notranslate"><span class="pre">5-fold</span></code> validación cruzada, necesitamos entrenar <em><strong>36 * 5 = 180 modelos</strong></em>. Como puede imaginarse el <em><strong>principal inconveniente del uso de la validación cruzada es el tiempo que lleva entrenar todos estos modelos</strong></em>. La siguiente visualización ilustra cómo se selecciona la mejor configuración de parámetros en el código anterior</p></li>
</ul>
<figure class="align-center" id="best-params-cv">
<img alt="_images/best_params_cv.png" src="_images/best_params_cv.png" />
</figure>
<ul class="simple">
<li><p>Para cada ajuste de parámetros (sólo se muestra un subconjunto), <em><strong>se calculan cinco valores de precisión</strong></em>, uno para cada división en la validación cruzada. A continuación, <em><strong>se calcula la precisión media</strong></em> de la validación para cada parámetro. <em><strong>Se eligen los parámetros con la mayor precisión media de validación, marcados con un círculo</strong></em>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Como hemos dicho antes, <em><strong>la validación cruzada es una forma de evaluar un determinado algoritmo en un conjunto de datos específico</strong></em>. Sin embargo, a menudo se utiliza junto con métodos de búsqueda de parámetros como <code class="docutils literal notranslate"><span class="pre">Grid</span> <span class="pre">Search</span></code>. Por esta razón, normalmente se utiliza el término <em><strong>validación cruzada</strong></em> coloquialmente para referirse a un <code class="docutils literal notranslate"><span class="pre">Grid</span> <span class="pre">Search</span></code> con <em><strong>validación cruzada</strong></em>.</p>
</div>
<ul class="simple">
<li><p>El proceso general de división de los datos, la ejecución de <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> y la evaluación de los parámetros finales se ilustra en la siguiente figura</p></li>
</ul>
<figure class="align-center" id="kfold-validation">
<a class="reference internal image-reference" href="_images/kfold_validation.png"><img alt="_images/kfold_validation.png" src="_images/kfold_validation.png" style="width: 525.0px; height: 351.4px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 9.1 </span><span class="caption-text">Resumen del proceso de selección de parámetros y evaluación de modelos con <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>.</span><a class="headerlink" href="#kfold-validation" title="Link to this image">#</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>Debido a que <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> con <em><strong>validación cruzada</strong></em> es un método tan comúnmente utilizado para ajustar parámetros, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> proporciona la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, que lo implementa en la forma de un estimador. Para utilizar la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, primero hay que especificar los parámetros sobre los que se quiere buscar utilizando un <em><strong>diccionario</strong></em>.</p></li>
<li><p>A continuación, <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> realizará todos los ajustes necesarios del modelo. Las <em><strong>claves</strong></em> (keys) del diccionario son los <em><strong>nombres de los parámetros que queremos ajustar</strong></em> (tal y como se indican cuando se construye el modelo, en este caso, <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code>), y los <em><strong>valores</strong></em> (values) son los ajustes de los parámetros que queremos probar. Probar los valores <em><strong>0,001, 0,01, 0,1, 1, 10 y 100 para</strong></em> <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code> se traduce en lo siguiente diccionario</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parameter grid:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Parameter grid:
{&#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100], &#39;gamma&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Ahora podemos instanciar la clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> con el modelo <code class="docutils literal notranslate"><span class="pre">(SVC)</span></code>, el parámetro a buscar (<code class="docutils literal notranslate"><span class="pre">param_grid</span></code>), y la estrategia de validación cruzada que queremos utilizar (digamos <em><strong>validación cruzada estratificada 5-fold</strong></em>):</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> utilizará la validación cruzada en lugar de la división en un conjunto de entrenamiento y de prueba que utilizábamos antes. <em><strong>Sin embargo, todavía tenemos que dividir los datos en un conjunto de entrenamiento y otro de prueba, para evitar el sobreajuste de los parámetros</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El objeto <code class="docutils literal notranslate"><span class="pre">grid_search</span></code> que hemos creado <em><strong>se comporta como un clasificador</strong></em>; podemos llamar a los métodos estándar <code class="docutils literal notranslate"><span class="pre">fit,</span> <span class="pre">predict</span></code> y <code class="docutils literal notranslate"><span class="pre">score</span></code>. Sin embargo, <em><strong>cuando llamamos a fit, se ejecutará una validación cruzada para cada combinación de parámetros que hayamos especificado</strong></em> en <code class="docutils literal notranslate"><span class="pre">param_grid</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-2 {color: black;}#sk-container-id-2 pre{padding: 0;}#sk-container-id-2 div.sk-toggleable {background-color: white;}#sk-container-id-2 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-2 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-2 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-2 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-2 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-2 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-2 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-2 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-2 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-2 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-2 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-2 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-2 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-2 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-2 div.sk-item {position: relative;z-index: 1;}#sk-container-id-2 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-2 div.sk-item::before, #sk-container-id-2 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-2 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-2 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-2 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-2 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-2 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-2 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-2 div.sk-label-container {text-align: center;}#sk-container-id-2 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-2 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-2" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>GridSearchCV(cv=5, estimator=SVC(),
             param_grid={&#x27;C&#x27;: [0.001, 0.01, 0.1, 1, 10, 100],
                         &#x27;gamma&#x27;: [0.001, 0.01, 0.1, 1, 10, 100]})</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">GridSearchCV</label><div class="sk-toggleable__content"><pre>GridSearchCV(cv=5, estimator=SVC(),
             param_grid={&#x27;C&#x27;: [0.001, 0.01, 0.1, 1, 10, 100],
                         &#x27;gamma&#x27;: [0.001, 0.01, 0.1, 1, 10, 100]})</pre></div></div></div><div class="sk-parallel"><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">estimator: SVC</label><div class="sk-toggleable__content"><pre>SVC()</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-4" type="checkbox" ><label for="sk-estimator-id-4" class="sk-toggleable__label sk-toggleable__label-arrow">SVC</label><div class="sk-toggleable__content"><pre>SVC()</pre></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<ul class="simple">
<li><p>El objeto <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> no solo busca los mejores parámetros, sino que también automáticamente un <em><strong>nuevo modelo en todo el conjunto de datos de entrenamiento con los parámetros que han dado el mejor rendimiento en la validación cruzada</strong></em>. La clase <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> proporciona una interfaz muy conveniente para acceder al modelo reentrenado utilizando los métodos <code class="docutils literal notranslate"><span class="pre">predict</span></code> y <code class="docutils literal notranslate"><span class="pre">score</span></code>. Para <em><strong>evaluar lo bien que generalizan los mejores parámetros encontrados</strong></em>, podemos llamar a <code class="docutils literal notranslate"><span class="pre">score</span></code> en el conjunto de prueba</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Al elegir los parámetros mediante la validación cruzada, <em><strong>encontramos un modelo que alcanza el 97% de precisión en el conjunto de prueba</strong></em>. <em><strong>Lo importante aquí es que no utilizamos el conjunto de prueba para elegir los parámetros</strong></em>. Los parámetros encontrados se anotan en el atributo <code class="docutils literal notranslate"><span class="pre">best_params_</span></code> y la mejor precisión de la validación cruzada (la precisión media sobre las diferentes divisiones para esta configuración de parámetros) se almacena en <code class="docutils literal notranslate"><span class="pre">best_score_</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best parameters: {&#39;C&#39;: 10, &#39;gamma&#39;: 0.1}
Best cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>De nuevo, tenga cuidado de no confundir <code class="docutils literal notranslate"><span class="pre">best_score_</span></code> con el rendimiento de generalización del modelo calculado por el método score en el conjunto de prueba. El uso del método score (o la evaluación de la salida del método de predicción) emplea un modelo entrenado en todo el conjunto de entrenamiento. <em><strong>El atributo</strong></em> <code class="docutils literal notranslate"><span class="pre">best_score_</span></code> <em><strong>almacena la precisión media de la validación cruzada, con la validación cruzada realizada en el conjunto de entrenamiento</strong></em>.</p>
</div>
<ul class="simple">
<li><p>A veces es útil tener <em><strong>acceso al modelo real que se encontró</strong></em>, por ejemplo, para ver los <em><strong>coeficientes o la importancia de las características</strong></em>. Puede acceder al modelo con los mejores parámetros entrenados en todo el conjunto de entrenamiento utilizando el atributo <code class="docutils literal notranslate"><span class="pre">best_estimator_</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best estimator:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best estimator:
SVC(C=10, gamma=0.1)
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como el propio <code class="docutils literal notranslate"><span class="pre">grid_search</span></code> tiene métodos de predicción y score, no es necesario utilizar <code class="docutils literal notranslate"><span class="pre">best_estimator_</span></code> para hacer predicciones o evaluar el modelo.</p></li>
</ul>
</section>
<section id="analisis-del-resultado-de-la-validacion-cruzada">
<h3><span class="section-number">9.2.4. </span>Análisis del resultado de la validación cruzada<a class="headerlink" href="#analisis-del-resultado-de-la-validacion-cruzada" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>A menudo es útil visualizar los resultados de la validación cruzada, para entender cómo la generalización del modelo depende de los parámetros que estamos buscando. Como los <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> son bastante costosos desde el punto de vista computacional, <em><strong>a menudo es una buena idea empezar con grids de múltiples medidas, ya sean grandes o pequeños</strong></em>.</p></li>
<li><p>A continuación, podemos inspeccionar los resultados del <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> validado, y posiblemente ampliar nuestra búsqueda. Los resultados de un <code class="docutils literal notranslate"><span class="pre">grid</span> <span class="pre">search</span></code> se pueden encontrar en el atributo <code class="docutils literal notranslate"><span class="pre">cv_results_</span></code>, que es un diccionario que almacena todos los aspectos de la búsqueda. Este contiene muchos detalles, como se puede ver en la siguiente salida, y es mejor verlo después de convertirlo en un <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> de <code class="docutils literal notranslate"><span class="pre">pandas</span></code>.</p></li>
<li><p>Mostramos solo algunas columnas, para que se puedan diferenciar en el <em>jbook</em>, pero en su máquina puede visualizarla todas usando la orden <code class="docutils literal notranslate"><span class="pre">results.head()</span></code>. <code class="docutils literal notranslate"><span class="pre">GridSearchCV.cv_results_</span></code> incluye los <em><strong>resultados de tiempo para scoring y ajuste de parámetros en cada pliegue</strong></em>. Por ejemplo <code class="docutils literal notranslate"><span class="pre">mean_score_time</span></code> es la cantidad media de tiempo que se necesita para scoring en los datos de cada pliegue <code class="docutils literal notranslate"><span class="pre">cv</span></code>, para cada conjunto de parámetros que definió en el <code class="docutils literal notranslate"><span class="pre">grid-search</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">)</span>
<span class="n">results</span><span class="p">[[</span><span class="s1">&#39;mean_fit_time&#39;</span><span class="p">,</span> <span class="s1">&#39;std_fit_time&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_score_time&#39;</span><span class="p">,</span>
         <span class="s1">&#39;std_score_time&#39;</span><span class="p">,</span> <span class="s1">&#39;param_C&#39;</span><span class="p">,</span> <span class="s1">&#39;param_gamma&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mean_fit_time</th>
      <th>std_fit_time</th>
      <th>mean_score_time</th>
      <th>std_score_time</th>
      <th>param_C</th>
      <th>param_gamma</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000562</td>
      <td>0.000246</td>
      <td>0.000291</td>
      <td>0.000039</td>
      <td>0.001</td>
      <td>0.001</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.000412</td>
      <td>0.000009</td>
      <td>0.000274</td>
      <td>0.000050</td>
      <td>0.001</td>
      <td>0.01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000417</td>
      <td>0.000013</td>
      <td>0.000235</td>
      <td>0.000008</td>
      <td>0.001</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.000414</td>
      <td>0.000009</td>
      <td>0.000230</td>
      <td>0.000003</td>
      <td>0.001</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.000426</td>
      <td>0.000027</td>
      <td>0.000239</td>
      <td>0.000013</td>
      <td>0.001</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<ul class="simple">
<li><p>Cada fila de resultados corresponde a un ajuste de parámetros concreto. <em><strong>Para cada ajuste, se registran los resultados de todas las divisiones de validación cruzada, así como la media y la desviación estándar de todas las divisiones</strong></em>. Como buscamos una red bidimensional de parámetros (<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code>), esto se visualiza mejor como un <em><strong>mapa de calor</strong></em>. Primero <em><strong>extraemos las puntuaciones medias de la validación</strong></em> y luego las reformamos para que los ejes correspondan a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">mean_test_score</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> 
            <span class="n">xticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Grid Search Scores&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e5851044dd7ebb11b33753fc3202dd9236a2bceb6760b34214077bda892f1d57.png" src="_images/e5851044dd7ebb11b33753fc3202dd9236a2bceb6760b34214077bda892f1d57.png" />
</div>
</div>
<ul class="simple">
<li><p>Cada punto del mapa de calor corresponde a una ejecución de validación cruzada, con un parámetro en particular. <em><strong>El color codifica la precisión de la validación cruzada</strong></em>, siendo los colores claros los relacionados con alta precisión y los colores oscuros con baja precisión. Se puede ver que <em><strong>SVC es muy sensible a la configuración de los parámetros</strong></em>. Para muchos de los ajustes de los parámetros, la precisión está en torno al 37%, lo que es bastante malo; para otros ajustes, la precisión está en torno al 96%.</p></li>
<li><p>De este gráfico se desprenden varias cosas. En primer lugar, <em><strong>los parámetros que ajustamos son muy importantes para obtener un buen rendimiento</strong></em>. Ambos parámetros <em><strong>(C y gamma)</strong></em> son muy importantes, ya que su ajuste puede cambiar la precisión del 37% al 96%. Además, <em><strong>los rangos que elegimos para los parámetros son rangos en los que vemos cambios significativos en el resultado</strong></em>. También es importante tener en cuenta que <em><strong>los rangos de los parámetros son lo suficientemente amplios: los valores óptimos de cada parámetro no están en los bordes del gráfico</strong></em>.</p></li>
<li><p>Veamos algunos gráficos en los que <em><strong>el resultado es menos ideal</strong></em>, porque los rangos de búsqueda no fueron elegidos correctamente</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">import</span> <span class="nn">mglearn</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Definir los grids de hiperparámetros</span>
<span class="n">param_grid_linear</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">param_grid_one_log</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">param_grid_range</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="k">for</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">param_grid_linear</span><span class="p">,</span> <span class="n">param_grid_one_log</span><span class="p">,</span> <span class="n">param_grid_range</span><span class="p">],</span> <span class="n">axes</span><span class="p">):</span>
    <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">[</span><span class="s1">&#39;mean_test_score&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format_tick</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Formatea el número con notación científica si tiene más de 4 cifras decimales&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.001</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">xticklabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_tick</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]]</span>
    <span class="n">yticklabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_tick</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]]</span>

    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">xticklabels</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">yticklabels</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b49dd78dad4899c6e2859f830e2c52ac1035f8a3f4aa99474dd4b90f2173af16.png" src="_images/b49dd78dad4899c6e2859f830e2c52ac1035f8a3f4aa99474dd4b90f2173af16.png" />
</div>
</div>
<ul class="simple">
<li><p>El primer panel no muestra ningún cambio, con scores aproximadamente constantes en toda la red de parámetros. En este caso, esto se debe a una escala y un <em><strong>rango inadecuado para los parámetros</strong></em> <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code>. Sin embargo, <em><strong>si no se aprecia ningún cambio en la precisión a lo largo de los diferentes ajustes de los parámetros, también puede ser que un parámetro no sea importante en absoluto</strong></em>.</p></li>
<li><p>Suele ser bueno probar primero valores muy extremos, para ver si hay algún cambio en la precisión como resultado de cambiar un parámetro. El segundo panel muestra un patrón de rayas verticales. Esto indica que solo el ajuste del parámetro <code class="docutils literal notranslate"><span class="pre">gamma</span></code> hace alguna diferencia. Esto podría significar que el parámetro <em><strong>gamma busca valores interesantes, pero el parámetro C no lo hace, o podría significar que el parámetro C no es importante</strong></em>.</p></li>
<li><p>El tercer panel muestra <em><strong>cambios tanto en C como en gamma</strong></em>. Sin embargo, podemos ver que en toda la parte inferior izquierda del gráfico, no ocurre nada interesante. Probablemente, podemos excluir los valores muy pequeños de las futuras búsquedas en la red. <em><strong>La configuración óptima de los parámetros está en la parte superior derecha</strong></em>. <em><strong>Como el óptimo está en el borde del gráfico, podemos esperar que puede haber valores aún mejores más allá de este límite, y podríamos cambiar nuestro rango de búsqueda para incluir más parámetros en esta región</strong></em>.</p></li>
<li><p>Ajustar la red de parámetros basándose en las puntuaciones de validación cruzada es perfectamente correcto, y una buena manera de explorar la importancia de los diferentes parámetros. Sin embargo, <em><strong>no debería probar diferentes rangos de parámetros en el conjunto de pruebas final</strong></em>, ya que, como hemos dicho antes, <em><strong>la evaluación del conjunto de pruebas solo debería realizarse una vez que sepamos exactamente qué modelo queremos utilizar</strong></em>.</p></li>
</ul>
</section>
<section id="busqueda-sobre-espacios-que-no-son-una-red">
<h3><span class="section-number">9.2.5. </span>Búsqueda sobre espacios que no son una red<a class="headerlink" href="#busqueda-sobre-espacios-que-no-son-una-red" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>En algunos casos, probar todas las combinaciones posibles de todos los parámetros, como suele hacer <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, no es una buena idea. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">SVC</span></code> tiene un parámetro de <code class="docutils literal notranslate"><span class="pre">kernel</span></code>, y dependiendo del <code class="docutils literal notranslate"><span class="pre">kernel</span></code> que se elija, otros parámetros serán relevantes. Si <code class="docutils literal notranslate"><span class="pre">kernel='linear'</span></code>, el modelo es lineal, y solo se utiliza el parámetro <code class="docutils literal notranslate"><span class="pre">C</span></code>. Si <code class="docutils literal notranslate"><span class="pre">kernel='rbf'</span></code>, se utilizan los parámetros <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span> <span class="pre">gamma</span></code> (pero no otros parámetros como el grado).</p></li>
<li><p>En este caso, la búsqueda de todas las combinaciones posibles de <code class="docutils literal notranslate"><span class="pre">C,</span> <span class="pre">gamma</span> <span class="pre">y</span> <span class="pre">kernel</span></code> no tendría sentido: si <code class="docutils literal notranslate"><span class="pre">kernel='linear',</span> <span class="pre">gamma</span></code> no se utiliza, y probar diferentes valores de <code class="docutils literal notranslate"><span class="pre">gamma</span></code> sería una pérdida de tiempo. Recuerde que <code class="docutils literal notranslate"><span class="pre">kernel='rbf'</span></code> es el <em><strong>kernel de función de base radial (RBF)</strong></em> con mapeo de características <span class="math notranslate nohighlight">\(\phi(\boldsymbol{x})=\exp(\|\boldsymbol{x}-x_{i}\|/2\sigma^2),~\gamma=1/\sigma^2\)</span>. Para ver todas las opciones de kernel gaussiano (ver <a class="reference external" href="https://scikit-learn.org/stable/modules/gaussian_process.html#gp-kernels">Kernels for Gaussian Processes</a>).</p></li>
<li><p>Para tratar este tipo de parámetros “condicionales”, <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> permite que <code class="docutils literal notranslate"><span class="pre">param_grid</span></code> sea una lista de diccionarios. Cada diccionario de la lista se expande en una red <code class="docutils literal notranslate"><span class="pre">(grid)</span></code> independiente. Una posible búsqueda en red que incluya el núcleo (<code class="docutils literal notranslate"><span class="pre">kernel</span></code>) y los parámetros podría ser así:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;rbf&#39;</span><span class="p">],</span>
               <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
               <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]},</span>
              <span class="p">{</span><span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">],</span>
               <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List of grids:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>List of grids:
[{&#39;kernel&#39;: [&#39;rbf&#39;], &#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100], &#39;gamma&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}, {&#39;kernel&#39;: [&#39;linear&#39;], &#39;C&#39;: [0.001, 0.01, 0.1, 1, 10, 100]}]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>En la primera red, el parámetro del <code class="docutils literal notranslate"><span class="pre">kernel</span></code> se establece siempre en <code class="docutils literal notranslate"><span class="pre">'rbf'</span></code> (no que la entrada de <code class="docutils literal notranslate"><span class="pre">kernel</span></code> es una lista de longitud uno), y se varían los parámetros <code class="docutils literal notranslate"><span class="pre">C</span></code> y <code class="docutils literal notranslate"><span class="pre">gamma</span></code>. <em><strong>En la segunda red, el parámetro kernel siempre se establece como lineal, y sólo se varía C</strong></em>. Ahora apliquemos esta búsqueda de parámetros más compleja</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best parameters: {&#39;C&#39;: 10, &#39;gamma&#39;: 0.1, &#39;kernel&#39;: &#39;rbf&#39;}
Best cross-validation score: 0.97
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Observemos de nuevo el <code class="docutils literal notranslate"><span class="pre">cv_results_</span></code>. Como era de esperar, si el núcleo es <code class="docutils literal notranslate"><span class="pre">&quot;lineal&quot;</span></code>, sólo varía <code class="docutils literal notranslate"><span class="pre">C</span></code>. Nótese que el <em><strong>pandas tiene un total de 16 columnas</strong></em>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grid_search</span><span class="o">.</span><span class="n">cv_results_</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span> <span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">])</span>
<span class="n">results</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>mean_fit_time</th>
      <td>0.000476</td>
      <td>0.000407</td>
      <td>0.000416</td>
      <td>0.000423</td>
      <td>0.000417</td>
      <td>0.000482</td>
    </tr>
    <tr>
      <th>std_fit_time</th>
      <td>0.000104</td>
      <td>0.000008</td>
      <td>0.000016</td>
      <td>0.000011</td>
      <td>0.00001</td>
      <td>0.000013</td>
    </tr>
    <tr>
      <th>mean_score_time</th>
      <td>0.000265</td>
      <td>0.000235</td>
      <td>0.000257</td>
      <td>0.000254</td>
      <td>0.00027</td>
      <td>0.000253</td>
    </tr>
    <tr>
      <th>std_score_time</th>
      <td>0.000044</td>
      <td>0.000008</td>
      <td>0.00003</td>
      <td>0.000042</td>
      <td>0.000062</td>
      <td>0.000015</td>
    </tr>
    <tr>
      <th>param_C</th>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>0.001</td>
    </tr>
    <tr>
      <th>param_gamma</th>
      <td>0.001</td>
      <td>0.01</td>
      <td>0.1</td>
      <td>1</td>
      <td>10</td>
      <td>100</td>
    </tr>
    <tr>
      <th>param_kernel</th>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
      <td>rbf</td>
    </tr>
    <tr>
      <th>params</th>
      <td>{'C': 0.001, 'gamma': 0.001, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 0.01, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 0.1, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 1, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 10, 'kernel': 'rbf'}</td>
      <td>{'C': 0.001, 'gamma': 100, 'kernel': 'rbf'}</td>
    </tr>
    <tr>
      <th>split0_test_score</th>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
    </tr>
    <tr>
      <th>split1_test_score</th>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
      <td>0.347826</td>
    </tr>
    <tr>
      <th>split2_test_score</th>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
    </tr>
    <tr>
      <th>split3_test_score</th>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
      <td>0.363636</td>
    </tr>
    <tr>
      <th>split4_test_score</th>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
      <td>0.409091</td>
    </tr>
    <tr>
      <th>mean_test_score</th>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
      <td>0.366403</td>
    </tr>
    <tr>
      <th>std_test_score</th>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
      <td>0.022485</td>
    </tr>
    <tr>
      <th>rank_test_score</th>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
      <td>27</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(16, 42)
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Uso de diferentes estrategias de validación cruzada con la búsqueda en red</p>
<p>Al igual que <code class="docutils literal notranslate"><span class="pre">cross_val_score,</span> <span class="pre">GridSearchCV</span></code> utiliza por defecto la validación cruzada estratificada <code class="docutils literal notranslate"><span class="pre">k-fold</span></code> para la clasificación, y la <em><strong>validación cruzada k-fold</strong></em> para la regresión. Sin embargo, también puede pasar cualquier divisor de validación cruzada, como se describe en <em><strong>“Más control sobre la validación cruzada”</strong></em>, como parámetro <code class="docutils literal notranslate"><span class="pre">cv</span></code> en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>. En particular, para obtener una única división en un conjunto de entrenamiento y otro de validación, puede utilizar <code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code> o <code class="docutils literal notranslate"><span class="pre">StratifiedShuffleSplit</span></code> con <code class="docutils literal notranslate"><span class="pre">n_iter=1</span></code> (número de iteraciones de reordenamiento y división). Esto puede ser útil para conjuntos de datos muy grandes o para modelos muy lentos.</p>
</div>
</section>
<section id="validacion-cruzada-anidada">
<h3><span class="section-number">9.2.6. </span>Validación cruzada anidada<a class="headerlink" href="#validacion-cruzada-anidada" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>La validación cruzada anidada mejora la estabilidad de la evaluación del modelo al evitar depender de una sola partición de entrenamiento/prueba. <strong>Consiste en un bucle externo de validación cruzada que evalúa el rendimiento general del modelo y un bucle interno (GridSearchCV) que ajusta los hiperparámetros</strong>.</p></li>
<li><p>El resultado son <strong>puntuaciones más realistas sobre la capacidad de generalización, pero no genera un modelo final entrenado</strong>. Es útil para evaluación comparativa de modelos, no para producción. Se implementa fácilmente con <code class="docutils literal notranslate"><span class="pre">cross_val_score(GridSearchCV(...))</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean cross-validation score: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores:  [0.96666667 1.         0.9        0.96666667 1.        ]
Mean cross-validation score:  0.9666666666666668
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La validación cruzada anidada muestra que <strong>SVC alcanza un 96.67% de precisión media en el conjunto <code class="docutils literal notranslate"><span class="pre">iris</span></code></strong>, usando validación cruzada estratificada de 5 pliegues en bucles interno y externo. Con <strong>36 combinaciones de parámetros, se entrenan 900 modelos (36 × 5 × 5)</strong>, lo que implica un alto costo computacional. Aunque aquí se usa el mismo divisor para ambos bucles, pueden combinarse distintas estrategias, y visualizar el proceso como bucles <code class="docutils literal notranslate"><span class="pre">for</span></code> facilita su comprensión.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nested_cv</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inner_cv</span><span class="p">,</span> <span class="n">outer_cv</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">,</span> <span class="n">parameter_grid</span><span class="p">):</span>
    <span class="n">outer_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">training_samples</span><span class="p">,</span> <span class="n">test_samples</span> <span class="ow">in</span> <span class="n">outer_cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">best_parms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">parameter_grid</span><span class="p">:</span>
            <span class="n">cv_scores</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">inner_train</span><span class="p">,</span> <span class="n">inner_test</span> <span class="ow">in</span> <span class="n">inner_cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">training_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">training_samples</span><span class="p">]):</span>
                <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
                <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">inner_train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">inner_train</span><span class="p">])</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">inner_test</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">inner_test</span><span class="p">])</span>
                <span class="n">cv_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="n">mean_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">mean_score</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">)</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">training_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">training_samples</span><span class="p">])</span>
        <span class="n">outer_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">test_samples</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_samples</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outer_scores</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">ParameterGrid</span><span class="p">,</span> <span class="n">StratifiedKFold</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scores</span> <span class="o">=</span> <span class="n">nested_cv</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="n">StratifiedKFold</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">SVC</span><span class="p">,</span> <span class="n">ParameterGrid</span><span class="p">(</span><span class="n">param_grid</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cross-validation scores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]
</pre></div>
</div>
</div>
</div>
</section>
<section id="paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">
<h3><span class="section-number">9.2.7. </span>Paralelización de la validación cruzada y la búsqueda en red<a class="headerlink" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Aunque la ejecución de <em>grid search</em> sobre múltiples parámetros y grandes conjuntos de datos puede ser computacionalmente exigente, su naturaleza independiente entre combinaciones de parámetros y particiones de validación cruzada permite una paralelización eficiente en múltiples núcleos o clústeres.</p></li>
<li><p>En <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> y <code class="docutils literal notranslate"><span class="pre">cross_validation</span></code>, el parámetro <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> controla el número de núcleos utilizados (<code class="docutils literal notranslate"><span class="pre">n_jobs=-1</span></code> emplea todos). No obstante, scikit-learn no permite anidamiento de paralelización: si el modelo ya usa <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>, no debe usarse en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>. Además, en modelos o conjuntos de datos grandes, el uso intensivo de núcleos puede generar un consumo elevado de memoria, por lo que debe monitorearse.</p></li>
<li><p>La paralelización también puede extenderse a varios nodos mediante el marco paralelo de IPython o mediante bucles personalizados. Para entornos Spark, el paquete <strong><code class="docutils literal notranslate"><span class="pre">spark-sklearn</span></code> permite ejecutar búsquedas en red sobre un clúster ya configurado</strong>.</p></li>
</ul>
</section>
</section>
<section id="metricas-de-evaluacion-y-scoring">
<h2><span class="section-number">9.3. </span>Métricas de evaluación y scoring<a class="headerlink" href="#metricas-de-evaluacion-y-scoring" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Hasta ahora, hemos evaluado el <em><strong>rendimiento de la clasificación utilizando la precisión (accuracy)</strong></em> (la fracción de muestras correctamente clasificadas) y el <em><strong>rendimiento de la regresión</strong></em> mediante el <span class="math notranslate nohighlight">\(R^2\)</span>. Sin embargo, éstas son sólo dos de las muchas formas posibles de resumir la eficacia de un modelo supervisado en un conjunto de datos determinado. <em><strong>En la práctica, estas métricas de evaluación pueden no ser apropiadas para su aplicación, y es importante elegir la métrica correcta cuando se selecciona entre modelos y se ajustan los parámetros</strong></em>.</p></li>
</ul>
<section id="tenga-en-cuenta-el-objetivo-final">
<h3><span class="section-number">9.3.1. </span>Tenga en cuenta el objetivo final<a class="headerlink" href="#tenga-en-cuenta-el-objetivo-final" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Al elegir una <em><strong>métrica en aprendizaje automático, debe alinearse con el objetivo final de la aplicación</strong></em>, conocido como <em><strong>métrica de negocio</strong></em>, ya que las predicciones influyen en la toma de decisiones y el impacto empresarial. Por ejemplo, podría buscar reducir accidentes, minimizar hospitalizaciones o aumentar ingresos.</p></li>
<li><p>La <em><strong>selección del modelo y sus parámetros debe maximizar el impacto positivo en la métrica de negocio</strong></em>, pero evaluarlo en producción puede ser riesgoso. Por ello, se emplean métricas sustitutas más fáciles de calcular, como la <code class="docutils literal notranslate"><span class="pre">precision</span></code> en la clasificación de imágenes. Sin embargo, estas métricas deben acercarse lo más posible al objetivo real.</p></li>
<li><p>El impacto empresarial puede no reducirse a un solo número (por ejemplo, más clientes pero menor gasto por cliente), pero debe reflejar la influencia del modelo. En esta sección, se abordarán <em><strong>métricas para clasificación binaria, multiclase y regresión</strong></em>.</p></li>
</ul>
</section>
<section id="metricas-para-la-clasificacion-binaria">
<h3><span class="section-number">9.3.2. </span>Métricas para la clasificación binaria<a class="headerlink" href="#metricas-para-la-clasificacion-binaria" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>La clasificación binaria es probablemente la aplicación más común y conceptualmente simple de aprendizaje automático en la práctica. <em><strong>Sin embargo, todavía hay una serie de advertencias en evaluar incluso esta sencilla tarea</strong></em>. Antes de entrar en las métricas alternativas, echemos un vistazo a la forma en que se mide la precisión, la cual puede ser engañosa. Recordemos que para la clasificación binaria, a menudo hablamos de una <em><strong>clase positiva</strong></em> y una <em><strong>clase negativa</strong></em>, entendiendo que la clase positiva es la que estamos buscando.</p></li>
</ul>
</section>
<section id="tipos-de-errores">
<h3><span class="section-number">9.3.3. </span>Tipos de errores<a class="headerlink" href="#tipos-de-errores" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>precisión (<code class="docutils literal notranslate"><span class="pre">accuracy</span></code>)</strong> no siempre es una buena medida del rendimiento, ya que los errores cometidos no reflejan toda la información relevante. Por ejemplo, en la <strong>detección temprana de cáncer</strong>, una prueba positiva implica más exámenes, mientras que una negativa considera al paciente sano. Dado que ningún modelo es perfecto, es crucial evaluar el impacto real de sus errores.</p></li>
<li><p>Un <strong>falso positivo</strong> ocurre cuando un paciente sano es clasificado como enfermo, causando pruebas innecesarias y posibles preocupaciones. En cambio, un <strong>falso negativo</strong>, donde un paciente enfermo es clasificado como sano, puede ser fatal al retrasar el tratamiento. Estos errores se conocen como <strong>tipo I y tipo II</strong>, pero los términos <strong>falso positivo y falso negativo</strong> son más claros. En este contexto, es <strong>crítico minimizar los falsos negativos (<code class="docutils literal notranslate"><span class="pre">recall</span></code>)</strong>, aunque los falsos positivos sean una molestia.</p></li>
<li><p>Las consecuencias de estos errores varían según la aplicación. En el ámbito comercial, se pueden asignar <strong>costos monetarios a cada tipo de error</strong>, permitiendo evaluar modelos más allá de la precisión, optimizando la toma de decisiones.</p></li>
</ul>
<ul class="simple">
<li><p>Un ejemplo donde el equilibrio es clave pede ser la <strong>detección de spam en correos electrónicos</strong>.</p>
<ul>
<li><p><strong>Reducir falsos negativos</strong> (<em>correos spam que se clasifican como no spam</em>): Si un correo malicioso pasa desapercibido, el usuario podría ser víctima de estafas o phishing.</p></li>
<li><p><strong>Reducir falsos positivos</strong> (<em>correos legítimos que se clasifican como spam</em>): Correos importantes, como facturas o mensajes de trabajo, podrían perderse en la carpeta de spam.</p></li>
</ul>
</li>
</ul>
</section>
<section id="conjuntos-de-datos-desequilibrados">
<h3><span class="section-number">9.3.4. </span>Conjuntos de datos desequilibrados<a class="headerlink" href="#conjuntos-de-datos-desequilibrados" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Los errores son cruciales cuando una clase es mucho más frecuente que otra, como en la predicción de <em>clicks</em>, donde la mayoría de los elementos mostrados no reciben interacción. En estos casos, los datos están <strong>desequilibrados</strong>, con una gran mayoría perteneciente a la clase “no click”.</p></li>
<li><p>Dado que los eventos de interés suelen ser raros, un modelo con <strong>99% para <code class="docutils literal notranslate"><span class="pre">accuracy</span></code></strong> podría simplemente predecir siempre “no click” sin aportar valor real. Por ello, la precisión no distingue entre un modelo trivial y uno efectivo. Para ilustrarlo, se creará un conjunto de datos desequilibrado 9:1 con el conjunto <em>digits</em>, clasificando el dígito 9 frente a los demás.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_digits</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digits</span> <span class="o">=</span> <span class="n">load_digits</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data shape: &quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;; Target shape&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data shape:  (1797, 64) ; Target shape (1797,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,
       13., 14., 15., 16.])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span> <span class="c1"># Boolean</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Podemos utilizar <code class="docutils literal notranslate"><span class="pre">DummyClassifier</span></code> para predecir siempre la clase mayoritaria (aquí “not nine”) <em><strong>para ver lo poco informativa que puede ser el (accuracy)</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dummy_majority</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;most_frequent&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_most_frequent</span> <span class="o">=</span> <span class="n">dummy_majority</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique predicted labels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pred_most_frequent</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dummy_majority</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unique predicted labels: [False]
Test score: 0.90
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Obtuvimos una precisión cercana al 90% sin aprender nada. Esto puede parecer sorprendente, pero pero piénselo un momento. <em><strong>Imagine que alguien le dice que su modelo tiene un 90% de precisión. Podrías pensar que han hecho un buen trabajo. Pero dependiendo del problema, ¡eso podría ser posible con sólo predecir una clase! Comparemos esto con el uso de un clasificador real</strong></em>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test score: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Según la precisión, el <em><strong>DecisionTreeClassifier es sólo ligeramente mejor que el predictor constante. Esto podría indicar que algo está mal en la forma en que utilizamos DecisionTreeClassifier, o bien que accuracy no es una buena medida en este caso</strong></em>. Para comparar, evaluemos otro clasificador, <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred_logreg</span> <span class="o">=</span> <span class="n">logreg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;logreg score: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logreg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>logreg score: 0.98
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El clasificador <code class="docutils literal notranslate"><span class="pre">dummy</span></code> con resultados aleatorios es el peor según <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> muestra buenos resultados. Sin embargo, <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> es inadecuada en entornos desequilibrados, dificultando la evaluación real del modelo. <em><strong>Exploraremos métricas alternativas que permitan seleccionar modelos de manera más efectiva</strong></em>, priorizando aquellas que indiquen cuánto mejor es un modelo en lugar de favorecer predicciones frecuentes o aleatorias. <em><strong>Una métrica adecuada debería descartar predicciones sin sentido</strong></em>.</p></li>
</ul>
</section>
<section id="matrices-de-confusion">
<h3><span class="section-number">9.3.5. </span>Matrices de confusión<a class="headerlink" href="#matrices-de-confusion" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Una de las formas más completas de representar el resultado de la evaluación de la clasificación binaria es el uso de <em><strong>matrices de confusión</strong></em>. Inspeccionemos las predicciones de <code class="docutils literal notranslate"><span class="pre">LogisticRegres</span></code> de la sección anterior utilizando la función <code class="docutils literal notranslate"><span class="pre">confusion_matrix</span></code>. Ya hemos almacenado las predicciones del conjunto de prueba en <code class="docutils literal notranslate"><span class="pre">pred_logreg</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">confusion</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Confusion matrix:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">confusion</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Confusion matrix:
[[402   1]
 [  6  41]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La salida de <code class="docutils literal notranslate"><span class="pre">confusion_matrix</span></code> es una <em><strong>matriz de dos por dos, donde las filas corresponden a las clases verdaderas y las columnas corresponden a las clases predichas</strong></em>. Cada entrada cuenta la frecuencia con la que una muestra que pertenece a la clase correspondiente a la fila (aquí “not nine” y “nine”) fue clasificada como la clase correspondiente a la columna.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_confusion_matrix_illustration</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d015e36315dcf24c7da5c0244804d4e070dc8cf5fcd4f271c64165177d2e7942.png" src="_images/d015e36315dcf24c7da5c0244804d4e070dc8cf5fcd4f271c64165177d2e7942.png" />
</div>
</div>
<ul class="simple">
<li><p>La <strong>diagonal principal</strong> de la matriz de confusión representa las clasificaciones correctas, mientras que las demás entradas indican errores. Si “nine” es la clase positiva, se pueden definir los términos <strong>falso positivo (FP)</strong> y <strong>falso negativo (FN)</strong>. Además, las muestras correctamente clasificadas como positivas son <strong>verdaderos positivos (TP)</strong> y las negativas, <strong>verdaderos negativos (TN)</strong>. Estos términos permiten interpretar la matriz de confusión.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_binary_confusion_matrix</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fa190ec0c58244f66d7148f34adebdcf042ed53699b96c50db73e736806707b4.png" src="_images/fa190ec0c58244f66d7148f34adebdcf042ed53699b96c50db73e736806707b4.png" />
</div>
</div>
<ul class="simple">
<li><p>Ahora utilicemos la <em><strong>matriz de confusión</strong></em> para comparar los modelos que hemos ajustado antes (los dos modelos <em><strong>dummy, árbol de decisión y regresión logística</strong></em>)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Dummy model:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dummy model:
[[403   0]
 [ 47   0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Decision tree:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Decision tree:
[[390  13]
 [ 24  23]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Logistic Regression&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Logistic Regression
[[402   1]
 [  6  41]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La matriz de confusión revela que <code class="docutils literal notranslate"><span class="pre">pred_most_frequent</span></code> <em><strong>es ineficaz, ya que siempre predice la misma clase y tiene cero verdaderos y falsos positivos</strong></em>. Aunque el árbol de decisión y la regresión logística presentan predicciones más razonables, la regresión logística supera al árbol en todos los aspectos, con más verdaderos positivos y negativos y menos errores. Sin embargo, <em><strong>analizar manualmente la matriz es un proceso cualitativo y laborioso</strong></em>. A continuación, exploraremos métodos para resumir su información de manera más eficiente.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Accuracy</p>
<p>Ya vimos una forma de resumir el resultado en la <em><strong>matriz de confusión</strong></em>, calculando su <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, que puede expresarse como</p>
<div class="math notranslate nohighlight">
\[
\text{Accuracy}=\frac{TP+TN}{TP+TN+FP+FN}.
\]</div>
<p>En otras palabras, el <em><strong>accuracy es el número de predicciones correctas (TP y TN) dividido por el número de todas las muestras</strong></em> (todas las entradas de la matriz de confusión sumadas).</p>
</div>
<ul class="simple">
<li><p><em><strong>Precision, recall y f-score</strong></em>. Hay otras formas de resumir la matriz de confusión, siendo las más comunes: <em><strong>precision, recall y f-score</strong></em>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Precision</p>
<p><em><strong>Precision</strong></em> mide cuántas de las muestras predichas como positivas son realmente positivas, es decir, <code class="docutils literal notranslate"><span class="pre">precision</span></code> intenta responder a la siguiente pregunta: ¿qué proporción de identificaciones positivas fue correcta?</p>
<div class="math notranslate nohighlight">
\[
\text{Precision} = \frac{TP}{TP+FP} 
\]</div>
<p><em><strong>Precision</strong></em> se utiliza como métrica de rendimiento cuando <em><strong>el objetivo es limitar el número de falsos positivos</strong></em>.</p>
</div>
<ul class="simple">
<li><p>Un modelo que predice la eficacia de un medicamento en ensayos clínicos debe minimizar falsos positivos, ya que estos experimentos son costosos y solo deben realizarse con alta certeza de éxito. Por ello, es crucial que el modelo tenga alta <strong>precision</strong> (o valor predictivo positivo, VPP). Nótese que cuando <strong>precision → 1</strong>, <strong>FP → 0</strong>, y cuando <strong>recall → 1</strong>, <strong>FN → 0</strong>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Recall</p>
<p>El <code class="docutils literal notranslate"><span class="pre">recall</span></code> mide cuántas de las muestras de la clase positiva son realmente predichas positivas, es decir, <code class="docutils literal notranslate"><span class="pre">recall</span></code> intenta responder a la siguiente pregunta: ¿qué proporción de positivos reales se identificó en forma correcta?</p>
<div class="math notranslate nohighlight">
\[
\text{Recall} = \frac{TP}{TP+FN} 
\]</div>
<p><em><strong>Recall</strong></em> se utiliza como métrica de rendimiento cuando <em><strong>el objetivo es limitar el número de falsos negativos</strong></em>.</p>
</div>
<ul class="simple">
<li><p>Existe un equilibrio entre <code class="docutils literal notranslate"><span class="pre">recall</span></code> y <code class="docutils literal notranslate"><span class="pre">precision</span></code>. Si se predicen todas las muestras como positivas, se elimina <code class="docutils literal notranslate"><span class="pre">recall</span></code>, pero con muchos falsos positivos, reduciendo <code class="docutils literal notranslate"><span class="pre">precision</span></code>. En cambio, si solo se predice como positiva la muestra más segura, <code class="docutils literal notranslate"><span class="pre">precision</span></code> será perfecta (si es realmente positiva), pero el <code class="docutils literal notranslate"><span class="pre">recall</span></code> será muy bajo.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p><em><strong>Precision</strong></em> y <em><strong>recall</strong></em> son sólo dos de las muchas medidas de clasificación derivadas de <em><strong>TP, FP, TN y FN</strong></em>. Puede encontrar un gran resumen de todas las medidas en <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">Sensitivity_and_specificity</a>. En la comunidad del aprendizaje automático, <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> son las medidas más utilizadas para la clasificación binaria, aunque pueden utilizar otras métricas relacionadas.</p>
</div>
<div class="tip admonition">
<p class="admonition-title"><span class="math notranslate nohighlight">\(f_{1}\)</span>-score</p>
<p>Por lo tanto, aunque <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> sean medidas muy importantes, si sólo se tiene en cuenta una de ellas no se obtiene una visión completa. Una forma de resumirlas es usando el <em><strong>f-score o f-measure</strong></em>, que es la <em><strong>media armónica entre precision y recall</strong></em>:</p>
<div class="math notranslate nohighlight">
\[
F=2\cdot\frac{\text{precision}\cdot\text{recall}}{\text{precision}+\text{recall}}.
\]</div>
<p>Esta variante concreta también se conoce como <span class="math notranslate nohighlight">\(f_{1}\)</span>-score.</p>
</div>
<p>El <strong>F₁-score</strong> es mejor que la <strong>exactitud</strong> en conjuntos de datos desbalanceados, ya que considera <strong>precisión</strong> y <strong>recuperación</strong>. Lo aplicaremos al conjunto “nine vs. rest”, donde “nine” es la clase positiva y minoritaria (<code class="docutils literal notranslate"><span class="pre">True</span></code>), mientras que el resto es negativa (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">f1_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score dummy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score dummy: 0.00
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score tree: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score tree: 0.55
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1 score logistic regression: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1 score logistic regression: 0.92
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El <span class="math notranslate nohighlight">\(f_{1}\)</span>-score distingue mejor las predicciones dummy de las del árbol que el <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, alineándose mejor con nuestra intuición sobre un buen modelo. Sin embargo, es menos interpretable. Para un resumen más completo de <code class="docutils literal notranslate"><span class="pre">precision</span></code>, <code class="docutils literal notranslate"><span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f_{1}\)</span>-score, <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> los calcula y muestra en un formato claro. Sus últimas filas incluyen <code class="docutils literal notranslate"><span class="pre">macro</span> <span class="pre">avg</span></code>, que pondera cada clase por igual, y <code class="docutils literal notranslate"><span class="pre">weighted</span> <span class="pre">avg</span></code>, que ajusta los pesos según la proporción de datos. Más detalles en <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html">sklearn.metrics.classification_report</a>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_most_frequent</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.90      1.00      0.94       403
        nine       0.00      0.00      0.00        47

    accuracy                           0.90       450
   macro avg       0.45      0.50      0.47       450
weighted avg       0.80      0.90      0.85       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> produce una línea por clase (aquí, <code class="docutils literal notranslate"><span class="pre">True</span></code> y <code class="docutils literal notranslate"><span class="pre">False</span></code>) e informa <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code>. Si consideramos la clase positiva por “not nine”, podemos ver en la salida de <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> que obtenemos un <span class="math notranslate nohighlight">\(f\)</span>-score de 0.94 con el modelo <code class="docutils literal notranslate"><span class="pre">dummy</span></code>. Además, para la clase “not nine” tenemos un <code class="docutils literal notranslate"><span class="pre">recall</span></code> de 1, ya que clasificamos todas las muestras como “not nine”.</p></li>
<li><p>La última columna junto al <span class="math notranslate nohighlight">\(f\)</span>-score proporciona el soporte de cada clase, lo que significa simplemente el número de muestras en esta clase según la verdad básica. La última fila del informe de clasificación muestra una media ponderada (por el número de muestras en la clase) de los números de cada clase. Aquí hay dos informes más, uno para el clasificador <em><strong>arbol de decisión</strong></em> y otro para la <em><strong>regresión logística</strong></em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_tree</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.94      0.97      0.95       403
        nine       0.64      0.49      0.55        47

    accuracy                           0.92       450
   macro avg       0.79      0.73      0.75       450
weighted avg       0.91      0.92      0.91       450
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_logreg</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;not nine&quot;</span><span class="p">,</span> <span class="s2">&quot;nine&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

    not nine       0.99      1.00      0.99       403
        nine       0.98      0.87      0.92        47

    accuracy                           0.98       450
   macro avg       0.98      0.93      0.96       450
weighted avg       0.98      0.98      0.98       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como puede observar al mirar los informes, las diferencias entre los modelos <code class="docutils literal notranslate"><span class="pre">dummy</span></code> y un modelo muy bueno ya no son tan claras. La elección de la clase que se declarada como clase positiva, tiene un gran impacto en las métricas. Mientras que el <span class="math notranslate nohighlight">\(f\)</span>-score de la clasificación <code class="docutils literal notranslate"><span class="pre">dummy</span></code> es de 0.13 (frente a 0.89 para la <em><strong>regresión logística</strong></em>) en la clase “nine” es de 0.90 frente a 0.99, lo que parece un resultado razonable. Sin embargo, si se observan todas las cifras juntas, se obtiene una imagen bastante precisa, y podemos ver claramente la superioridad de la regresión logística.</p></li>
</ul>
</section>
<section id="teniendo-en-cuenta-la-incertidumbre">
<h3><span class="section-number">9.3.6. </span>Teniendo en cuenta la incertidumbre<a class="headerlink" href="#teniendo-en-cuenta-la-incertidumbre" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>La matriz de confusión y el informe de clasificación analizan detalladamente un conjunto de predicciones, pero las predicciones en sí contienen información clave del modelo. La mayoría de los clasificadores incluyen <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> para medir la certeza de las predicciones, utilizando umbrales fijos: 0 en <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> y 0.5 en <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> para clasificación binaria.</p></li>
<li><p>Un ejemplo de clasificación binaria desequilibrada presenta 400 puntos negativos y 50 positivos. Se entrena un <em><strong>kernel SVM</strong></em>, y un mapa de calor ilustra la función de decisión. Un círculo negro en la gráfica central superior marca el umbral donde la función es cero: puntos dentro del círculo son positivos, los demás negativos.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mglearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">.05</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_decision_threshold</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/5a2b41ffed1db21e6b8fa3faddc9dccb0dd2ce46ecd6d5b38be0dad937a6742c.png" src="_images/5a2b41ffed1db21e6b8fa3faddc9dccb0dd2ce46ecd6d5b38be0dad937a6742c.png" />
</div>
</div>
<ul class="simple">
<li><p>Podemos utilizar la función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> para evaluar <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> de ambas clases</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       0.49      1.00      0.66        49
           1       0.00      0.00      0.00        51

    accuracy                           0.49       100
   macro avg       0.24      0.50      0.33       100
weighted avg       0.24      0.49      0.32       100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[49  0]
 [51  0]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Se obtienen las puntuaciones de decisión para medir la certeza del modelo, luego se calcula un umbral óptimo como la media de estas puntuaciones. A partir de este umbral, se generan predicciones ajustadas, considerando como positivos los valores superiores.</p></li>
<li><p>La función <code class="docutils literal notranslate"><span class="pre">decision_function(X_test)</span></code> de un clasificador SVM (<code class="docutils literal notranslate"><span class="pre">SVC</span></code>) devuelve un arreglo de valores numéricos que representan la distancia de cada muestra con respecto al <strong>hiperplano de decisión</strong>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">decision_scores</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">optimal_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">decision_scores</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Umbral óptimo:&quot;</span><span class="p">,</span> <span class="n">optimal_threshold</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Umbral óptimo: -0.013244755286005602
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_pred_adjusted</span> <span class="o">=</span> <span class="n">decision_scores</span> <span class="o">&gt;</span> <span class="n">optimal_threshold</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_adjusted</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       0.98      1.00      0.99        49
           1       1.00      0.98      0.99        51

    accuracy                           0.99       100
   macro avg       0.99      0.99      0.99       100
weighted avg       0.99      0.99      0.99       100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_adjusted</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[49  0]
 [ 1 50]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Como se esperaba, <em><strong>recall y precision</strong></em> para la clase 1 subió. Ahora estamos clasificando una <em><strong>región más grande del espacio como clase 1</strong></em>, como se ilustra en el panel superior derecho de la anterior figura. <em><strong>Si valora más <code class="docutils literal notranslate"><span class="pre">precision</span></code> que <code class="docutils literal notranslate"><span class="pre">recall</span></code>, o al revés, o sus datos están muy desequilibrados, cambiar el umbral de decisión es la forma más fácil de obtener mejores resultados</strong></em>. <em>Como la función de decisión puede tener rangos arbitrarios, es difícil proporcionar una regla general sobre cómo elegir un umbral</em>.</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p><em><strong>Si establece un umbral, debe tener cuidado de no hacerlo utilizando el conjunto de prueba</strong></em>. Como con cualquier otro parámetro, establecer un umbral de decisión en el conjunto de prueba es probable que produzca resultados demasiado optimistas. <em><strong>Utilice un conjunto de validación o aplique validación cruzada</strong></em>.</p></li>
<li><p>La <em><strong>media geométrica o G-mean</strong></em> es una métrica de clasificación desequilibrada que, si se optimiza, <em><strong>buscará un equilibrio entre la precision y recall</strong></em>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\text{G-mean}=\sqrt{\text{precision}\times\text{recall}}.
\]</div>
<ul class="simple">
<li><p>Un enfoque consistiría en <em><strong>probar el modelo con cada umbral</strong></em> devuelto por la llamada <code class="docutils literal notranslate"><span class="pre">precision_recall_curve()</span></code> y <em><strong>seleccionar el umbral con el mayor valor G-mean</strong></em>. Otras técnicas de oversampling, tales como <code class="docutils literal notranslate"><span class="pre">SMOTE</span></code> también pueden ser adecuadas, para datos de entrenamiento desbalanceados.</p></li>
</ul>
</div>
<ul class="simple">
<li><p>El umbral en modelos con <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> es más fácil de ajustar, ya que su salida va de 0 a 1. <strong>Por defecto, un umbral de 0.5 clasifica como positiva una instancia si la probabilidad supera el 50%</strong>. Aumentarlo exige mayor certeza para predecir positivo y menor para negativo.</p></li>
<li><p>Trabajar con probabilidades es intuitivo, pero <strong>no todos los modelos reflejan bien la incertidumbre</strong> (ej., un <code class="docutils literal notranslate"><span class="pre">DecisionTree</span></code> profundo siempre está 100% seguro, aunque se equivoque). Esto se relaciona con la calibración: <strong>un modelo calibrado mide correctamente su incertidumbre</strong>. Para más detalles, consulte <em>“Predicting Good Probabilities with Supervised Learning”</em> de Niculescu-Mizil y Caruana.</p></li>
</ul>
</section>
</section>
<section id="curvas-precision-recall-y-roc">
<h2><span class="section-number">9.4. </span>Curvas precision-recall y ROC<a class="headerlink" href="#curvas-precision-recall-y-roc" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Ajustar el umbral de clasificación permite equilibrar <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code>. Por ejemplo, para un <code class="docutils literal notranslate"><span class="pre">recall</span></code> del 90%, el umbral debe adaptarse según los objetivos empresariales. Sin embargo, un umbral extremo, como clasificar todo como positivo, garantiza un <code class="docutils literal notranslate"><span class="pre">recall</span></code> del 100% pero hace inútil el modelo.</p></li>
<li><p>Fijar un <em><strong>punto operativo</strong></em>, como un <code class="docutils literal notranslate"><span class="pre">recall</span></code> del 90%, ayuda a garantizar el rendimiento en entornos empresariales. Al desarrollar un modelo, es clave explorar distintos umbrales y compromisos <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code> para comprender mejor el problema.</p></li>
<li><p>La herramienta clave para esto es la <em><strong>curva precision-recall</strong></em>, calculable con <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_curve.html"><code class="docutils literal notranslate"><span class="pre">precision_recall_curve()</span></code></a> de <code class="docutils literal notranslate"><span class="pre">sklearn.metrics</span></code>, que usa etiquetas reales e incertidumbres de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La función <code class="docutils literal notranslate"><span class="pre">precision_recall_curve</span></code> devuelve listas de <strong>precisión y recall</strong> para todos los umbrales posibles, permitiendo trazar la curva correspondiente. Más puntos generan una curva más suave. <code class="docutils literal notranslate"><span class="pre">make_blobs</span></code> crea datos gaussianos isotrópicos para agrupación.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>También usaremos el conjunto de <strong>cáncer de mama</strong> con <code class="docutils literal notranslate"><span class="pre">load_breast_cancer</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">.05</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">closest_eq_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">precision</span> <span class="o">-</span> <span class="n">recall</span><span class="p">))</span>
<span class="n">best_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">closest_eq_idx</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">best_precision</span> <span class="o">=</span> <span class="n">precision</span><span class="p">[</span><span class="n">closest_eq_idx</span><span class="p">]</span>
<span class="n">best_recall</span> <span class="o">=</span> <span class="n">recall</span><span class="p">[</span><span class="n">closest_eq_idx</span><span class="p">]</span>

<span class="n">best_threshold</span><span class="p">,</span> <span class="n">best_precision</span><span class="p">,</span> <span class="n">best_recall</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.39103354055345696, 0.9529411764705882, 0.9)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">close_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Precision-Recall Curve&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">[</span><span class="n">closest_eq_idx</span><span class="p">],</span> <span class="n">recall</span><span class="p">[</span><span class="n">closest_eq_idx</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
         <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Best Threshold (</span><span class="si">{</span><span class="n">best_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">recall</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
         <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Threshold ~ 0&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Precision&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Recall&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Precision-Recall Curve with Best Threshold and Threshold ~ 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/aefc5af3c9c56bfba4c97803da75360c67f14a8228bf21406ae377973474bdd0.png" src="_images/aefc5af3c9c56bfba4c97803da75360c67f14a8228bf21406ae377973474bdd0.png" />
</div>
</div>
<ul class="simple">
<li><p>Cada punto de la curva representa un umbral de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code>. Se puede lograr un <em><strong>recall de 0.99</strong></em> con una <em><strong>precisión de 0.63</strong></em>. <strong>El círculo negro indica el umbral 0, que es el predeterminado de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code></strong>, mostrando la compensación usada en <code class="docutils literal notranslate"><span class="pre">predict</span></code>. Cuanto más cerca de la esquina superior derecha esté la curva, mejor es el clasificador, pues indica alto <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> simultáneamente.</p></li>
<li><p>La curva inicia en la esquina superior izquierda con un umbral bajo, clasificando todo como positivo. A medida que el umbral aumenta, la precisión mejora, pero el <code class="docutils literal notranslate"><span class="pre">recall</span></code> disminuye. Si el umbral es muy alto, solo los verdaderos positivos son clasificados correctamente, lo que maximiza <code class="docutils literal notranslate"><span class="pre">precision</span></code> pero reduce <code class="docutils literal notranslate"><span class="pre">recall</span></code>. Para <code class="docutils literal notranslate"><span class="pre">precision</span></code> mayor a 0.5, cada mejora en precisión cuesta una gran pérdida en <code class="docutils literal notranslate"><span class="pre">recall</span></code>.</p></li>
<li><p>Diferentes clasificadores rinden mejor en distintas partes de la curva. Comparando un <code class="docutils literal notranslate"><span class="pre">SVM</span></code> con un <code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code>, este último usa <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code>. La función <code class="docutils literal notranslate"><span class="pre">precision_recall_curve</span></code> requiere una medida de certeza, por lo que se usa <code class="docutils literal notranslate"><span class="pre">rf.predict_proba(X_test)[:,</span> <span class="pre">1]</span></code>. El umbral predeterminado de <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> es 0.5 y está marcado en la curva.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">rf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="n">y_scores_svc</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">precision_svc</span><span class="p">,</span> <span class="n">recall_svc</span><span class="p">,</span> <span class="n">thresholds_svc</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_scores_svc</span><span class="p">)</span>

<span class="n">y_scores_rf</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">precision_rf</span><span class="p">,</span> <span class="n">recall_rf</span><span class="p">,</span> <span class="n">thresholds_rf</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_scores_rf</span><span class="p">)</span>

<span class="n">closest_eq_idx_svc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">precision_svc</span> <span class="o">-</span> <span class="n">recall_svc</span><span class="p">))</span>
<span class="n">best_threshold_svc</span> <span class="o">=</span> <span class="n">thresholds_svc</span><span class="p">[</span><span class="n">closest_eq_idx_svc</span><span class="p">]</span>
<span class="n">close_zero_svc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds_svc</span><span class="p">))</span>

<span class="n">closest_eq_idx_rf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">precision_rf</span> <span class="o">-</span> <span class="n">recall_rf</span><span class="p">))</span>
<span class="n">best_threshold_rf</span> <span class="o">=</span> <span class="n">thresholds_rf</span><span class="p">[</span><span class="n">closest_eq_idx_rf</span><span class="p">]</span>
<span class="n">close_default_rf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds_rf</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_svc</span><span class="p">,</span> <span class="n">recall_svc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SVC Precision-Recall Curve&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_rf</span><span class="p">,</span> <span class="n">recall_rf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;RandomForest Precision-Recall Curve&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_svc</span><span class="p">[</span><span class="n">closest_eq_idx_svc</span><span class="p">],</span> <span class="n">recall_svc</span><span class="p">[</span><span class="n">closest_eq_idx_svc</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> 
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Best Threshold SVC (</span><span class="si">{</span><span class="n">best_threshold_svc</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> 
         <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_svc</span><span class="p">[</span><span class="n">close_zero_svc</span><span class="p">],</span> <span class="n">recall_svc</span><span class="p">[</span><span class="n">close_zero_svc</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> 
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Threshold ~ 0 (SVC)&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_rf</span><span class="p">[</span><span class="n">closest_eq_idx_rf</span><span class="p">],</span> <span class="n">recall_rf</span><span class="p">[</span><span class="n">closest_eq_idx_rf</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> 
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Best Threshold RF (</span><span class="si">{</span><span class="n">best_threshold_rf</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> 
         <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">precision_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="n">recall_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> 
         <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Threshold 0.5 (RF)&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Precision&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Recall&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Precision-Recall Curve for SVC and RandomForest&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f7de970220dd694c01f26fb10e348803673b105ea196aa5a79f6185c8a082dcc.png" src="_images/f7de970220dd694c01f26fb10e348803673b105ea196aa5a79f6185c8a082dcc.png" />
</div>
</div>
<ul class="simple">
<li><p>En el gráfico de comparación podemos ver que el bosque aleatorio funciona mejor en los extremos, para requisitos de <code class="docutils literal notranslate"><span class="pre">recall</span></code> o de <code class="docutils literal notranslate"><span class="pre">precision</span></code> muy altos. Alrededor de cualquier nivel de precision, <code class="docutils literal notranslate"><span class="pre">RF</span></code> tiene un mejor rendimiento. Si sólo nos fijamos en el <span class="math notranslate nohighlight">\(f_{1}\)</span>-score para comparar el rendimiento general, habríamos pasado por alto estas sutilezas. El <span class="math notranslate nohighlight">\(f_{1}\)</span>-score sólo capta un punto de la curva <em><strong>precision-recall</strong></em>, el dado por el <em><strong>umbral por defecto</strong></em>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1_score of random forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1_score of svc: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f1_score of random forest: 0.978
f1_score of svc: 0.767
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>La comparación de dos curvas <em><strong>precision-recall</strong></em> proporciona una visión muy detallada, pero <em><strong>es un proceso bastante manual</strong></em>. Para la comparación automática de modelos, es posible que queramos resumir la información contenida en la curva, sin limitarnos a un umbral o punto de operación. Una forma concreta de resumir la curva <em><strong>precisión-recall</strong></em> es <strong><code class="docutils literal notranslate"><span class="pre">calcular</span> <span class="pre">la</span> <span class="pre">integral</span> <span class="pre">o</span> <span class="pre">el</span> <span class="pre">área</span> <span class="pre">bajo</span> <span class="pre">la</span> <span class="pre">curva</span> <span class="pre">precision-recall,</span> <span class="pre">también</span> <span class="pre">conocida</span> <span class="pre">como</span> <span class="pre">precisión</span> <span class="pre">media</span></code></strong>. Para calcular la precisión media se puede utilizar la función <code class="docutils literal notranslate"><span class="pre">average_precision_score</span></code>. Como tenemos que calcular la curva ROC y considerar múltiples umbrales, el resultado de <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> o <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> debe pasarse a <code class="docutils literal notranslate"><span class="pre">average_precision_score</span></code>, no el resultado de <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">average_precision_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ap_rf</span>  <span class="o">=</span> <span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ap_svc</span> <span class="o">=</span> <span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average precision of random forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ap_rf</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average precision of svc: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ap_svc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average precision of random forest: 0.998
Average precision of svc: 0.948
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Al promediar todos los umbrales posibles, vemos que el bosque aleatorio y el SVC tienen un rendimiento similar, con <code class="docutils literal notranslate"><span class="pre">RF</span></code> ligeramente por delante. Esto es bastante diferente del resultado que obtuvimos antes con <span class="math notranslate nohighlight">\(f_{1}\)</span>-score. Como la <em><strong>precisión media es el área área bajo una curva que va de 0 a 1, la precisión media siempre devuelve un valor entre 0 (worst) y 1 (best)</strong></em>. La precisión media de un clasificador que asigna <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> al azar es la fracción de muestras positivas en el conjunto de datos.</p></li>
</ul>
<section id="caracteristicas-operativas-del-receptor-roc-y-auc">
<h3><span class="section-number">9.4.1. </span>Características operativas del receptor (ROC) y AUC<a class="headerlink" href="#caracteristicas-operativas-del-receptor-roc-y-auc" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>La <em><strong>curva ROC</strong></em> analiza el rendimiento de los clasificadores a distintos umbrales, graficando la <em><strong>tasa de verdaderos positivos (TPR)</strong></em> frente a la <em><strong>tasa de falsos positivos (FPR)</strong></em>. Mientras que TPR equivale al <code class="docutils literal notranslate"><span class="pre">recall</span></code>, FPR mide la fracción de negativos reales clasificados incorrectamente. A diferencia de la curva <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>, la curva ROC evalúa el equilibrio entre la detección de positivos y la generación de falsos positivos.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
FPR=\frac{FP}{FP+TN}.
\]</div>
<ul class="simple">
<li><p>Nótese que <span class="math notranslate nohighlight">\(FPR\)</span> se utiliza como métrica de rendimiento cuando el objetivo es <em><strong>limitar el número de verdaderos negativos</strong></em>. La curva ROC puede calcularse mediante la función <code class="docutils literal notranslate"><span class="pre">roc_curve</span></code>. Nótese que si <span class="math notranslate nohighlight">\(FPR\rightarrow 0\)</span> entonces el número de <span class="math notranslate nohighlight">\(TN\)</span> crece.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR (recall)&quot;</span><span class="p">)</span>
<span class="n">close_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1157213221094643f496c78d6acac32475b321562103e0e1fbe0691ef98d8420.png" src="_images/1157213221094643f496c78d6acac32475b321562103e0e1fbe0691ef98d8420.png" />
</div>
</div>
<ul class="simple">
<li><p>Nótese que, <em><strong>los valores más pequeños en el eje</strong></em> <span class="math notranslate nohighlight">\(x\)</span> <em><strong>indican menos falsos positivos (FP) y más verdaderos negativos (TN). Los valores más grandes en el eje</strong></em> <span class="math notranslate nohighlight">\(y\)</span> <em><strong>indican más verdaderos positivos (TP) y menos falsos negativos (FN)</strong></em>. En cuanto a la curva <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>, a menudo queremos resumir la curva ROC utilizando un solo número, <em><strong>el área bajo la curva (comúnmente se denomina simplemente AUC, y se entiende que la curva en cuestión es la curva ROC)</strong></em>. Podemos calcular el área bajo la curva <code class="docutils literal notranslate"><span class="pre">ROC</span></code> con la función <code class="docutils literal notranslate"><span class="pre">roc_auc_score</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rf_auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">svc_auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC for Random Forest: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rf_auc</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC for SVC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">svc_auc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AUC for Random Forest: 0.997
AUC for SVC: 0.921
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fpr_rf</span><span class="p">,</span> <span class="n">tpr_rf</span><span class="p">,</span> <span class="n">thresholds_rf</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve SVC&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_rf</span><span class="p">,</span> <span class="n">tpr_rf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ROC Curve RF&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR (recall)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">close_zero</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold zero SVC&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">close_default_rf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thresholds_rf</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="n">tpr_rf</span><span class="p">[</span><span class="n">close_default_rf</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;threshold 0.5 RF&quot;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/45e5dec07684121d99bb7f0389bd79d4dd0f13c1378b6150c1b1effabc48211b.png" src="_images/45e5dec07684121d99bb7f0389bd79d4dd0f13c1378b6150c1b1effabc48211b.png" />
</div>
</div>
<ul class="simple">
<li><p>El bosque aleatorio supera ligeramente a la SVM en AUC-score. La precisión media, representada por el área bajo la curva (AUC), varía entre 0 (peor) y 1 (mejor). Una predicción aleatoria siempre tiene un AUC de 0.5, sin importar el desequilibrio de clases, lo que hace que AUC sea una mejor métrica que el accuracy en estos casos.</p></li>
<li><p><em><strong>El AUC mide qué tan bien el modelo clasifica muestras positivas en comparación con negativas</strong></em>. Un AUC de 1 indica que todas las muestras positivas tienen un puntaje mayor que las negativas. <em><strong>En problemas con clases desequilibradas, el AUC es más útil que el accuracy para la selección del modelo</strong></em>. Por ejemplo, al clasificar el dígito 9 frente a otros en un conjunto de datos, podemos evaluar el rendimiento de una SVM con diferentes valores de <code class="docutils literal notranslate"><span class="pre">gamma</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]:</span>
    <span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
    <span class="n">auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
    <span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span> <span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gamma = </span><span class="si">{:.2f}</span><span class="s2"> accuracy = </span><span class="si">{:.2f}</span><span class="s2"> AUC = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="n">auc</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;gamma=</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;FPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;TPR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>gamma = 1.00 accuracy = 0.62 AUC = 0.53
gamma = 0.07 accuracy = 0.62 AUC = 0.91
gamma = 0.01 accuracy = 0.63 AUC = 0.93
</pre></div>
</div>
<img alt="_images/460dcea5c79ca9b1a2c04b6aa0496f2e06d6f0f317bad8720dd3b76e2ad7c057.png" src="_images/460dcea5c79ca9b1a2c04b6aa0496f2e06d6f0f317bad8720dd3b76e2ad7c057.png" />
</div>
</div>
<ul class="simple">
<li><p>Los valores de <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> para <code class="docutils literal notranslate"><span class="pre">gamma</span></code> de <code class="docutils literal notranslate"><span class="pre">1.0,</span> <span class="pre">0.07</span></code> y <code class="docutils literal notranslate"><span class="pre">0.01</span></code> son <code class="docutils literal notranslate"><span class="pre">0.51,</span> <span class="pre">0.94</span></code> y <code class="docutils literal notranslate"><span class="pre">0.95</span></code>, respectivamente. Con <code class="docutils literal notranslate"><span class="pre">gamma=1.0</span></code>, el AUC es aleatorio, mientras que con <code class="docutils literal notranslate"><span class="pre">gamma=0.07</span></code> mejora a <code class="docutils literal notranslate"><span class="pre">0.94</span></code>, y con <code class="docutils literal notranslate"><span class="pre">gamma=0.01</span></code>, alcanza <code class="docutils literal notranslate"><span class="pre">0.95</span></code>, indicando que los positivos están mejor clasificados que los negativos. Con un umbral adecuado, el modelo puede clasificar perfectamente.</p></li>
<li><p>Usar solo <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> no revela esto, por lo que recomendamos el <code class="docutils literal notranslate"><span class="pre">AUC</span></code>, especialmente en datos desequilibrados. Sin embargo, dado que <code class="docutils literal notranslate"><span class="pre">AUC</span></code> no usa un umbral fijo, puede ser necesario ajustarlo para mejorar la clasificación.</p></li>
</ul>
</section>
</section>
<section id="metricas-para-la-clasificacion-multiclase">
<h2><span class="section-number">9.5. </span>Métricas para la clasificación multiclase<a class="headerlink" href="#metricas-para-la-clasificacion-multiclase" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>La evaluación de la clasificación multiclase se basa en métricas de clasificación binaria, pero promediadas en todas las clases. El <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> sigue siendo la fracción de ejemplos clasificados correctamente, pero no es ideal cuando las clases están desequilibradas.</p></li>
<li><p>Por ejemplo, en un problema con tres clases (A: 85%, B: 10%, C: 5%), un <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> del 85% puede ser engañoso. La clasificación multiclase es más difícil de interpretar que la binaria, por lo que, además del <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, se utilizan la <em><strong>matriz de confusión</strong></em> y el <em><strong>informe de clasificación</strong></em>. Aplicaremos estos métodos al reconocimiento de dígitos escritos a mano en el conjunto de datos <code class="docutils literal notranslate"><span class="pre">digits</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Confusion matrix:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Accuracy: 0.951
Confusion matrix:
[[37  0  0  0  0  0  0  0  0  0]
 [ 0 40  0  0  0  0  0  0  2  1]
 [ 0  1 40  3  0  0  0  0  0  0]
 [ 0  0  0 43  0  0  0  0  1  1]
 [ 0  0  0  0 37  0  0  1  0  0]
 [ 0  0  0  0  0 46  0  0  0  2]
 [ 0  1  0  0  0  0 51  0  0  0]
 [ 0  0  0  1  1  0  0 46  0  0]
 [ 0  3  1  0  0  0  0  0 43  1]
 [ 0  0  0  0  0  1  0  0  1 45]]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>El modelo tiene un accuracy del 95.1%, lo que ya nos dice que lo estamos haciendo bastante bien. La matriz de confusión nos proporciona algunos detalles más. Como en el caso binario, <em><strong>cada fila corresponde a una etiqueta verdadera y cada columna a una etiqueta predicha</strong></em>. En la siguiente figura se puede encontrar una mejor representación visual</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="n">conf_matrix</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">conf_matrix</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray_r&quot;</span><span class="p">,</span> 
            <span class="n">xticklabels</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target_names</span><span class="p">,</span> 
            <span class="n">yticklabels</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target_names</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Etiqueta Predicha&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Etiqueta Real&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Matriz de Confusión&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/61f510d04de55a3c9009dea4392eed536f362af1a379bc21798ef6bf633b8438.png" src="_images/61f510d04de55a3c9009dea4392eed536f362af1a379bc21798ef6bf633b8438.png" />
</div>
</div>
<ul class="simple">
<li><p>Para el dígito 0, las 37 muestras fueron clasificadas correctamente, sin falsos negativos ni falsos positivos. Sin embargo, hubo confusiones entre otros dígitos, como el 2, que se clasificó erróneamente como 3 en tres casos y como 1 en uno. También un dígito 8 se clasificó como 2. La función <code class="docutils literal notranslate"><span class="pre">classification_report</span></code> permite calcular <code class="docutils literal notranslate"><span class="pre">precision</span></code>, <code class="docutils literal notranslate"><span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span>-score para cada clase.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0       1.00      1.00      1.00        37
           1       0.89      0.93      0.91        43
           2       0.98      0.91      0.94        44
           3       0.91      0.96      0.93        45
           4       0.97      0.97      0.97        38
           5       0.98      0.96      0.97        48
           6       1.00      0.98      0.99        52
           7       0.98      0.96      0.97        48
           8       0.91      0.90      0.91        48
           9       0.90      0.96      0.93        47

    accuracy                           0.95       450
   macro avg       0.95      0.95      0.95       450
weighted avg       0.95      0.95      0.95       450
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>No es de extrañar que los valores para <code class="docutils literal notranslate"><span class="pre">precision</span></code> y <code class="docutils literal notranslate"><span class="pre">recall</span></code> sean un 1 perfecto para la clase 0, ya que no hay confusiones con esta clase. Para la clase 6, en cambio, el <code class="docutils literal notranslate"><span class="pre">precision</span></code> es de 1 porque ninguna otra clase se clasificó erróneamente como 6. <em><strong>La métrica más utilizada para conjuntos de datos desequilibrados en el entorno multiclase es la versión multiclase del</strong></em> <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code>.</p></li>
<li><p>La idea detrás del <span class="math notranslate nohighlight">\(f\)</span>-score multiclase es calcular un <span class="math notranslate nohighlight">\(f\)</span>-score <em><strong>binario por clase, siendo esa clase la positiva y las otras clases las negativas</strong></em>. Luego, estos <span class="math notranslate nohighlight">\(f\)</span>-scores por clase se promedian utilizando una de las siguientes estrategias:</p>
<ul>
<li><p><em><strong>El promedio “macro”</strong></em> calcula los <span class="math notranslate nohighlight">\(f\)</span>-scores no ponderadas por clase. De este modo, se da el mismo peso a todas las clases, independientemente de su tamaño.</p></li>
<li><p><em><strong>El promedio “weighted”</strong></em> calcula la media de los <span class="math notranslate nohighlight">\(f\)</span>-scores por clase, ponderada por su soporte. Esto es lo que se indica en el informe de clasificación.</p></li>
<li><p><em><strong>El promedio “micro”</strong></em> calcula el número total de falsos positivos, falsos negativos y verdaderos positivos en todas las clases, y luego calcula <code class="docutils literal notranslate"><span class="pre">precision,</span> <span class="pre">recall</span></code> y <span class="math notranslate nohighlight">\(f\)</span><code class="docutils literal notranslate"><span class="pre">-score</span></code> utilizando estos recuentos.</p></li>
</ul>
</li>
<li><p>Si se preocupa por igual de cada muestra, se recomienda utilizar el “micro” <span class="math notranslate nohighlight">\(f\)</span>-score; si le importa cada clase por igual, se recomienda utilizar la media macro <span class="math notranslate nohighlight">\(f\)</span>-score.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Macro average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;macro&quot;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weighted average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Micro average f1 score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;micro&quot;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Macro average f1 score: 0.952
Weighted average f1 score: 0.951
Micro average f1 score: 0.951
</pre></div>
</div>
</div>
</div>
</section>
<section id="metricas-de-regresion">
<h2><span class="section-number">9.6. </span>Métricas de regresión<a class="headerlink" href="#metricas-de-regresion" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>La evaluación en regresión puede ser tan detallada como en clasificación, analizando sobrepredicción y subpredicción. Sin embargo, en la mayoría de los casos, el <strong><span class="math notranslate nohighlight">\(R^2\)</span></strong> usado por defecto en los regresores es suficiente. En aplicaciones empresariales, métricas como <strong>MSE o MAE</strong> pueden influir en la optimización de modelos. No obstante, <strong><span class="math notranslate nohighlight">\(R^2\)</span></strong> suele ser más intuitivo. En el curso de <strong>Time Series Forecasting</strong>, se profundizará en métricas como <strong>MAE, MAPE, MSE y RMSE</strong>.</p></li>
</ul>
<section id="uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">
<h3><span class="section-number">9.6.1. </span>Uso de métricas de evaluación en la selección de modelos<a class="headerlink" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Para evaluar modelos con métricas como AUC en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> o <code class="docutils literal notranslate"><span class="pre">cross_val_score</span></code>, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> permite usar el argumento <code class="docutils literal notranslate"><span class="pre">scoring</span></code>. Basta con proporcionar una cadena con la métrica deseada, como <code class="docutils literal notranslate"><span class="pre">&quot;roc_auc&quot;</span></code>, para cambiar la evaluación predeterminada (accuracy) a AUC. Esto facilita la selección de modelos en tareas como clasificar “nueve vs. resto” en <code class="docutils literal notranslate"><span class="pre">digits</span></code>.</p></li>
</ul>
<ul class="simple">
<li><p>Scoring por defecto para la clasificación es <code class="docutils literal notranslate"><span class="pre">accuracy</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Default scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Default scoring: [0.975      0.99166667 1.         0.99442897 0.98050139]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Proporcionar <code class="docutils literal notranslate"><span class="pre">scoring=&quot;accuracy&quot;</span></code> no cambia los resultados</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">explicit_accuracy</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;accuracy&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Explicit accuracy scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">explicit_accuracy</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Explicit accuracy scoring: [0.975      0.99166667 1.         0.99442897 0.98050139]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Ahora asignemos <code class="docutils literal notranslate"><span class="pre">scoring=&quot;roc_auc&quot;</span></code> para modificar la técnica de <code class="docutils literal notranslate"><span class="pre">scoring</span></code> utilizada</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">roc_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;roc_auc&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AUC scoring: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roc_auc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AUC scoring: [0.99717078 0.99854252 1.         0.999828   0.98400413]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Del mismo modo, podemos cambiar la métrica utilizada para elegir los mejores parámetros en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Proporcionamos una red a manera de ilustración del punto</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]}</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando el score <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> por defecto</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grid-Search with accuracy&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters:&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score (accuracy)): </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set AUC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Grid-Search with accuracy
Best parameters: {&#39;gamma&#39;: 0.0001}
Best cross-validation score (accuracy)): 0.976
Test set AUC: 0.992
Test set accuracy: 0.973
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Utilizando el scoring AUC en su lugar</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;roc_auc&quot;</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Grid-Search with AUC&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best parameters:&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best cross-validation score (AUC): </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">best_score_</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set AUC: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Grid-Search with AUC
Best parameters: {&#39;gamma&#39;: 0.01}
Best cross-validation score (AUC): 0.998
Test set AUC: 1.000
Test set accuracy: 1.000
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Cuando se utiliza <code class="docutils literal notranslate"><span class="pre">accuracy</span></code>, se selecciona el parámetro <code class="docutils literal notranslate"><span class="pre">gamma=0.0001</span></code>, mientras que cuando se utiliza el AUC se selecciona <code class="docutils literal notranslate"><span class="pre">gamma=0.01</span></code>. Accuracy score para la validación cruzada es coherente con el <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> del conjunto de prueba en ambos casos. <em><strong>Sin embargo, al utilizar AUC se encontró un mejor ajuste de los parámetros en en términos de AUC e incluso en términos de accuracy</strong></em>. Los valores más importantes del parámetro de scoring para la clasificación son <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> (por defecto); <code class="docutils literal notranslate"><span class="pre">roc_auc</span></code> para el área bajo la curva ROC; <code class="docutils literal notranslate"><span class="pre">average_precision</span></code> para el área bajo la curva de <code class="docutils literal notranslate"><span class="pre">precision-recall</span></code>; <code class="docutils literal notranslate"><span class="pre">f1,</span> <span class="pre">f1_macro,</span> <span class="pre">f1_micro</span></code> y <code class="docutils literal notranslate"><span class="pre">f1_weighted</span></code> para <span class="math notranslate nohighlight">\(f_{1}\)</span>-score binario y las diferentes variantes ponderadas.</p></li>
<li><p>En cuanto a la regresión, los valores más utilizados son <code class="docutils literal notranslate"><span class="pre">r2</span></code> para el score <span class="math notranslate nohighlight">\(R^{2}\)</span>, <code class="docutils literal notranslate"><span class="pre">mean_squared_error</span></code> para el error medio al cuadrado y <code class="docutils literal notranslate"><span class="pre">mean_absolute_error</span></code> para el error medio absoluto. Puede encontrar una lista completa de argumentos admitidos en la <a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules">documentación</a> o consultando el diccionario SCORER definido en el módulo <code class="docutils literal notranslate"><span class="pre">metrics.scorer</span></code>.</p></li>
</ul>
<div class="important admonition">
<p class="admonition-title">Resumen y conclusiones</p>
<p>La validación cruzada, el grid-search y las métricas de evaluación son fundamentales para mejorar los modelos de aprendizaje automático. Hay dos puntos clave a considerar:</p>
<ol class="arabic simple">
<li><p><strong>Validación cruzada</strong>: Permite evaluar un modelo como se comportaría en el futuro. Sin embargo, si se usa para seleccionar modelos o hiperparámetros, los datos de prueba quedan “agotados”, lo que lleva a estimaciones optimistas. Para evitarlo, se deben separar los datos en <strong>entrenamiento, validación y prueba</strong>, usando validación cruzada en el conjunto de entrenamiento para la selección de modelos y parámetros.</p></li>
<li><p><strong>Métrica de evaluación</strong>: <code class="docutils literal notranslate"><span class="pre">precision</span></code> no siempre es el mejor criterio, especialmente en problemas con clases desbalanceadas, donde los falsos positivos y negativos tienen impactos diferentes. Es crucial elegir una métrica adecuada según el contexto.</p></li>
</ol>
<p>Las herramientas descritas son esenciales para cualquier científico de datos. Sin embargo, grid-search y validación cruzada solo aplican a modelos supervisados individuales. En la siguiente sección, se introducirá <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> para optimizar procesos más complejos.</p>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Elemento</p></th>
<th class="head"><p>¿Necesario?</p></th>
<th class="head"><p>Comentario</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Python</strong></p></td>
<td><p>Sí</p></td>
<td><p>Versión recomendada: 3.8 a 3.10</p></td>
</tr>
<tr class="row-odd"><td><p><strong>PySpark instalado</strong> (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pyspark</span></code>)</p></td>
<td><p>Sí</p></td>
<td><p>Necesario para ejecutar Spark desde Python</p></td>
</tr>
<tr class="row-even"><td><p><strong>scikit-learn</strong> (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">scikit-learn</span></code>)</p></td>
<td><p>Sí</p></td>
<td><p>Necesario para cargar el dataset de <em>Iris</em></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Jupyter, VSCode o IDE</strong></p></td>
<td><p>Recomendado</p></td>
<td><p>Necesario si deseas una interfaz cómoda para desarrollar</p></td>
</tr>
<tr class="row-even"><td><p><strong>Java JDK (versión requerida por PySpark <code class="docutils literal notranslate"><span class="pre">java-17</span></code>)</strong></p></td>
<td><p>Usualmente necesario</p></td>
<td><p>Spark requiere Java. Asegúrate de tener <code class="docutils literal notranslate"><span class="pre">JAVA_HOME</span></code> configurado correctamente</p></td>
</tr>
<tr class="row-odd"><td><p><strong>findspark</strong> (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">findspark</span></code>)</p></td>
<td><p>Opcional</p></td>
<td><p>Útil si usas notebooks y necesitas inicializar Spark manualmente</p></td>
</tr>
<tr class="row-even"><td><p><strong>MLflow</strong> (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mlflow</span></code>)</p></td>
<td><p>Opcional</p></td>
<td><p>Solo si planeas hacer tracking de experimentos</p></td>
</tr>
</tbody>
</table>
</div>
<ul class="simple">
<li><p>Para instalar Java (ver <a class="reference external" href="https://www.oracle.com/java/technologies/downloads/?er=221886">Java Downloads</a>)</p></li>
<li><p>Configurar <code class="docutils literal notranslate"><span class="pre">JAVA_HOME</span></code> permanentemente. Si prefieres no tener que hacer esto en cada notebook:</p>
<ol class="arabic simple">
<li><p>Abre el Panel de Control → Sistema → Configuración avanzada del sistema.</p></li>
<li><p>Clic en “Variables de entorno”.</p></li>
<li><p>En “Variables del sistema”, haz clic en “Nueva…” y agrega:</p>
<ul>
<li><p><strong>Nombre:</strong> <code class="docutils literal notranslate"><span class="pre">JAVA_HOME</span></code></p></li>
<li><p><strong>Valor:</strong> <code class="docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Java\jdk-17.0.20</span></code> (ajusta según tu versión)</p></li>
</ul>
</li>
<li><p>Cierra y vuelve a abrir tu entorno (<code class="docutils literal notranslate"><span class="pre">Jupyter,</span> <span class="pre">Anaconda</span></code>, etc.).</p></li>
</ol>
</li>
</ul>
</section>
</section>
<section id="por-que-usar-pyspark-para-modelos-de-machine-learning-con-grandes-volumenes-de-datos">
<h2><span class="section-number">9.7. </span>¿Por qué usar <code class="docutils literal notranslate"><span class="pre">PySpark</span></code> para modelos de Machine Learning con grandes volúmenes de datos?<a class="headerlink" href="#por-que-usar-pyspark-para-modelos-de-machine-learning-con-grandes-volumenes-de-datos" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>A medida que trabajamos con datasets más grandes, las herramientas tradicionales como <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> comienzan a mostrar ciertas limitaciones. Aunque son excelentes para prototipado rápido y problemas de tamaño moderado, <strong>no están diseñadas para escalar eficientemente</strong> cuando tratamos con millones de registros.</p></li>
<li><p>Aquí es donde entra <strong>PySpark</strong>, la interfaz en Python de <code class="docutils literal notranslate"><span class="pre">Apache</span> <span class="pre">Spark</span></code>. <code class="docutils literal notranslate"><span class="pre">PySpark</span></code> permite:</p>
<ul>
<li><p><strong>Ejecutar operaciones en paralelo</strong> aprovechando múltiples núcleos o incluso múltiples máquinas (clústeres)</p></li>
<li><p><strong>Procesar y transformar datos a gran escala</strong> con pipelines eficientes</p></li>
<li><p><strong>Entrenar modelos de machine learning distribuidos</strong> con la API <code class="docutils literal notranslate"><span class="pre">pyspark.ml</span></code></p></li>
</ul>
</li>
<li><p>En el siguiente ejemplo consideramos un <strong>ejemplo realista</strong> donde entrenamos un modelo <code class="docutils literal notranslate"><span class="pre">SVM</span></code> sobre un dataset sintético de <strong>10 mil muestras y 50 features</strong>. Compararemos dos enfoques:</p>
<ul>
<li><p>Uno con <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> de <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, ejecutado en un solo equipo usando múltiples hilos</p></li>
<li><p>Otro con <code class="docutils literal notranslate"><span class="pre">CrossValidator</span></code> de <code class="docutils literal notranslate"><span class="pre">PySpark</span></code>, aprovechando el cómputo distribuido</p></li>
</ul>
</li>
<li><p>Ambos producen resultados comparables en calidad (métrica AUC), pero difieren notablemente en <strong>tiempo de entrenamiento</strong>, demostrando cómo <strong>PySpark puede acelerar tareas complejas cuando los datos crecen</strong>.</p></li>
<li><p>Este tipo de enfoque es crucial cuando trabajas en entornos de big data, o cuando quieres preparar tus modelos para producción sobre volúmenes de datos reales.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.classification</span> <span class="kn">import</span> <span class="n">LinearSVC</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.feature</span> <span class="kn">import</span> <span class="n">VectorAssembler</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.tuning</span> <span class="kn">import</span> <span class="n">ParamGridBuilder</span><span class="p">,</span> <span class="n">CrossValidator</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.evaluation</span> <span class="kn">import</span> <span class="n">BinaryClassificationEvaluator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYSPARK_PYTHON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/usr/bin/python3.10&quot;</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYSPARK_DRIVER_PYTHON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/usr/bin/python3.10&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">platform</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Driver usando Python:&quot;</span><span class="p">,</span> <span class="n">platform</span><span class="o">.</span><span class="n">python_version</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PYSPARK_PYTHON:&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYSPARK_PYTHON&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Driver usando Python: 3.10.12
PYSPARK_PYTHON: /usr/bin/python3.10
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">10_000</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_informative</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PySpark</span></code> solo soporta <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code>, sin soporte para kernels no lineales (<code class="docutils literal notranslate"><span class="pre">RBF,</span> <span class="pre">poly,</span> <span class="pre">sigmoid</span></code>). Si necesitas kernels no lineales con <code class="docutils literal notranslate"><span class="pre">Spark</span></code>, puedes usar <code class="docutils literal notranslate"><span class="pre">MLflow</span> <span class="pre">+</span> <span class="pre">Spark</span> <span class="pre">Submit</span></code> (<code class="docutils literal notranslate"><span class="pre">ejercicio</span> <span class="pre">para</span> <span class="pre">el</span> <span class="pre">estudiante</span></code>).</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># --- PySpark ---</span>
<span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span> \
    <span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&quot;WSL Spark Demo&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">master</span><span class="p">(</span><span class="s2">&quot;local[*]&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING: Using incubator modules: jdk.incubator.vector
Using Spark&#39;s default log4j profile: org/apache/spark/log4j2-defaults.properties
25/08/04 23:28:27 WARN Utils: Your hostname, DESKTOP-14GHD2E, resolves to a loopback address: 127.0.1.1; using 10.255.255.254 instead (on interface lo)
25/08/04 23:28:27 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address
Using Spark&#39;s default log4j profile: org/apache/spark/log4j2-defaults.properties
Setting default log level to &quot;WARN&quot;.
To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).
25/08/04 23:28:28 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convertir a Spark DataFrame</span>
<span class="n">df_pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
<span class="n">df_pd</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">df_spark</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">df_pd</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># VectorAssembler</span>
<span class="n">assembler</span> <span class="o">=</span> <span class="n">VectorAssembler</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;features&quot;</span><span class="p">)</span>
<span class="n">df_spark</span> <span class="o">=</span> <span class="n">assembler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_spark</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;features&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Split en Spark</span>
<span class="n">train_df</span><span class="p">,</span> <span class="n">test_df</span> <span class="o">=</span> <span class="n">df_spark</span><span class="o">.</span><span class="n">randomSplit</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Modelo y Grid</span>
<span class="n">svm</span> <span class="o">=</span> <span class="n">LinearSVC</span><span class="p">(</span><span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">featuresCol</span><span class="o">=</span><span class="s2">&quot;features&quot;</span><span class="p">)</span>
<span class="n">paramGrid</span> <span class="o">=</span> <span class="n">ParamGridBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">addGrid</span><span class="p">(</span><span class="n">svm</span><span class="o">.</span><span class="n">regParam</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">evaluator</span> <span class="o">=</span> <span class="n">BinaryClassificationEvaluator</span><span class="p">(</span><span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">metricName</span><span class="o">=</span><span class="s2">&quot;areaUnderROC&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># CrossValidator</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">CrossValidator</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">svm</span><span class="p">,</span> <span class="n">estimatorParamMaps</span><span class="o">=</span><span class="n">paramGrid</span><span class="p">,</span> <span class="n">evaluator</span><span class="o">=</span><span class="n">evaluator</span><span class="p">,</span> <span class="n">numFolds</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Entrenamiento</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">cv_model</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">elapsed_spark</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>25/08/04 23:28:31 WARN SparkStringUtils: Truncated the string representation of a plan since it was too large. This behavior can be adjusted by setting &#39;spark.sql.debug.maxToStringFields&#39;.
25/08/04 23:28:34 WARN InstanceBuilder: Failed to load implementation from:dev.ludovic.netlib.blas.JNIBLAS
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Evaluación</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">cv_model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
<span class="n">auc_spark</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
<span class="n">best_reg</span> <span class="o">=</span> <span class="n">cv_model</span><span class="o">.</span><span class="n">bestModel</span><span class="o">.</span><span class="n">_java_obj</span><span class="o">.</span><span class="n">getRegParam</span><span class="p">()</span>
<span class="n">best_c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">best_reg</span>

<span class="c1"># Resultados</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> PySpark + CrossValidator&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best C (1/regParam):&quot;</span><span class="p">,</span> <span class="n">best_c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test AUC: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">auc_spark</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tiempo: </span><span class="si">{:.2f}</span><span class="s2"> segundos&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed_spark</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> PySpark + CrossValidator
Best C (1/regParam): 10.0
Test AUC: 0.8573
Tiempo: 31.21 segundos
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><strong>“A continuación, se emplea el clásico <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> de <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>. Es importante destacar que <code class="docutils literal notranslate"><span class="pre">Apache</span> <span class="pre">Spark</span></code> ofrece un tiempo de cómputo aproximadamente nueve veces menor.”</strong></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]}</span>
<span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;roc_auc&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">elapsed_sklearn</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="n">y_pred</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">auc_sklearn</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">GridSearchCV (scikit-learn)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Best C:&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test AUC: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">auc_sklearn</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tiempo: </span><span class="si">{:.2f}</span><span class="s2"> segundos&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed_sklearn</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>GridSearchCV (scikit-learn)
Best C: 0.1
Test AUC: 0.8760
Tiempo: 273.57 segundos
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> usa <strong>liblinear</strong> como backend para <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PySpark</span></code> (<code class="docutils literal notranslate"><span class="pre">pyspark.ml.classification.LinearSVC</span></code>) usa un optimizador diferente basado en <strong>OWLQN</strong> (Orthant-Wise Limited-memory Quasi-Newton).</p></li>
<li><p><strong>Diferente optimizador → diferentes soluciones</strong>, incluso si el parámetro <code class="docutils literal notranslate"><span class="pre">C</span></code> o <code class="docutils literal notranslate"><span class="pre">regParam</span></code> es equivalente.</p></li>
</ul>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "tf"
        },
        kernelOptions: {
            name: "tf",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'tf'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="practical_pca.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Análisis de Componentes Principales</p>
      </div>
    </a>
    <a class="right-next"
       href="chains_pipelines.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Cadenas de Algoritmos y Pipelines</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-validation">9.1. Cross-Validation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-en-scikit-learn">9.1.1. Validación cruzada en scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ventajas-de-la-validacion-cruzada">9.1.2. Ventajas de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-kfold">9.1.3. Validación cruzada <code class="docutils literal notranslate"><span class="pre">KFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-estratificada-stratifiedkfold">9.1.4. Validación cruzada estratificada <code class="docutils literal notranslate"><span class="pre">StratifiedKFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-shuffle-kfold">9.1.5. Validación cruzada <code class="docutils literal notranslate"><span class="pre">shuffle</span> <span class="pre">KFold</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-con-exclusion-leave-one-out">9.1.6. Validación cruzada con exclusión <code class="docutils literal notranslate"><span class="pre">leave-one-out</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-aleatoria-y-divididashufflesplit">9.1.7. Validación cruzada aleatoria y dividida<code class="docutils literal notranslate"><span class="pre">ShuffleSplit</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-por-grupos-groupkfold">9.1.8. Validación cruzada por grupos <code class="docutils literal notranslate"><span class="pre">GroupKFold</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search">9.2. Grid Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-simple">9.2.1. Grid Search simple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#el-peligro-de-sobreajustar-los-parametros-y-el-conjunto-de-validacion">9.2.2. El peligro de sobreajustar los parámetros y el conjunto de validación</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-search-con-validacion-cruzada">9.2.3. Grid Search con validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisis-del-resultado-de-la-validacion-cruzada">9.2.4. Análisis del resultado de la validación cruzada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-sobre-espacios-que-no-son-una-red">9.2.5. Búsqueda sobre espacios que no son una red</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validacion-cruzada-anidada">9.2.6. Validación cruzada anidada</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#paralelizacion-de-la-validacion-cruzada-y-la-busqueda-en-red">9.2.7. Paralelización de la validación cruzada y la búsqueda en red</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-evaluacion-y-scoring">9.3. Métricas de evaluación y scoring</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tenga-en-cuenta-el-objetivo-final">9.3.1. Tenga en cuenta el objetivo final</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-binaria">9.3.2. Métricas para la clasificación binaria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tipos-de-errores">9.3.3. Tipos de errores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjuntos-de-datos-desequilibrados">9.3.4. Conjuntos de datos desequilibrados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-de-confusion">9.3.5. Matrices de confusión</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#teniendo-en-cuenta-la-incertidumbre">9.3.6. Teniendo en cuenta la incertidumbre</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#curvas-precision-recall-y-roc">9.4. Curvas precision-recall y ROC</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caracteristicas-operativas-del-receptor-roc-y-auc">9.4.1. Características operativas del receptor (ROC) y AUC</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-para-la-clasificacion-multiclase">9.5. Métricas para la clasificación multiclase</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metricas-de-regresion">9.6. Métricas de regresión</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uso-de-metricas-de-evaluacion-en-la-seleccion-de-modelos">9.6.1. Uso de métricas de evaluación en la selección de modelos</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#por-que-usar-pyspark-para-modelos-de-machine-learning-con-grandes-volumenes-de-datos">9.7. ¿Por qué usar <code class="docutils literal notranslate"><span class="pre">PySpark</span></code> para modelos de Machine Learning con grandes volúmenes de datos?</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Lihki Rubio, Ph.D.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <p>Lihki Rubio, Ph.D. All rights reserved.</p>
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>